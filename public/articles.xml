<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-07-06T04:33:56.121Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[Next.js应用程序路由器更新]]></title>
        <id>https://nextjs.org/blog/june-2023-update</id>
        <link href="https://nextjs.org/blog/june-2023-update"/>
        <updated>2023-07-06T03:02:01.177Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nextjs.org/blog/june-2023-update">Next.js App Router Update</a></p><p><strong>概要：</strong></p><p>Next.js 团队正在专注于改进性能、稳定性和开发者教育。他们已经设计了一种新的基础设施 ——App Router，以满足更大规模应用的需求。这个新工具允许开发者逐步迁移到新的 API，而不需要对整个应用进行重写。目前，团队正在探索更多使增量采用变得更容易的机会。在性能方面，他们正在专注于提高本地迭代速度、生产构建时间和无服务器性能。他们还在努力优化现有的 webpack 架构的性能，并计划用 Turbopack 替换 webpack。为了改善稳定性，他们正在修复 App Router 中的 bug，并感谢社区的反馈。最后，他们正在重新编写 Next.js 的文档，并计划发布更多的教育资源，以帮助开发者理解新的特性和概念。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[npm生态系统核心的巨大错误]]></title>
        <id>https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem</id>
        <link href="https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem"/>
        <updated>2023-07-06T03:01:33.182Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem">The massive bug at the heart of the npm ecosystem</a></p><p><strong>概要：</strong></p><p>文章是由前 npm CLI 团队的工程经理撰写，主要讨论了 npm 包的 "manifest confusion" 问题。npm 包的清单与其 tarball 独立发布，且从未完全验证过它们的内容是否一致。这导致任何使用公共注册表的工具或洞察可能易受攻击或不准确，恶意行为者可以在直接或转移依赖项中隐藏恶意软件和脚本而不被检测到。作者认为，应该进一步调查以确定受影响的注册表条目的范围，并尽快记录 npm 公共注册表 API 及其各自的请求 / 响应对象。同时，建议开发者联系任何已知依赖于 npm 注册表的 manifest 数据的工具作者 / 维护者，并确保他们在适当时开始使用包的内容作为元数据。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高级macOS命令 - saurabhs.org]]></title>
        <id>https://saurabhs.org/advanced-macos-commands</id>
        <link href="https://saurabhs.org/advanced-macos-commands"/>
        <updated>2023-07-06T03:00:40.075Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://saurabhs.org/advanced-macos-commands">Advanced macOS Commands - saurabhs.org</a></p><p><strong>概要：</strong></p><p>文章介绍了 macOS 系统中的一些高级命令行工具，包括 Unix 标准工具和 macOS 特有的功能。这些工具包括：caffeinate 用于设置 Mac 的睡眠行为；pbcopy 和 pbpaste 用于与系统剪贴板交互；networkQuality 用于测量互联网速度；sips 用于图像操作；open 用于打开文件和应用程序；textutil 是文档文件转换器；mdfind 和 mdls 用于使用 Spotlight 进行搜索；screencapture 用于截屏；taskpolicy 用于控制进程的调度；say 是文本转语音引擎；pmset 用于配置电源管理；networksetup 用于配置网络设置；softwareupdate 用于管理操作系统更新；system_profiler 用于查看系统信息。每个工具都有详细的使用说明和例子，可以通过运行 man <command> 查看完整的文档。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[现代JavaScript中的安全数据获取]]></title>
        <id>https://www.builder.io/blog/safe-data-fetching</id>
        <link href="https://www.builder.io/blog/safe-data-fetching"/>
        <updated>2023-07-06T02:59:43.875Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/safe-data-fetching">Safe Data Fetching in Modern JavaScript</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了 JavaScript 中 Fetch 函数的使用方法和常见问题，作者指出直接使用 Fetch 可能会遇到错误处理不当和信息丢失等问题。为了解决这些问题，作者提出了创建自定义错误类和封装 Fetch 函数的方法，使得错误处理更加智能和方便。但是，这种方法仍然需要开发者每次都写一定量的样板代码。因此，作者推荐使用 Axios、Redaxios 和 Wretch 等开源解决方案，它们可以自动处理上述问题，同时还有更多的文档、测试和社区支持。无论选择哪种方式，作者强调要正确地获取数据，以保证用户体验和团队效率。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[现代Javascript：过去10年中你错过的一切]]></title>
        <id>https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years</id>
        <link href="https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years"/>
        <updated>2023-07-06T02:59:21.311Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years">Modern Javascript: Everything you missed over the last 10 years</a></p><p><strong>概要：</strong></p><p>这篇文章是一份 JavaScript 的速查表，作者总结了近年来在现代浏览器中广泛支持的 JavaScript 新语法和功能。包括内置数组函数、const/let 关键字、空值合并和可选链运算符、Async/Await 关键字、箭头函数、for...of 循环、异步迭代、类、get/set 函数、函数默认参数、命名参数、剩余参数、Object.assign 和展开运算符、解构、简写函数、Promise.all、模板字面量、代理以及模块导入 / 导出等。每个主题都附有示例代码和进一步文档的链接。此外，作者还提供了其他参考资源，如 Map、Set、生成器、严格模式、数组方法、对象静态方法、反射、URL 等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ember 5.0发布]]></title>
        <id>https://blog.emberjs.com/ember-5-0-released/</id>
        <link href="https://blog.emberjs.com/ember-5-0-released/"/>
        <updated>2023-07-06T02:53:30.631Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.emberjs.com/ember-5-0-released/">Ember 5.0 Released</a></p><p><strong>概要：</strong></p><p>EmberJS 5.0 代表了开发者对 Ember 生态系统稳定性和可靠性的承诺。Ember 团队努力去除所有弃用的部分，并向 Polaris 迈进。这篇文章介绍了我们的发布策略，如何升级，预期结果，以及被移除的过时 API。
这是根据 RFC 830 提出的新发布策略和目标下的第一个主要版本。总结来说，每 12 个小版本，Ember 将发布一个新的主要版本，移除任何针对该主要版本的过时代码。
在引入新功能时，Ember 通常旨在在小版本中发布新功能，同时为现有代码提供向后兼容性，同时让开发者有机会尝试新功能。这种方法减少了团队面临的主要升级挑战，相比于制作带有大量新功能的大型、突破性、引人注目的主要版本。
在 Ember 4.x 的小版本中，我们添加了一些特性（当然还有各种错误修复）：
在 Ember 4.1 中，我们发布了一系列改善生活质量的改进：
缓存昂贵 getter 的 @cached 装饰器
@service 装饰器，所以你不再需要导入 {inject as service}
Ember 路由器上的刷新方法，使整个当前路由树的数据刷新更容易
在 Ember 4.4 中，我们发布了一个 {{unique-id}} 助手，使编写可访问表单更容易，并通过改进 setupTest 的蓝图使测试定制更容易。
在 Ember 4.5 中，我们使得可以使用普通的 JavaScript 函数作为助手：不再需要用 helper () 包裹它们！
我们还发布了一个新的测试原语，renderSettled</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CommonJS是不会消失的]]></title>
        <id>https://bun.sh/blog/commonjs-is-not-going-away</id>
        <link href="https://bun.sh/blog/commonjs-is-not-going-away"/>
        <updated>2023-07-06T02:48:37.350Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bun.sh/blog/commonjs-is-not-going-away">CommonJS is not going away</a></p><p><strong>概要：</strong></p><p>文章讨论了 JavaScript 的未来，特别是关于 CommonJS 和 ES 模块（ESM）的使用。尽管 ESM 被视为 JavaScript 的未来，但 CommonJS 仍然有其存在的价值。数据显示，ESM 在 npm 上的使用率为 9%，而 CJS（CommonJS）的使用率为 73.6%。CommonJS 在 2009 年开发并由 Node.js 推广，它允许文件将属性分配给名为 exports 的特殊变量，然后其他文件可以通过特殊的 require 函数引用 exports 对象的属性。相比之下，ESM 在 2015 年作为 ES6 的一部分引入，它使用 export 关键字声明其导出，并使用 import 关键字从其他文件导入。与 CommonJS 不同，ESM 设计用于在浏览器中工作，预期文件会通过网络加载，这就是 ES 模块被称为异步的原因。文章还指出，CommonJS 启动速度更快，允许动态模块加载，并且已经在 npm 发布了数百万个模块。最后，Bun v0.6.5 开始原生实现 CommonJS，而且 Bun 也增加了对__esModule 注解的支持，这是 CommonJS 模块表明 exports.default 应被解释为默认导出的事实标准方式。总的来说，CommonJS 已经在这里并将继续存在，Bun 将其视为一等公民。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Remotion 4.0 | Remotion | 在React中以编程方式制作视频]]></title>
        <id>https://www.remotion.dev/blog/4-0</id>
        <link href="https://www.remotion.dev/blog/4-0"/>
        <updated>2023-07-06T02:47:30.098Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.remotion.dev/blog/4-0">Remotion 4.0 | Remotion | Make videos programmatically in React</a></p><p><strong>概要：</strong></p><p>Remotion 4.0 发布了最大的更新，为每个工作流程带来了重大改进。这次更新引入了 Remotion Studio，并增加了一些方便的功能。现在，用户可以通过图形界面直接编辑数字、字符串、数组、对象、枚举和日期等属性，甚至可以可视化和编辑嵌套的数据结构。此外，该版本还增加了渲染按钮，用户只需按下按钮就可以渲染资产。新版本还使用 Rust 二进制文件加速了当前和未来的功能，并内置了 FFmpeg。此外，Remotion 4.0 还提供了对 WebP 和 PDF 生成的支持，简化了数据驱动视频的制作，并升级了所有模板以使用新特性。此外，该版本还增加了许多新功能，包括 @remotion/rive 包、@remotion/shapes 包、@remotion/tailwind 包、音频编解码器的调整、Lambda 的改进、新的 PHP 和 Go SDKs、播放器的改进、ES 模块支持、字体选择器、新的核心 API 等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用Rust写一个Node库]]></title>
        <id>https://blog.metlo.com/writing-a-node-library-in-rust/</id>
        <link href="https://blog.metlo.com/writing-a-node-library-in-rust/"/>
        <updated>2023-07-06T02:34:14.724Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.metlo.com/writing-a-node-library-in-rust/">Writing a Node Library in Rust</a></p><p><strong>概要：</strong></p><p>Metlo 是一个开源 API 安全工具，可以在 15 分钟内设置完成，对你的端点进行清单，检测恶意行为者并实时阻止恶意流量。通过使用 Rust 编程语言，Metlo 能够创建一个 C 兼容库，这样就可以用各种 FFI 库或低延迟通信系统（如 GRPC 或管道）来使用它。文章中以 Node.js 为例，介绍了如何利用基于 Rust 的库 Neon 来实现，并探讨了 Rust 在处理不同任务时的性能提升。Neon 可以让我们在 Node.js 代码中运行 Rust 代码。Metlo 使用这些绑定来支持多个框架，几乎无需配置即可使用。在 Metlo，他们能够支持所有三种 node 框架，因为他们的核心逻辑现在都是用 rust 编写的。此外，他们的 rust 代理是内存安全的，非阻塞的，并且最多只会增加几百微秒的延迟。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bun v0.6.10]]></title>
        <id>https://bun.sh/blog/bun-v0.6.10</id>
        <link href="https://bun.sh/blog/bun-v0.6.10"/>
        <updated>2023-06-28T14:24:16.954Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bun.sh/blog/bun-v0.6.10">Bun v0.6.10</a></p><p><strong>概要：</strong></p><p>我们正在招聘 C/C++ 和 Zig 工程师来构建 JavaScript 的未来！加入我们的团队→最近，我们对 Bun 进行了许多更改，以下是一些重要更新：

v0.6.0 - 引入 bun build，Bun 的新 JavaScript 打包器。
v0.6.2 - 性能提升：JSON.parse 速度提高 20%，Proxy 和 arguments 速度提高 2 倍。
v0.6.3 - 实现 node:vm，对 node:http 和 node:tls 进行了大量修复。
v0.6.4 - 实现 require.cache，process.env.TZ，并使 bun test 速度提高 80%。
v0.6.5 - 对 CommonJS 模块的原生支持（之前，Bun 将 CJS 转换为 ESM）。
v0.6.6 - bun test 的改进，包括 Github Actions 支持，test.only ()，test.if ()，describe.skip () 以及 15 + 个 expect () 匹配器；还有使用 fetch () 进行文件上传。
v0.6.7 - Node.js 兼容性改进，以解决 Discord.js、Prisma 和 Puppeteer 的问题。
v0.6.8 - 引入 Bun.password，bun test 中的 mocking 和 toMatchObject ()。
v0.6.9 - 内存使用减少，支持非 ascii 文件名。

此外，我们对 CommonJS 的支持也有所改善，使得在 Bun 中加载 npm 包更加可靠。我们修复了与加载 CommonJS 模块相关的许多崩溃，并改进了我们的 CommonJS 模块加载器，使其更兼容 Node.js。

我们还修复了 Bun 客户端 WebSocket 实现中的一个编码错误，这可能会导致 latin1 编码的文本帧被截断。感谢这些更改，puppeteer 在 Bun 中的支持已经得到改善。

另外，我们对 bun:test 进行了改进，现在支持更多的匹配</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布v6.0.0 - styled-components/styled-components]]></title>
        <id>https://github.com/styled-components/styled-components/releases/tag/v6.0.0</id>
        <link href="https://github.com/styled-components/styled-components/releases/tag/v6.0.0"/>
        <updated>2023-06-28T14:22:35.169Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/styled-components/styled-components/releases/tag/v6.0.0">Release v6.0.0 · styled-components/styled-components</a></p><p><strong>概要：</strong></p><p>这篇文章是关于一个版本更新的说明，主要包含以下改动：

在此版本中进行了一些修复和改进，例如防止样式属性上的 prop 渗漏，通过 "CSS" 命名空间来传输 csstype，提升 stylis 至 4.3 版本，并减少了一些不必要的分支逻辑。

在 v6 版本中有一些重大变化，包括现在使用 stylis v4（如果使用 stylis-plugin-rtl，你需要升级到新版本），styled-components 现在提供自己的类型；如果你过去安装过 @types/styled-components，你会想要移除它。此外，还删除了 $as 和 $forwardedAs props（使用 as 或 forwardedAs 替代），以及自动 prop 过滤；对于你不希望传递给子组件 / HTML 的内容，使用瞬态 props（$ 前缀）。

StyleSheetManager 也做出了一些更改，比如用 enableVendorPrefixes prop 替换了 disableVendorPrefixes，取消了自动供应商前缀；如果你需要支持旧的浏览器，可以使用上述 prop 轻松重新启用。

此外，还删除了已弃用的 withComponent API（87f511a）；现在需要使用 "as" prop。并且需要 node >= 14。

完整的更改日志可以查看：v5.3.7...v6.0.0。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对Svelte(Kit)的看法，一年后30亿次的请求]]></title>
        <id>https://claudioholanda.ch/en/blog/svelte-kit-after-3-billion-requests/</id>
        <link href="https://claudioholanda.ch/en/blog/svelte-kit-after-3-billion-requests/"/>
        <updated>2023-06-28T02:20:57.195Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://claudioholanda.ch/en/blog/svelte-kit-after-3-billion-requests/">Thoughts on Svelte(Kit), one year and 3 billion requests later</a></p><p><strong>概要：</strong></p><p>去年，我的公司接到了建设一个新闻网站的任务。自从项目上线以来，它经历了显著的观众增长，每天处理数十万的访客。在过去的 12 个月中，每个访客都在页面及其组件上进行导航和交互，大约产生了 30 亿次请求。

我选择 Svelte 作为这个项目的开发框架，并分享了我认为使用 Svelte 和 SvelteKit 工作的好坏两面。

我们的客户给我们带来了一个多年前制作的网站，该网站采用了旧技术，难以添加新功能，性能差，且垂直基础设施昂贵。经过几次会议，我们得出的结论是，最好的方法是暂停旧网站的开发，使用最佳技术和实践从头开始构建一个新的。考虑到这个项目的可塑性和可扩展性需求，还需要从零开始构建一个新的 CMS。

SvelteKit 具有强大的 SSR 解决方案，因此我选择了它。尽管 React 是一个拥有庞大社区和繁荣生态系统的优秀反应式库，但一旦你离开这条路径，你可能会在某个时候遇到麻烦。而有些项目你不想（或不能）因为你选择的 UI 开发工具而冒险遇到麻烦。所以我们选择了 Svelte/SvelteKit 而不是 React/Next.js。

然而，Svelte 也存在一些问题，比如缺乏 “Svelte” 组件，很多项目都是一个人的军队，缺乏已经建立的模式和优秀的教程等。但总的来说，Svelte 对于我们的团队</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - mrjooz/password-generator: 密码生成工具]]></title>
        <id>https://github.com/mrjooz/password-generator</id>
        <link href="https://github.com/mrjooz/password-generator"/>
        <updated>2023-06-28T02:16:42.518Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/mrjooz/password-generator">GitHub - mrjooz/password-generator: 密码生成工具</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了在使用 Git 时，如果已经存在与提供的分支名相同的标签，可能会导致一些问题。因为很多 Git 命令同时接受标签和分支名，所以创建这个分支可能会引发意外的行为。作者询问读者是否确定要创建这个分支。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过使用Node.js的AsyncLocalStorage来避免参数钻取| pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/avoid-parameter-drilling-by-using-the-node-js-asynclocalstorage/</id>
        <link href="https://pawelgrzybek.com/avoid-parameter-drilling-by-using-the-node-js-asynclocalstorage/"/>
        <updated>2023-06-28T02:12:40.147Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/avoid-parameter-drilling-by-using-the-node-js-asynclocalstorage/">Avoid parameter drilling by using the Node.js AsyncLocalStorage | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>虽然全局变量被认为是一种不好的做法，但它可能是共享上下文的最简单形式。在这个例子中，我定义了全局变量 context，并用它在主函数和 logger 函数之间共享 uuid 值。这种方法对于同步代码来说工作得很好，但是当我们引入异步操作时，问题就出现了。让我通过添加一个 http 服务器来说明这个问题：每个后续的请求都会更新全局上下文，logger 函数总是记录 uuid 的最后一个值，而不一定是与请求相关的那个值。将 uuid 作为参数传递给 logger（参数钻取）或将其粘贴到 req 对象是解决此问题的常见解决方案。尽管如此，它们都可能很快变得繁琐。

自 Node.js 13.10 以来，AsyncLocalStorage 类提供了一种在 web 请求或任何其他异步操作的生命周期内存储特定上下文数据的方法。它类似于不同编程语言中使用的线程本地存储（TLS）概念。让我们利用这个 API 并重写我们的示例：现在，所有连续的请求都将记录正确的 uuid 值，而无需担心相互干扰。关联 ID 只是 AsyncLocalStorage API 的许多用例之一。它可以用于存储当前用户、事务 ID、报告数据等。

Node.js AsyncLocalStorage API 的广泛用例激发了社区成员提出 JavaScript 的异步上下文。我希望这个提案能够迅速成为 ECMAScript 标准的一部分。

感谢 Syntax.fm 的一集启发了我去探索这个主题并写下这篇文章。感谢 Wes 和 Scott 创造的优秀内容！</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在焦点上刷新React服务器组件]]></title>
        <id>https://buildui.com/recipes/refresh-react-server-component-on-focus</id>
        <link href="https://buildui.com/recipes/refresh-react-server-component-on-focus"/>
        <updated>2023-06-28T02:08:39.348Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://buildui.com/recipes/refresh-react-server-component-on-focus">Refresh React Server Component on Focus</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 <RefreshOnFocus /> 的组件，它可以被插入到 Next.js 应用中的任何 React 服务器组件中，使其在浏览器窗口被聚焦时刷新。页面上的卡片使用与它们的动态数据相关的键来运行 CSS 动画，每当它们的数据发生变化时都会触发动画。文章还提供了代码和使用方法，以及使用的库 ——Next.js 13 App Directory。同时，文章也邀请读者加入 Build UI Newsletter，以便在发布新的配方时接收通知。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布v1.18.0 - remix-run/remix]]></title>
        <id>https://github.com/remix-run/remix/releases/tag/remix%401.18.0</id>
        <link href="https://github.com/remix-run/remix/releases/tag/remix%401.18.0"/>
        <updated>2023-06-28T02:06:28.873Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/remix-run/remix/releases/tag/remix%401.18.0">Release v1.18.0 · remix-run/remix</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了 Remix 1.18.0 的新特性和改进。包括：

1. 稳定的 V2 开发服务器：这个新版本正式稳定化了 "New Dev Server"，并带有 HMR/HDR。

2. JSON/Text 提交：如果你不是 FormData 的粉丝，Remix 1.18.0 更新了对 react-router-dom@6.14.0 的支持，它带来了在 useSubmit/fetcher.submit 中选择 application/json 或 text/plain 编码的支持，并添加了相应的 navigation.json/navigation.text 和 fetcher.json/fetcher.text 字段。

3. 视口驱动的预获取：Link 组件现在可以通过新的 <Link prefetch="viewport"> 属性值自动预获取路由数据和 JS 模块。

4. 更新的 ESLint 配置：我们已经更新了 @remix-run/eslint-config，以继承来自 @typescript-eslint/recommended 的推荐规则集，而不是手动维护我们自己的 TS 相关规则。

5. 性能改进：我们过去几周大量投入到性能提升上，你可能会看到一些改善（大约快 10%），但我们也亲眼看到在一些极端情况下构建和重建时间大幅缩短。

此外，还修复了一些问题，包括使用 React 17 时的类型问题、pathless 布局路由下的嵌套路径段的错误等，并更新了 React Router 依赖项至最新版本。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用键盘锁API实现更好的全屏模式 - Chrome开发人员]]></title>
        <id>https://developer.chrome.com/blog/better-full-screen-mode/</id>
        <link href="https://developer.chrome.com/blog/better-full-screen-mode/"/>
        <updated>2023-06-27T03:01:02.572Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/blog/better-full-screen-mode/">Better full screen mode with the Keyboard Lock API - Chrome Developers</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了如何使用键盘锁 API 来在全屏模式下捕获 Escape 键。作者指出，当用户在全屏游戏中打开一个对话框，本能地用 Escape 键取消时，可能会被强制退出全屏模式，这是由于对话框和全屏模式对 Escape 键的 “争夺”。默认情况下，全屏模式总是胜出。但通过使用键盘锁 API，可以让对话框成为 Escape 键的 “赢家”。该 API 可以在 navigator.keyboard 上使用，lock () 方法可以在启用后捕获物理键盘上所有键的按键。此方法只能捕获操作系统授权访问的键，幸运的是 Escape 键就是其中之一。如果你的应用有全屏模式，可以在请求全屏时捕获 Escape 键，以此作为渐进增强的手段。当用户离开全屏模式时，通过 Keyboard 接口的 unlock () 方法解锁（即不再捕获）键盘。这样，在全屏模式下，按下 Escape 键将默认取消对话框。如果用户长按 Escape 键，仍然可以退出全屏模式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在VSCode中提高生产力的6个快速技巧]]></title>
        <id>https://techhub.iodigital.com/articles/6-vscode-tips</id>
        <link href="https://techhub.iodigital.com/articles/6-vscode-tips"/>
        <updated>2023-06-27T03:00:42.843Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://techhub.iodigital.com/articles/6-vscode-tips">6 Quick Tips to Boost Your Productivity in VSCode</a></p><p><strong>概要：</strong></p><p>这篇文章分享了六个 VSCode 的使用技巧，帮助开发者优化工作流程。1. 通过快捷键 cmd + option + o（Windows 上为 Shift + Alt + o）可以方便地删除无用的引入，使代码库更整洁。2. 在 VSCode 中，可以通过 F2 键轻松重命名变量，系统会自动更新代码中所有该变量的实例，节省时间并保证一致性。3. 对于频繁使用的命令或扩展，可以设置快捷键，提高工作效率。在 “代码> 首选项 > 键盘快捷方式” 中搜索需要的操作，双击快捷方式列并设定你喜欢的快捷键。4. 可以设置一个快速修复 ESLint 问题的自定义快捷键。将以下代码复制到 keybindings.json 文件中，并分配一个未被 VSCode 使用的键组合，即可立即触发 ESLint 的自动修复功能。5. VSCode 内置的 “快速修复” 功能能够显示当前上下文所有可用的快速修复方案，例如添加缺失的引入、修复 linting 问题或向单行箭头函数添加花括号。6. 可以创建一个 “快速修复：添加所有缺失的引入” 的快捷键，比如设定为 cmd + '，当遇到未解决的引入时，只需使用这个快捷键就能自动添加必要的引入，无需手动搜索、输入和导入。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bright - 语法高亮的React服务器组件]]></title>
        <id>https://bright.codehike.org/</id>
        <link href="https://bright.codehike.org/"/>
        <updated>2023-06-26T10:56:40.259Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bright.codehike.org/">Bright - Syntax Highlighting React Server Component</a></p><p><strong>概要：</strong></p><p>这篇文章主要讲述了 React 服务器组件用于语法高亮的内容。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023年的React Ecosystem。]]></title>
        <id>https://dev.to/ihteshamulhaq510/react-ecosystem-in-2023-5aj4</id>
        <link href="https://dev.to/ihteshamulhaq510/react-ecosystem-in-2023-5aj4"/>
        <updated>2023-06-26T01:58:53.568Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/ihteshamulhaq510/react-ecosystem-in-2023-5aj4">React Ecosystem in 2023.</a></p><p><strong>概要：</strong></p><p>这篇文章主要介绍了 2023 年的 React 生态系统，包括一些可供学习和成为 React 开发者的库。最近，推出了一款名为 million.js 的工具，它使 React 的速度提高了 70%。对于初学者来说，选择正确的库可能相当具有挑战性。

文章列举了一些 React 库，包括构建工具（如 vite、nextjs、Webpack）、路由（如 react router、tanstack router）、客户端状态管理（如 redux toolkit、zustand）、服务器状态管理（如 tanstack query、redux-toolkit query、Apollo Client、jotai）、表单处理（如 Formik、React Hook Form）、测试（如 Vitest、React Testing library、Play-write）、样式（如 Tailwindcss、Styled-components、Emotion、Bootstrap）、UI 组件库（如 Material UI、Man time UI、Ant Design、Chakra UI、Headless UI (tailwindcss)、DaisyUI (Tailwindcss)、shadcn UI (Tailwindcss)、React Bootstrap）、动画（如 React Spring、Framer motion）、数据可视化（如 Victory charts、React Charts js、Recharts）、表格（如 Tanstack table）、国际化（如 react-i18next、formatjs）以及开发工具（如 react developer tools、Redux dev tool、testing playground、react hook form dev tools、AxeDev Tool (Accessibility)、Tanstack query dev tools）。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第四部分：编写简洁高效的React代码--最佳实践和优化技术]]></title>
        <id>https://dev.to/sathishskdev/part-4-writing-clean-and-efficient-react-code-best-practices-and-optimization-techniques-423d</id>
        <link href="https://dev.to/sathishskdev/part-4-writing-clean-and-efficient-react-code-best-practices-and-optimization-techniques-423d"/>
        <updated>2023-06-26T01:58:29.603Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/sathishskdev/part-4-writing-clean-and-efficient-react-code-best-practices-and-optimization-techniques-423d">Part 4: Writing Clean and Efficient React Code- Best Practices and Optimization Techniques</a></p><p><strong>概要：</strong></p><p>本文是 "2023 年 React 最佳实践" 系列的第四部分，探讨了如何编写清晰、高效的 React 应用程序代码。以下是一些最佳实践：

1. 实现错误边界来优雅地处理组件错误。
2. 对于功能组件，使用 React.memo 以避免不必要的重渲染。
3. 使用 Linting 工具（如 ESLint）来提高代码质量和一致性。
4. 避免默认导出，因为它可能使理解哪些组件被导入和在其他文件中使用变得困难。
5. 使用对象解构，这是一种更简洁、优雅的方式来提取对象属性。
6. 使用片段来避免在渲染多个元素时产生不必要的包装 div。
7. 优先传递对象而不是多个 props。
8. 使用箭头函数，它提供了更简洁的语法和词法范围。
9. 使用枚举代替数字或字符串。
10. 对布尔 props 使用简写。
11. 避免使用索引作为 key props。
12. 在小函数中使用隐式返回。
13. 使用 PropTypes 进行类型检查。
14. 优先使用模板文字。
15. 避免使用庞大的组件。

以上最佳实践可以提高代码的可维护性、性能和可读性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[跟大家聊聊当下卖课的现状]]></title>
        <id>https://blog.meathill.com/share/lets-talk-about-be-a-tutorial-video-creator.html</id>
        <link href="https://blog.meathill.com/share/lets-talk-about-be-a-tutorial-video-creator.html"/>
        <updated>2023-06-25T13:52:19.567Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.meathill.com/share/lets-talk-about-be-a-tutorial-video-creator.html">跟大家聊聊当下卖课的现状</a></p><p><strong>概要：</strong></p><p>文章作者分享了他在制作在线课程方面的经验。首先，他提到了平台分成问题，大部分平台会收取 50% 的服务费，再加上苹果设备用户需要支付 30% 的税，最终讲师能拿到的收入并不多。其次，课程内容的选择也是一个问题，新人讲师往往无法接到热门选题，而自己感兴趣的选题可能平台不愿意接受。此外，如果想自行销售课程，除非有大量的粉丝基础，否则难以获得成功。最后，由于网络技术更新快速，课程的生命周期较短，因此很难实现稳定的收入。总的来说，作者建议想做在线课程的人在开始前应该仔细考虑各种因素，找出更适合自己的方向。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React中的远程传输：定位、堆叠上下文和传送门]]></title>
        <id>https://www.developerway.com/posts/positioning-and-portals-in-react</id>
        <link href="https://www.developerway.com/posts/positioning-and-portals-in-react"/>
        <updated>2023-06-25T13:45:53.262Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developerway.com/posts/positioning-and-portals-in-react">Teleportation in React: Positioning, Stacking Context, and Portals</a></p><p><strong>概要：</strong></p><p>这篇文章详细讨论了 CSS 定位的工作原理，堆叠上下文（Stacking Context）是什么，如何使用 CSS 逃离 overflow:hidden，为什么我们不能用 CSS 做所有事情而需要 Portals，以及 Portals 是如何工作的。文章首先解释了 CSS 的绝对定位，并指出绝对并不完全是绝对的，它实际上是相对于设置了任何值的最近元素的位置。然后，文章介绍了堆叠上下文，这是一个三维的视角来看待 HTML 元素。接着，文章讨论了如何使用 CSS 逃离内容剪裁，为什么我们不能用 CSS 做所有事情而需要 Portals，以及 Portals 是如何实际工作的。文章还深入探讨了 React Portal 如何解决这个问题，以及 React 生命周期，重渲染，Context 和 Portals 之间的关系。最后，文章总结了在使用 Portals 时的规则：在 React 中发生的事情保持在 React 层次结构中，在 React 之外的事情遵循 DOM 结构规则。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - a16z-infra/ai-getting-started：一个用于周末项目的Javascript AI入门栈，包括图像/文本模型、矢量存储、授权和部署配置。]]></title>
        <id>https://github.com/a16z-infra/ai-getting-started</id>
        <link href="https://github.com/a16z-infra/ai-getting-started"/>
        <updated>2023-06-25T13:45:22.332Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/a16z-infra/ai-getting-started">GitHub - a16z-infra/ai-getting-started: A Javascript AI getting started stack for weekend projects, including image/text models, vector stores, auth, and deployment configs</a></p><p><strong>概要：</strong></p><p>这篇文章是关于如何开始使用 AI 的指南，包括了一些主要技术栈和操作步骤。技术栈包括 Auth：Clerk、应用逻辑：Next.js、VectorDB：Pinecone / Supabase pgvector、LLM Orchestration：Langchain.js、图像模型：Replicate、文本模型：OpenAI、文本流：ai sdk、部署：Fly 等。

文章详细介绍了如何在本地测试这个技术栈，并理解每个组件的工作方式。首先需要从 Github 账户复制并克隆仓库，然后安装依赖项。接着填写 Clerk Secrets、OpenAI API key、Replicate API key、Pinecone API key 和 Supabase API key。注意，默认情况下，此模板使用 Pinecone 作为向量存储，但你可以轻松开启 Supabase pgvector。

之后，生成嵌入并将其存储在向量数据库中以供未来查询。然后在本地运行应用程序进行测试。最后，将应用程序部署到 fly.io。

此外，文章还介绍了如何为该仓库做出贡献，包括代码贡献工作流程和其他贡献方式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是CDN？内容交付网络的无偏见指南]]></title>
        <id>https://calibreapp.com/blog/content-delivery-networks-guide</id>
        <link href="https://calibreapp.com/blog/content-delivery-networks-guide"/>
        <updated>2023-06-25T13:43:12.424Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://calibreapp.com/blog/content-delivery-networks-guide">What is a CDN? An Unbiased Guide to Content Delivery Networks</a></p><p><strong>概要：</strong></p><p>内容分发网络（CDN）是提高网站性能和可靠性的最佳方式之一。它可以帮助提高页面速度，抵御拒绝服务攻击，并优化内容以实现更快的传输。选择合适的 CDN 对于网站来说是一个重要的决定，因此你需要进行研究。然而，大部分关于 CDN 的搜索结果都来自销售 CDN 的公司，这让人很难相信由销售人员写的博客文章。好消息是我们不销售 CDN，但作为网络性能专家，我们对此有深入了解。我们编写了这篇指南，帮助你在选择 CDN 时做出明智的决定。

CDN 是全球分布的服务器网络，可以托管你的内容并快速将其传送给访问者。CDN 通过减少延迟、提高可靠性，甚至优化内容以实现更快的传输，来支持你的主机服务器。CDN 就像是遍布全球的小型本地仓库。当访问者请求内容时，这些本地仓库从你的中央仓库（主机服务器）接收内容并存储起来。这样，我们可以快速可靠地传输内容，因为 CDN 服务器的位置遍布全球，如果一个服务器出现故障，其他服务器可以接替其工作。

CDN 的工作原理是在全球各地的战略位置拥有服务器，从而更快地为你传送内容。CDN 通过在全球范围内提前存储你的内容来解决这些问题。因此，当有请求时，CDN 会将数据存储在悉尼的服务器上，以便更快地传送到新西兰。

CDN 的好</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布Svelte 4]]></title>
        <id>https://svelte.dev/blog/svelte-4</id>
        <link href="https://svelte.dev/blog/svelte-4"/>
        <updated>2023-06-25T13:40:29.417Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://svelte.dev/blog/svelte-4">Announcing Svelte 4</a></p><p><strong>概要：</strong></p><p>Svelte 4 稳定版已经发布，它主要是一个维护版本，提升了性能，改进了开发者体验，并对网站进行了更新。Svelte 4 的包大小减少了近 75%，从 10.6MB 降到 2.8MB，这意味着在执行 npm install 时等待时间更短。此外，Svelte 的依赖项数量也从 61 个大幅度减少到 16 个，这不仅可以加快用户的下载速度，还可以降低供应链攻击的风险。对于 Web 组件的使用者来说，最大的变化是改变了使用 Svelte 来创建自定义元素的方式。此外，Svelte 4 还改进了 IDE 编写体验，更新了官方网站、文档和教程，并为即将发布的 Svelte 5 做好了准备。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 5.2的新关键词："using"。]]></title>
        <id>https://www.totaltypescript.com/typescript-5-2-new-keyword-using</id>
        <link href="https://www.totaltypescript.com/typescript-5-2-new-keyword-using"/>
        <updated>2023-06-25T13:23:00.586Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.totaltypescript.com/typescript-5-2-new-keyword-using">TypeScript 5.2's New Keyword: 'using'</a></p><p><strong>概要：</strong></p><p>TypeScript 5.2 将引入一个新的关键字 - 'using'，你可以用它在离开作用域时处理任何带有 Symbol.dispose 函数的东西。

这基于 TC39 提案，该提案最近达到了第 3 阶段，表明它将被引入 JavaScript。'using' 对于管理诸如文件句柄、数据库连接等资源将非常有用。

Symbol.dispose 是 JavaScript 中的一个新的全局符号。任何赋予 Symbol.dispose 函数的东西都会被视为一个 “资源” - “具有特定生命周期的对象”，并可以与 using 关键字一起使用。

你还可以使用 Symbol.asyncDispose 和 await using 来处理需要异步处理的资源。

这将在继续之前等待 Symbol.asyncDispose 函数。这对于数据库连接等资源非常有用，你希望确保程序继续之前连接已经关闭。

使用案例：

文件句柄：通过节点中的文件处理器访问文件系统可能会因为 using 变得更容易。

数据库连接：管理数据库连接是 C# 中使用 using 的一个常见用例。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[99.9成功率！Mac运行赛博朋克2077，使用Game Porting Toolkit]]></title>
        <id>https://www.bilibili.com/read/cv24310042</id>
        <link href="https://www.bilibili.com/read/cv24310042"/>
        <updated>2023-06-25T13:03:57.380Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.bilibili.com/read/cv24310042">99.9成功率！Mac运行赛博朋克2077，使用Game Porting Toolkit</a></p><p><strong>概要：</strong></p><p>这篇文章主要介绍了如何在苹果 M 芯片 Mac 上运行赛博朋克 2077 游戏。首先，需要通过 Game Porting Toolkit 工具将 Direct3D 指令转译成 Metal 指令，使得 Windows 游戏能够在 Apple Silicon Mac 上运行。然后，作者详细介绍了准备所需资源、安装 macOS14 Beta、安装 Game Porting Toolkit、配置 Wine Prefix 环境和安装 Steam 等步骤。最后，通过 Wine 直接启动赛博朋克 2077 游戏。全程操作较为复杂，需要耐心且对计算机有一定的了解。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[具有稳定扩散性的风格化二维码]]></title>
        <id>https://antfu.me/posts/ai-qrcode</id>
        <link href="https://antfu.me/posts/ai-qrcode"/>
        <updated>2023-06-25T12:42:53.686Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/ai-qrcode">Stylistic QR Code with Stable Diffusion</a></p><p><strong>概要：</strong></p><p>这篇文章是作者分享如何使用 Stable Diffusion 和 ControlNet 创建一个既可以扫描的 QR 码又是一幅艺术插图的过程。首先，作者介绍了他对 AI 技术的兴趣，并提到了一些重要的工具和模型。然后，他详细描述了创建 QR 码图像的步骤，包括设置环境、生成 QR 码、将文本转化为图像、调整细节和放大图像等。最后，他展示了最终结果并总结了自己的学习经历。作者希望这篇文章能够给读者提供一些基础概念或启发他们开始自己的创作之旅。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工人们的KV在新的架构下比以前更快]]></title>
        <id>https://blog.cloudflare.com/faster-workers-kv-architecture/</id>
        <link href="https://blog.cloudflare.com/faster-workers-kv-architecture/"/>
        <updated>2023-06-21T15:28:20.529Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.cloudflare.com/faster-workers-kv-architecture/">Workers KV is faster than ever with a new architecture</a></p><p><strong>概要：</strong></p><p>Cloudflare 宣布了对 Workers KV 的重大性能改进，这一改进主要集中在显著提高冷读性能和降低延迟，甚至对于长尾访问模式也是如此。开发人员使用 KV 时，热读取性能很好，但他们会问为什么他们的 95% 分位延迟 —— 通常是在一个关键（或一组关键）上，这个关键最近没有被访问过或者在该地区没有被访问过 —— 比预期的要高。因此，Cloudflare 已经在幕后为 KV 开发了一个新的缓存层，使客户能够实现更频繁的热读取，减少最差情况下的延迟时间，更好地控制缓存 TTL，并且比以前的版本快得多。最好的部分是，使用 KV 的开发人员不需要改变任何东西就可以从这种增强的性能中受益。

Workers KV 是 Cloudflare 网络支持的针对读取密集型用例和应用程序设计的键值存储。KV 专注于读取密集型用例，使其能够在毫秒内提供热（缓存）读取，这使其成为存储每个应用程序或客户配置数据、路由配置、多变量（A/B 测试）配置，甚至需要快速提供的小资产数据的理想选择。你可以将任何可以序列化并且需要快速获取的东西存储在 KV 中，每个单独的键可以存储高达 25 MiB 的数据，总数据存储没有上限。

Cloudflare 已经重新设计了 Workers KV，由新的分层缓存实现驱动。这个实现是作为 Worker 服务编写的。我们重用了为平</p>]]></content>
    </entry>
</feed>