<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-08-04T00:27:44.512Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[Nuxt 3 的 24 个省时技巧]]></title>
        <id>https://masteringnuxt.com/blog/24-time-saving-tips-for-nuxt3</id>
        <link href="https://masteringnuxt.com/blog/24-time-saving-tips-for-nuxt3"/>
        <updated>2023-08-04T00:26:58.024Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://masteringnuxt.com/blog/24-time-saving-tips-for-nuxt3">24 Time Saving Tips for Nuxt 3</a></p><p><strong>概要：</strong></p><p>这篇文章列出了 24 个 Nuxt 的使用技巧，包括何时使用 /assets 和 /public 目录、如何理解通用渲染方式（以及它与 SPA 和 SSR 的区别）、如何添加基础缓存等。其中一些具体技巧包括懒加载组件、预渲染特定路由、使用内置键值存储、自动导入、控制 head 脚本的反应性、获取路由信息、处理客户端错误、嵌套路由、自定义 NuxtLink 组件、页面预取、外部链接、数据获取和关键参数、简单的授权、使用 useAsyncData 和 useFetch 函数、图像压缩、添加基础缓存、理解通用渲染的优点、在新标签页中打开 NuxtLinks、运行时配置和应用配置的选择等。此外，还推荐了一门名为 “Mastering Nuxt 3” 的课程。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原型的价值在于它所传递的洞察力，而不是代码。]]></title>
        <id>https://addyosmani.com/blog/prototypes/</id>
        <link href="https://addyosmani.com/blog/prototypes/"/>
        <updated>2023-08-04T00:13:43.421Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/prototypes/">The value of a prototype is in the insight it imparts, not the code.</a></p><p><strong>概要：</strong></p><p>原型的价值在于它能提供的洞察，而不是编写的代码。原型设计让我们可以快速且低成本地失败，或者获取决策所需的数据。它帮助回答 "如果我们尝试这个会怎么样？" 的问题。更重要的是，原型设计为我们提供了安全有效地失败的保护栏。失败是学习过程中不可或缺的一部分。

如果你有一个想要验证的想法，一个明确的反馈路径，或者需要进一步数据的提议，那么原型就是合适的工具。它提供关键的洞察来推动前进。通过创建一个你一直在考虑的特性或系统的粗糙版本，你获得了放弃这个想法或全力以赴的灵活性。这是一种帮助产品和工程团队做出关键业务决策的技能。

无论你正在开发的是网站、移动应用还是落地页，验证你的设计决策总是至关重要的。一些开发团队会延迟验证阶段，直到他们有一个几乎完整的解决方案。但这是一个极其危险的策略。因为我们都知道，问题出现得越晚，修复它的成本就越高。幸运的是，无论你处于设计过程的哪个点，都可以构建和测试你概念的具体形象 —— 一个原型。

原型并不专注于解决方案，而是专注于理解问题。它们问的问题是，"当我们尝试这个时会发生什么？" 也许我们会发现这是个好主意，但更可能的是，我们会了解到</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Replit 部署：速度快 3 倍，功能更丰富]]></title>
        <id>https://blog.replit.com/deployments-updates</id>
        <link href="https://blog.replit.com/deployments-updates"/>
        <updated>2023-08-02T06:11:19.296Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.replit.com/deployments-updates">Replit Deployments: 3x Faster and Even More Features</a></p><p><strong>概要：</strong></p><p>文章介绍了 Replit 在四月份发布的 Replit Deployments，这是一个从软件想法到生产的最快方式。该公司根据用户反馈重建了适用于生产级应用的托管基础设施。自四月份初次发布以来，Replit Deployments 进行了升级、修复 bug 和改进。其优点包括：应用托管在 Google Cloud VMs 上，更可靠稳定；为应用提供独立的 VM 资源，提高安全性和性能；可以控制何时向用户发布，以便在不影响生产的情况下修复应用；所有 VM 日志直接流向工作区的 Deployments 面板。此外，Replit Deployments 还通过减少读取磁盘时的限制、升级构建机器、修复部署过程中的 bug 等方式，使得具有大量包的 Repls 部署速度提高 2-3 倍。同时，该公司也一直在寻找新的方法确保每次点击 “部署” 都像魔术一样顺利，减少部署失败的情况。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么 DNS 仍然难学？]]></title>
        <id>https://jvns.ca/blog/2023/07/28/why-is-dns-still-hard-to-learn/</id>
        <link href="https://jvns.ca/blog/2023/07/28/why-is-dns-still-hard-to-learn/"/>
        <updated>2023-08-02T06:09:34.144Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jvns.ca/blog/2023/07/28/why-is-dns-still-hard-to-learn/">Why is DNS still hard to learn?</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了为什么学习和调试 DNS 问题很困难。首先，很多系统是隐藏的，比如解析器的缓存、你的电脑上哪个库代码正在进行 DNS 请求等。其次，处理隐藏系统的方法有：教人们隐藏系统是什么，以及通过 “鱼缸” 方法展示系统的一部分。作者建议扩展 DNS 以包含 “调试信息” 部分。此外，DNS 还有一些令人困惑的工具，例如 dig。对于这些工具，作者提出了改进的建议：解释输出、制作新的、更友好的工具，或者使 dig 的输出更友好。然后，DNS 还有一些奇怪的问题，例如负缓存、getaddrinfo 实现的差异等。最后，作者提到了其他两个原因：不频繁的接触和难以实验。文章最后，作者希望听到读者对学习 DNS 或其他神秘技术的困难之处的看法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redwood v6.0.0 现已发布]]></title>
        <id>https://community.redwoodjs.com/t/redwood-v6-0-0-is-now-available/5165</id>
        <link href="https://community.redwoodjs.com/t/redwood-v6-0-0-is-now-available/5165"/>
        <updated>2023-08-02T02:06:56.558Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://community.redwoodjs.com/t/redwood-v6-0-0-is-now-available/5165">Redwood v6.0.0 is now available</a></p><p><strong>概要：</strong></p><p>文章未提供内容，无法进行总结。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dnt - 发布 ESM 和 CommonJS 混合 npm 模块的最简单方法]]></title>
        <id>https://deno.com/blog/publish-esm-cjs-module-dnt</id>
        <link href="https://deno.com/blog/publish-esm-cjs-module-dnt"/>
        <updated>2023-08-02T01:27:12.050Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/publish-esm-cjs-module-dnt">dnt — the easiest way to publish a hybrid npm module for ESM and CommonJS</a></p><p><strong>概要：</strong></p><p>虽然浏览器和 JavaScript 已经取得了长足的进步，但编写和发布 JavaScript 模块仍然很痛苦。为了最大化采用，你的模块应该支持 CommonJS 和 ESM、带有 TypeScript 声明的 JavaScript，并能在 Deno、Node.js 和网络浏览器中工作。为了达到这个目标，许多人不得不使用复杂的发布流程或者维护两份具有略微不同模块语法的代码。dnt 是一个构建工具，可以将 Deno 模块转换成与 Node.js/npm 兼容的包。此外，转换后的包还支持 CommonJS 和 ESM，可以在 Node.js、Deno 和浏览器中运行，同时还支持 TypeScript 和 JavaScript。通过使用 dnt，你可以使用 TypeScript 等现代工具一次性编写模块，并将其转换以支持所有用例。当需要发布时，可以使用 dnt 将其导出为与 Node.js/npm 兼容的格式。此外，dnt 还可以与 GitHub Actions 配合使用，简化每次发布新版本时的操作。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区分前端框架的最重要因素]]></title>
        <id>https://themer.dev/blog/the-single-most-important-factor-that-differentiates-front-end-frameworks</id>
        <link href="https://themer.dev/blog/the-single-most-important-factor-that-differentiates-front-end-frameworks"/>
        <updated>2023-08-02T00:51:11.692Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://themer.dev/blog/the-single-most-important-factor-that-differentiates-front-end-frameworks">The single most impor­tant factor that dif­fer­enti­ates front-end frame­works</a></p><p><strong>概要：</strong></p><p>文章主要探讨了前端框架如何解决变更检测问题，即检测应用状态的变化以便相应地更新用户界面。主要对比了 React、Angular、Vue 和 Svelte 四个主要框架的变更检测方式。React 通过内部 API 直接更新状态，并在需要时重新渲染组件。Angular 则要求开发者自行处理状态变化并通知框架进行重新渲染，但这种方式在处理复杂应用时可能变得难以管理。Vue 则通过特殊工具监控状态对象的变化，从而实现变更检测。Svelte 采用编译时方法，通过分析组件代码的抽象语法树并在必要时更新 DOM。文章最后指出，选择适合应用需求的变更检测模式非常重要，否则将在项目生命周期中不断与之斗争。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[了解 React 服务器组件 - Vercel]]></title>
        <id>https://vercel.com/blog/understanding-react-server-components</id>
        <link href="https://vercel.com/blog/understanding-react-server-components"/>
        <updated>2023-08-02T00:15:52.124Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/understanding-react-server-components">Understanding React Server Components – Vercel</a></p><p><strong>概要：</strong></p><p>文章介绍了 React Server Components (RSCs) 的基本概念和应用，RSCs 扩展了 React 的基础功能，使其不仅是一个纯粹的渲染库，还能在框架内部整合数据获取和远程客户端 - 服务器通信。文章解释了为何需要创建 RSCs，它们最擅长的工作，以及何时使用它们。文章还讨论了 Next.js 如何通过 App Router 简化和增强 RSC 的实现细节。RSCs 可以帮助减少客户端 JavaScript 包的大小，提高加载性能。在 Next.js 中，RSCs 允许智能数据缓存、单次往返中的多次获取，以及自动 fetch () 请求去重，所有这些都最大限度地提高了将数据发送到客户端的效率。此外，你不再需要像 getServerSideProps () 和 getStaticProps () 这样的 Next.js 特定的页面级方法，这些方法对于单个组件来说控制力不够，而且往往会过度获取数据。总的来说，Next.js App Router 中的 React Server Components 是一种有效、安全、动态获取数据的强大工具，所有数据默认都是缓存的，以提供高性能的用户体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 中的可视化树迭代器]]></title>
        <id>https://blog.danieljanus.pl/2023/07/20/iterating-trees/</id>
        <link href="https://blog.danieljanus.pl/2023/07/20/iterating-trees/"/>
        <updated>2023-07-28T04:16:50.639Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.danieljanus.pl/2023/07/20/iterating-trees/">A visual tree iterator in Rust</a></p><p><strong>概要：</strong></p><p>作者分享了他在学习 Rust 编程语言的过程中，如何使用迭代器重写树打印函数的经历。他希望通过这种方式使代码更具可复用性，并能更容易地为 Cursive 实现一个树形视图。在这个过程中，他遇到了很多问题，但最终成功实现了功能。此外，他还分享了自己在学习过程中的一些心得和感悟，比如 Rust 的学习曲线初始阶段较为陡峭，需要花费大量时间去理解和掌握；而且，他发现在学习过程中反思错误并尝试改正是非常有价值的。最后，他推荐了 Amos 的博客，认为这是学习 Rust 的优秀资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在两分钟内创建标记符编辑器（使用 GitHub Copilot）]]></title>
        <id>https://dev.to/github/how-to-build-a-markdown-editor-in-two-minutes-with-github-copilot-khb</id>
        <link href="https://dev.to/github/how-to-build-a-markdown-editor-in-two-minutes-with-github-copilot-khb"/>
        <updated>2023-07-28T00:11:35.915Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/github/how-to-build-a-markdown-editor-in-two-minutes-with-github-copilot-khb">How to build a markdown editor in two minutes (with GitHub Copilot)</a></p><p><strong>概要：</strong></p><p>这篇博客文章介绍了如何使用 GitHub Copilot 在两分钟内构建一个 markdown 编辑器。首先，需要创建一个 Next.js 的 GitHub Codespace 模板，然后安装特定的依赖项，删除 index.js 文件中的代码，并通过注释提示 GitHub Copilot。然后触发 GitHub Copilot 的建议，保存文件并尝试运行。此外，还可以使用 Copilot 聊天来改善 markdown 编辑器的用户界面。但是，由于 GitHub Copilot 和其他生成 AI 工具是非确定性的，所以这些工具有时会生成不同的输出。作者还强调，虽然这个教程对今天（2023 年 6 月）仍然适用，但未来可能会过时。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Astro 2.9：视图转换（实验性） | Astro]]></title>
        <id>https://astro.build/blog/astro-290/</id>
        <link href="https://astro.build/blog/astro-290/"/>
        <updated>2023-07-27T06:17:03.682Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://astro.build/blog/astro-290/">Astro 2.9: View Transitions (experimental) | Astro</a></p><p><strong>概要：</strong></p><p>Astro 2.9 版本已经发布，新特性包括对视图过渡的实验性支持，重定向配置以及改进的脚本打包。现在，Astro 通过新的 <ViewTransitions /> 组件和 transition:animate 指令支持视图过渡，使得过渡更加顺畅，无需牺牲 MPA 的简单性。此外，重定向配置选项不再是实验性的，你可以在项目中安全地使用重定向。Astro 还改进了静态分析，使其能够确定哪些 < script > 标签需要一起打包，这使得脚本的使用在页面之间进行了优化，并将它们放在文档的头部，以尽可能早地下载。感谢社区贡献者 Ottomated 为这个新功能的开发做出的贡献。此版本还包括其他的错误修复和集成特性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 服务器组件提示]]></title>
        <id>https://echobind.com/post/react-server-components-tips</id>
        <link href="https://echobind.com/post/react-server-components-tips"/>
        <updated>2023-07-27T06:07:48.874Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://echobind.com/post/react-server-components-tips">React Server Components Tips</a></p><p><strong>概要：</strong></p><p>React 官方的数据获取解决方案为 React Server Components（RSC）。使用 RSC 需要深度集成打包器，且严格执行组件树结构和模块组合。使用 RSC 时，任何交互代码必须在特殊的客户端组件中完成。但是，RSC 也有诸多优点：可以在组件内部获取数据，避免客户端获取数据时常见的瀑布式获取，可以使用 <Suspense> 流数据以加快初始页面加载速度，可以在服务器上执行更多代码而无需将其发送到客户端，从而保持包大小较小。目前，唯一被广泛接受的 React Server Components 实现是 Next.js App Router。此外，还提供了一些使用 RSC 构建应用程序的技巧，如制作更多的组件，自由使用客户端组件，构建组件以便于组合，不要忘记共享组件等。最后，作为 Server Components 获取数据的对应部分，React 团队引入了 Server Actions 来执行变异。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - emilkowalski/vaul：React 的非样式抽屉组件。]]></title>
        <id>https://github.com/emilkowalski/vaul</id>
        <link href="https://github.com/emilkowalski/vaul"/>
        <updated>2023-07-26T04:40:19.231Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/emilkowalski/vaul">GitHub - emilkowalski/vaul: An unstyled drawer component for React.</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 Vaul 的 React 抽屉组件，可以用作平板和移动设备上的 Dialog 替代品。它使用 Radix 的 Dialog 原始组件，并受到一条推文的启发。要开始使用这个库，需要在项目中安装它，然后在应用程序中使用这个抽屉。文章还提供了几个例子以及 API 参考，包括 Root、Trigger、Content、Overlay、Title、Description、Close 和 Portal 等部分的详细说明。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Valibot，小于 1kb 的佐德替代品]]></title>
        <id>https://www.builder.io/blog/introducing-valibot</id>
        <link href="https://www.builder.io/blog/introducing-valibot"/>
        <updated>2023-07-26T04:10:17.404Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/introducing-valibot">Introducing Valibot, a < 1kb Zod Alternative</a></p><p><strong>概要：</strong></p><p>文章宣布了新的开源项目 Valibot，这是一个用于验证结构数据的模式库，与 Zod、Ajv、Joi 和 Yup 等相似。Valibot 的创新之处在于其 API 的模块化设计以及源代码的压缩优化，使得它能通过代码分割和压缩实现前所未有的包大小最小化，成为当前全栈空间创新的完美补充。Valibot 没有依赖性，可以在任何 JavaScript 或 TypeScript 项目中使用，以根据模式验证数据。作者 Fabian 介绍了 Valibot 的工作原理，它与其他解决方案的不同之处，以及它适合的使用场景。Valibot 的核心功能是创建模式，这可以与 TypeScript 中的类型定义进行比较。Valibot 几乎提供了与 TypeScript 相同的选项，例如，你可以用 partial 使对象的值变为可选，或者用 required 使它们变为必需。Valibot 是完全类型安全的，允许你推断模式的输入和输出类型。如果数据与模式不匹配，将抛出一个错误，带有有用的信息来修复问题。如果没有抛出错误，那么数据符合模式并返回类型。Valibot 的 API 设计部分基于 Zod，因为我们在各种项目中使用 Zod，并且它在新的 TypeScript 项目中几乎是标准的。尽管 API 在第一眼看起来与其他解决方案相似，但源代码的实施和结构却非常不同。Valibot 的 API 设计和源代码基于许多小而独立的函数，每个函数只有一个任务。这种模块化设计有几个优点，一方面，可以轻松地用外部代码扩展库的功能；另一</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 React Tweet - Vercel]]></title>
        <id>https://vercel.com/blog/introducing-react-tweet</id>
        <link href="https://vercel.com/blog/introducing-react-tweet"/>
        <updated>2023-07-26T03:12:03.586Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/introducing-react-tweet">Introducing React Tweet – Vercel</a></p><p><strong>概要：</strong></p><p>文章介绍了一个名为 react-tweet 的新工具，它可以将推特嵌入到任何 React 应用中，只需一行代码，且不会牺牲性能。与 Twitter 的原生嵌入相比，react-tweet 的客户端 JavaScript 少 35 倍。它支持 React 服务器组件，内置数据获取和缓存功能，并可与 Next.js、Vite、CRA 等任何 React 框架配合使用。传统上，嵌入推文需要使用 Twitter 的嵌入式 iframe，这会加载 560kb 的客户端 JavaScript，降低网站性能并导致布局移位。而使用 react-tweet，无需使用 iframes，只需一个简单的 React 组件即可。此外，它还改善了用户体验，使浏览器中的推文立即可见（无懒加载），并利用强大的 React 组件抽象进行构建。在对原生 Twitter 嵌入、iframe 嵌入和 react-tweet 进行比较后，react-tweet 所需的客户端 JavaScript 最少，只有 16kb。react-tweet 的工作原理是反向工程 Twitter 的嵌入 API，获取给定推文的数据，并以与 Twitter 的嵌入式 iframe 相同的样式呈现出来。你无需依赖 Twitter API v2 自己获取推文，从而节省了费用，也更容易将推文添加到你的网站上。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hono + htmx + Cloudflare 是一种新的堆栈 - Yusuke Wada]]></title>
        <id>https://blog.yusu.ke/hono-htmx-cloudflare/</id>
        <link href="https://blog.yusu.ke/hono-htmx-cloudflare/"/>
        <updated>2023-07-25T00:49:51.565Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.yusu.ke/hono-htmx-cloudflare/">Hono + htmx + Cloudflare is a new stack - Yusuke Wada</a></p><p><strong>概要：</strong></p><p>文章介绍了一种新的技术栈 Hono + htmx + Cloudflare。Hono 是一个 JavaScript 框架，包括 JSX 中间件，可用于编写 HTML，但仅限于服务器端渲染。htmx 是一个库，可以在不需要编写 JavaScript 的情况下启用 Ajax。这种技术栈还包括 Zod、Tailwind CSS、Cloudflare Workers 和 Cloudflare D1 等组件。Cloudflare D1 是一种在 Cloudflare 边缘运行 SQLite 的数据库服务，虽然目前处于 “alpha” 状态，不推荐用于生产使用，但已经非常快速，完全适合概念验证（PoC）项目。文章中的示例展示了如何使用这个技术栈创建一个真实的 Todo 应用示例，只需 100 行代码就能在边缘的 D1 SQLite 中插入和删除数据，执行速度快（约 100 毫秒），轻量级（gzip 压缩后的 worker 大小：22 KB）。作者表示，这种技术栈让他感到熟悉和舒适，它简单、干净，并且有很多优点，例如可以在边缘运行，可以使用 JavaScript/JSX，通过良好的代码组织可以避免出现意大利面条式代码。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 TypeScript 的 5 个难以启齿的真相]]></title>
        <id>https://oida.dev/5-truths-about-typescript/</id>
        <link href="https://oida.dev/5-truths-about-typescript/"/>
        <updated>2023-07-25T00:47:55.530Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://oida.dev/5-truths-about-typescript/">5 Inconvenient Truths about TypeScript</a></p><p><strong>概要：</strong></p><p>这篇文章是作者关于 TypeScript 的见解和经验分享。作者首先指出，TypeScript 并不能替代 JavaScript，它只是 JavaScript 的超集，继承了 JavaScript 的所有历史、怪癖和陷阱，但可以帮助避免错误，提供动态类型编程语言的支持。其次，TypeScript 会为项目增加复杂性，具有很多配置选项，需要开发者熟悉和掌握。然后，作者强调 TypeScript 并不是类型安全的，尤其在处理用户输入、文件访问、网络数据获取等 I/O 操作时，需要依赖开发者的类型注释或断言。此外，TypeScript 有许多版本和使用方式，每个团队都会找到适合自己的方式和工具。最后，尽管存在上述问题，但作者认为学习和使用 TypeScript 是值得的，因为它能使开发者的工作更有效率，也使代码更易于理解和维护。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 LangSmith，一个用于调试、测试、评估和监控 LLM 应用程序的统一平台]]></title>
        <id>https://blog.langchain.dev/announcing-langsmith/</id>
        <link href="https://blog.langchain.dev/announcing-langsmith/"/>
        <updated>2023-07-25T00:41:43.750Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.langchain.dev/announcing-langsmith/">Announcing LangSmith, a unified platform for debugging, testing, evaluating, and monitoring your LLM applications</a></p><p><strong>概要：</strong></p><p>LangChain 是一个开源 Python 包，旨在简化 LLM（Large Language Models）驱动的应用程序开发。然而，将应用程序从原型转变为生产版本仍然面临挑战，主要问题在于应用性能。为了解决这个问题，LangChain 推出了 LangSmith 平台，帮助开发者更好地从原型转向生产。该平台提供了一整套工具和实践，包括调试、测试、日志记录、监控等，使开发者可以专注于构建他们的应用程序。LangSmith 目前处于封闭测试阶段。它的五大核心功能包括：调试、测试、评估、监控以及统一平台。LangSmith 已经成功帮助了 Streamlit、Snowflake、波士顿咨询集团等公司实现了智能代理人的原型设计，并在 DeepLearningAI 的 LangChain 课程中帮助学生更好地理解模型。此外，LangSmith 还计划推出新的功能，如分析、协作、即时学习、提示创建等，并支持导出数据集以便进行微调或加载到其他分析引擎中。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何取得成功]]></title>
        <id>https://blog.samaltman.com/how-to-be-successful</id>
        <link href="https://blog.samaltman.com/how-to-be-successful"/>
        <updated>2023-07-24T04:41:08.273Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.samaltman.com/how-to-be-successful">How To Be Successful</a></p><p><strong>概要：</strong></p><p>这篇文章是由 Y Combinator 的合伙人 Sam Altman 撰写，分享了他对创业成功的 13 个观点。首先，他强调了复利效应的重要性，建议寻找并创造具有网络效应和极端可扩展性的业务。其次，他提倡培养过度的自我信念，独立思考，并学会销售。他还建议早期在职业生涯中冒险，保持专注并努力工作。此外，他鼓励大胆行事，坚定意志，难以与之竞争，并建立一个网络。他指出，通过拥有价值迅速增长的东西来致富，并主张内驱动。最后，他强调了自我激励的重要性，认为最成功的人通常是由内心驱动的，他们做事是为了给自己留下深刻印象，因为他们感到有必要在世界上做出一些事情。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们如何从典型 Rust SDK 生成 JavaScript 和 Python SDK - PostgresML]]></title>
        <id>https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk</id>
        <link href="https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk"/>
        <updated>2023-07-24T01:57:43.612Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk">How We Generate JavaScript and Python SDKs From Our Canonical Rust SDK – PostgresML</a></p><p><strong>概要：</strong></p><p>PostgresML 团队正在开发一种新的软件开发工具包（SDK），能够将用 Rust 编写的代码转化为 Python 和 JavaScript 模块。他们选择 Rust 作为主要语言，因为它能使代码更安全并加快开发周期。然而，大多数用户仍在使用 Python 和 JavaScript 等语言，所以他们决定制作一个可以在多种语言中使用的 SDK。他们的目标是只在 Rust 中编写一次 SDK，然后使其在任何目标语言中都可用。为此，他们创建了一种流程，通过使用自定义宏来生成 Pyo3 和 Neon Rust 所需的代码。他们还计划将这些宏推广出去，并添加对更多语言的支持。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jeremy Mikkola - 是什么让开发人员富有成效？]]></title>
        <id>https://jeremymikkola.com/posts/developer_productivity.html</id>
        <link href="https://jeremymikkola.com/posts/developer_productivity.html"/>
        <updated>2023-07-24T01:56:32.036Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jeremymikkola.com/posts/developer_productivity.html">Jeremy Mikkola - What makes developers productive?</a></p><p><strong>概要：</strong></p><p>这篇文章探讨了影响开发者生产力的多个因素。一些因素如构建时间容易衡量，但有些因素如开发者对系统的理解程度则难以直接衡量。文章指出，知道要构建什么、做更少的事情、使用反应迅速的工具、开发者头脑中的知识、有帮助的基础设施、低技术债务、低失败率、实用的生产实践、工程师的专注度和完成任务等都是影响生产力的重要因素。作者强调，尽管不能直接通过仪表板来衡量所有这些不同的因素，但任何开发者都能告诉你哪些因素正在影响他们的生产力。修复这些问题可能会大大提高完成任务的数量。例如，花几个小时写一份文档可能会为公司节省数千个小时。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 查询和 React 上下文]]></title>
        <id>https://tkdodo.eu/blog/react-query-and-react-context</id>
        <link href="https://tkdodo.eu/blog/react-query-and-react-context"/>
        <updated>2023-07-24T01:54:02.854Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tkdodo.eu/blog/react-query-and-react-context">React Query and React Context</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了 React Query 的实践应用，特别是在组件树中使用查询的优势。作者指出，React Query 允许我们在需要数据的地方获取数据，使组件解耦和独立。然而，这并非完美无缺，也存在一些权衡。例如，为了使组件自动化，它必须处理查询数据不可用的情况，如加载和错误状态。此外，还存在隐式依赖性问题，即只存在于我们头脑中的依赖关系，但在代码中却看不到。最后，作者提出了一个解决方案，即通过 React Context 使依赖性显性化。尽管 TypeScript 可能不喜欢这种方法，但我们可以通过添加一个不变量来确保在错误的地方访问 useCurrentUserContext 时能快速失败并给出好的错误信息。总的来说，虽然这种技术可能会产生网络瀑布等问题，但对于子树的必需数据（如用户信息）来说，这仍是一种可行的方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最重要的编码习惯]]></title>
        <id>https://puppycoding.com/2023/07/22/healthy-coding-habits/</id>
        <link href="https://puppycoding.com/2023/07/22/healthy-coding-habits/"/>
        <updated>2023-07-24T01:53:42.324Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://puppycoding.com/2023/07/22/healthy-coding-habits/">The Most Important Coding Habits</a></p><p><strong>概要：</strong></p><p>这篇文章的作者分享了他因长时间低头对着键盘编程，导致脊椎间盘突出（俗称 “椎间盘滑脱”）的痛苦经历。他认为，对于程序员来说，最重要的习惯并不是提高代码的可读性、一致性或组织性，而是保持健康的身体以便能长期从事这项工作。他建议大家每天进行拉伸运动，定时休息，避免深夜编程，并改善工作环境，比如使用站立式办公桌等。他希望大家能从他的错误中吸取教训，享受健康编程的乐趣。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[好的代码就像一封情书，写给下一个维护它的开发人员。]]></title>
        <id>https://addyosmani.com/blog/good-code/</id>
        <link href="https://addyosmani.com/blog/good-code/"/>
        <updated>2023-07-24T01:53:22.928Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/good-code/">Good code is like a love letter to the next developer who will maintain it.</a></p><p><strong>概要：</strong></p><p>这篇文章将编程比作写情书，强调了编码的实质是沟通。好的代码就像一封爱情信件，是开发者之间的亲密对话。好的代码个性化、真诚、无需多余复杂性，且考虑到下一个维护它的开发者。我们有设计模式和原则来塑造我们的代码，使其可扩展、可维护、高效，同时也易读和易懂。好的代码会巧妙地利用这些模式，就像熟练的诗人使用诗歌设备来创造共鸣。SOLID, DRY, KISS 和 YAGNI 不仅仅是原则，而是编写好代码的基石。好的代码还遵循既定的最佳实践，如适当的命名规范、模块化和详尽的注释。同样重要的是进行严格的测试和采用测试驱动开发（TDD）的做法。最后，编写他人能阅读、理解和维护的代码，是对专业尊重的体现。因此，好的代码不仅是一封情书，更是我们留给后来者的持久遗产。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有效的代码审查]]></title>
        <id>https://addyosmani.com/blog/code-reviews/</id>
        <link href="https://addyosmani.com/blog/code-reviews/"/>
        <updated>2023-07-24T01:52:59.652Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/code-reviews/">Effective Code Reviews</a></p><p><strong>概要：</strong></p><p>这篇文章主要讲述了进行有效代码审查的指导方针。对于代码作者，应尊重审查者的时间，首先自我审查代码，分解大的更改列表，自动化简单任务，严格限定代码变更范围，积极回应批评，减少审查轮次之间的延迟，明确询问不清楚的信息，并明确沟通反馈。同时，不要忘记编写文档。对于审查者来说，应验证代码是否必需且设计良好，是否易读且目标明确，注释是否解释了代码存在的原因而非其功能，代码是否过于复杂，是否遵循团队的样式指南，以及是否经过充分测试和文档记录。此外，审查评论应专注于代码本身，避免贬低或模糊的评论，而是提供明确、具体且适当的正面反馈。审查过程中需要考虑多个标准，如代码是否满足需求，逻辑是否正确，是否安全等。总的来说，代码审查应尊重、建设性且有针对性，作者和审查者都在维护代码质量和保证其长期可维护性上发挥关键作用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - vantezzen/auto-form：基于 zod 模式自动创建 @shadcn/ui 表单的 React 组件。]]></title>
        <id>https://github.com/vantezzen/auto-form</id>
        <link href="https://github.com/vantezzen/auto-form"/>
        <updated>2023-07-24T01:36:39.348Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/vantezzen/auto-form">GitHub - vantezzen/auto-form: 🌟  A React component that automatically creates a @shadcn/ui form based on a zod schema.</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 AutoForm 的 React 组件，它能根据 zod 模式自动创建一个 @shadcn/ui 表单。安装该组件需要依赖于 shadcn/ui 的多个组件，如：折叠面板、按钮、日历、卡片、复选框、表单、输入框、标签、弹出窗、单选组、选择器、分隔符、开关、文本区和切换等。目前支持的字段类型有：布尔值（复选框、开关）、日期（日期选择器）、枚举（选择器、单选组）、数字（输入框）和字符串（输入框、文本字段）。使用时只能在客户端的 React 组件中使用，如果在 Next.js 应用中使用，需要将组件标记为 "使用客户端"。你可以通过 describe 方法为每个字段设置标签和描述，如果没有设置标签，将使用字段名称并取消驼峰命名。所有字段默认都是必填的，可以通过 optional 方法将字段设置为可选。你还可以通过 default 方法为字段设置默认值。你可以使用 inputProps 属性将 props 传递给输入组件。你可以使用 description 属性在字段下方添加描述。你可以使用 renderParent 属性自定义输入的父元素。有两种方式可以访问表单数据：onSubmit 和 Controlled form。你可以使用 AutoFormSubmit 组件创建提交按钮。所有传递给 AutoForm 组件的子元素都将在表单下方渲染。最后，该组件的许可证为 MIT。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Turborepo 如何从 Go 移植到 Rust - Vercel]]></title>
        <id>https://vercel.com/blog/how-turborepo-is-porting-from-go-to-rust</id>
        <link href="https://vercel.com/blog/how-turborepo-is-porting-from-go-to-rust"/>
        <updated>2023-07-24T01:33:07.553Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/how-turborepo-is-porting-from-go-to-rust">How Turborepo is porting from Go to Rust – Vercel</a></p><p><strong>概要：</strong></p><p>文章讲述了为何以及如何将 Turborepo，一个高性能的 JavaScript 和 TypeScript 构建系统，从 Go 语言迁移到 Rust 语言。首先，他们确定了迁移是可行的，并开始了这个过程。在迁移策略上，他们选择了逐步迁移而非全面重写，因为全面重写会带来一些问题，例如需要暂停新功能的开发，可能导致用户体验下降等。逐步迁移则可以保持原有代码的行为不变，同时进行 Go 和 Rust 代码的互操作。他们首先用 Rust 编写了一个小的新功能，然后逐渐将更多的代码迁移到 Rust。在这个过程中，他们遇到了一些挑战，例如在不同的操作系统和 Linux 版本上测试代码时出现的问题，但最终都得到了解决。通过这次迁移，他们认识到序列化对于互操作性非常有用，逐步迁移需要充分的准备和测试，跨平台、跨语言的发布工程非常具有挑战性，但对他们来说，从 Go 迁移到 Rust 是值得的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 React 中使用 svg 精灵图标]]></title>
        <id>https://www.jacobparis.com/content/svg-icons</id>
        <link href="https://www.jacobparis.com/content/svg-icons"/>
        <updated>2023-07-24T01:32:02.963Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.jacobparis.com/content/svg-icons">Use svg sprite icons in React</a></p><p><strong>概要：</strong></p><p>文章介绍了在 React 应用中使用 svg 图标的方法。最直观但效率最低的方式是将 svg 代码直接写入组件作为 JSX，这会增加包的大小。最好的方式是使用 svg spritesheet，它是一种包含许多精灵（本例中的图标）的单个图像。我们可以通过加载一个大图像并通过代码只显示需要的部分来优化图像加载。网站可以使用同样的策略将许多图标存储在一个 svg 文件中，称为 svg spritesheet。每个图标精灵都存储为 svg 文件内的 <symbol> 元素，我们可以通过使用 < use > 元素并引用图标的 id 来显示特定的图标。文章详细介绍了如何构建一个脚本，将一个文件夹的 svg 图标编译成一个单独的 svg spritesheet，以及如何构建一个 React 组件，通过名称显示特定的图标，并为可用的图标提供完全类型安全的自动完成功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[制作开发人员想要的东西]]></title>
        <id>https://leerob.io/blog/make-something-developers-want</id>
        <link href="https://leerob.io/blog/make-something-developers-want"/>
        <updated>2023-07-21T06:39:33.921Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://leerob.io/blog/make-something-developers-want">Make Something Developers Want</a></p><p><strong>概要：</strong></p><p>Y Combinator 以他们的建议而闻名：制造人们想要的东西。然而，当这些客户是开发者时，我会认为执行这个建议的方式看起来有所不同，可能与人们通常想要的相反。以下是你应该做的，以制造开发者想要的东西：你应该接受开源；你应该有一个免费的层级；你应该有优秀的文档；你应该能够得到开发者的支持；你应该是一个社区的一部分。1. 你应该接受开源，因为经验丰富的开发者喜欢开源产品，新手开发者也喜欢开源产品，因为他们正在学习帮助他们在职业生涯中提升的技能。2. 你应该有一个免费的层级，开发者不想和你的销售团队交谈，他们想尽可能少的摩擦地试用产品。3. 你应该有优秀的文档，文档越好，开发者就越可能尝试你的产品。4. 你应该能够得到开发者的支持，当开发者在你的文档中找不到答案时，他们会寻求支持。5. 你应该成为一个社区的一部分，开发者去哪里玩？在线和线下社区。你需要在那里提供价值。这是一个长期的游戏，有时需要花费几年时间才能实现价值，但事后看来是显而易见的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SvelteJS：我的生态系统比你的大 - HackMD]]></title>
        <id>https://hackmd.io/@roguegpu/r1RKQMdt3</id>
        <link href="https://hackmd.io/@roguegpu/r1RKQMdt3"/>
        <updated>2023-07-21T01:52:32.582Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://hackmd.io/@roguegpu/r1RKQMdt3">SvelteJS: My ecosystem is bigger than yours  - HackMD</a></p><p><strong>概要：</strong></p><p>文章主要讨论了 Svelte 和 React 之间的差异，以及为何使用 Svelte 可能是更好的选择。作者指出，尽管 Svelte 的生态系统相比 React 较小，但这并不意味着它的功能有所欠缺。事实上，Svelte 的一些特性，如内置的状态管理 API 和转换 API，使得开发者无需寻找额外的库就能解决问题。此外，Svelte 还允许直接在框架中进行样式设置，而无需引入其他库。作者还展示了如何在 Svelte 中使用 ag-grid 和 chart.js 等库，并指出与 React 相比，Svelte 可以更直接地使用这些库，而无需通过封装器。最后，作者总结道，虽然使用 React 可能需要学习更多的封装器，但使用 Svelte 则可以更直接地学习和使用底层库。</p>]]></content>
    </entry>
</feed>