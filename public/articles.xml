<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-08-10T02:38:30.902Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[通过应用程序接口发送用户界面]]></title>
        <id>https://www.builder.io/blog/ui-over-apis</id>
        <link href="https://www.builder.io/blog/ui-over-apis"/>
        <updated>2023-08-10T01:43:44.579Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/ui-over-apis">Sending UI over APIs</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了一种正在改变我们对用户界面（UI）思考方式的技术，即通过 API 发送 UI，也被称为服务器驱动的 UI。这种方法提供了新的动态性和灵活性，正在改变传统的 UI 开发范式。Instagram、Lyft 和 Airbnb 等科技巨头已经实施了这种方法，利用服务器驱动的 UI 向全球数百万用户提供动态内容和更新。服务器驱动的 UI 在服务器上生成 UI，并通过 API 将其发送到客户端，这种方法可以提供更快的迭代和更个性化的用户体验。尽管存在需要考虑的挑战，如应用商店指南和离线用户体验管理，但服务器驱动的 UI 为 UI 开发的未来提供了一个令人兴奋的方向。Instagram 的服务器驱动 UI 的采用提供了一个引人入胜的案例研究。此外，服务器驱动的 UI 带来了许多好处，包括立即修复错误和更快的迭代，后端开发者可以参与前端开发，动态和个性化的用户体验，以及减少客户端的复杂性。然而，实现服务器驱动的 UI 需要注意应用商店指南、离线用户体验、性能考虑因素和增加的复杂性等挑战。总的来说，通过 API 发送 UI 或服务器驱动的 UI 代表了 UI 开发领域的重大转变，它提供了一种动态性和灵活性的水平，正在重新塑造行业。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用于 React 服务器组件的开发工具]]></title>
        <id>https://www.alvar.dev/blog/creating-devtools-for-react-server-components</id>
        <link href="https://www.alvar.dev/blog/creating-devtools-for-react-server-components"/>
        <updated>2023-08-10T01:42:24.854Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.alvar.dev/blog/creating-devtools-for-react-server-components">Devtools for React Server Components</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了 React Server Components（RSC）的潜力，以及作者如何利用其创建开发工具。RSC 允许服务器在加载和渲染内容时进行流式传输，开发人员可以定义代码内容中可能需要更长时间加载的区域，并在加载时显示回退。这些区域被称为 <Suspense> 边界，它们可以在仍在加载的同时解锁页面的其余部分。现在，加载部分可以在服务器端进行。最近，这一切开始在生产环境中使用。尽管目前对于 RSC 的开发工具并不多，但有大量的数据可以处理。作者编写了一个小型解析器来解析响应，并开始思考如何以更好的方式呈现它。作者创建了 rsc-parser.vercel.app，一个可以复制粘贴使用 RSC 的网络响应站点的页面，并获得更好的数据探索体验。作者还创建了一个浏览器扩展，可以记录响应并在浏览时呈现信息。尽管该扩展仍处于早期阶段，但作者正在寻找方法，利用一些内部 React 代码来解析响应。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Project IDX：人工智能辅助的全栈应用程序开发环境]]></title>
        <id>https://addyosmani.com/blog/project-idx/</id>
        <link href="https://addyosmani.com/blog/project-idx/"/>
        <updated>2023-08-10T01:41:56.005Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/project-idx/">Introducing Project IDX: An AI-assisted, Full-Stack App Development Environment</a></p><p><strong>概要：</strong></p><p>Google 发布了新的基于浏览器的代码环境项目 IDX，该项目内置有 AI 辅助的代码生成、代码完成和代码解释功能，并支持现代 JavaScript 框架。IDX 基于 VSCode，其愿景是一个具有 AI 智能、使用热门框架的应用程序的快速起点、位于您附近的数据中心的 Linux-based VM，以及快速部署到 Firebase Hosting 和（即将推出的）浏览器中的 Android + iOS 模拟器的全面本地环境。IDX 允许开发者在任何地方、任何设备上进行工作，具有本地开发的全部效果。每个工作空间都具有 Linux-based VM 的全部功能，并配有托管在云中的通用访问权限。你可以将现有的 GitHub 项目导入 IDX，或者使用 Angular, React, Next.js, Svelte, Vue, Flutter 等流行框架的模板创建新项目。IDX 包含内置的网络预览，即将推出的配置完整的 Android 模拟器和嵌入式 iOS 模拟器，所有这些都可以直接在浏览器中使用。IDX AI 功能是这个创新项目的核心，提供智能代码完成、辅助聊天机器人和上下文代码操作。通过 Firebase Hosting 集成，可以更容易地部署应用程序，只需几次点击就可以部署您的网络应用程序的可分享预览或部署到生产环境。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js 的配置地狱问题]]></title>
        <id>https://deno.com/blog/node-config-hell</id>
        <link href="https://deno.com/blog/node-config-hell"/>
        <updated>2023-08-10T01:29:52.700Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/node-config-hell">Node.js's Config Hell Problem</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了在使用 Node.js 进行开发时，配置文件可能会阻碍开发者的生产力。例如，在最新版本的 Next.js 中，你将得到多个配置文件。所有软件都需要配置，但我们如何才能避免需要 30 个文件来运行一个项目的情况呢？有效的软件应该通过设定智能默认值来预测用户的需求，这些 “预设设置” 被设计为在不需要手动配置的情况下为大多数用户提供优化的体验。让用户在使用软件之前进行配置可能会损害他们对你的品牌的善意和信任。文章还列出了各种配置文件的作用。最后，作者提出了 Deno 的解决方案，Deno 是一个零配置、自带电池的运行时环境，使你可以立即开始下一个项目并立即提高生产力。它内置了 TypeScript 支持，因此你无需花时间进行设置。Deno 还配备了强大的工具链，包括格式化、linting、测试等，所以你无需自己设置。最后，Deno 使用与 web 兼容的 API，所以如果你已经在为 web 构建，那么你已经熟悉 Deno 了。编程就是要管理复杂性，而简化复杂性就是不需要配置步骤。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[将我的博客从 Gatsby 迁移到 Astro]]></title>
        <id>https://sapegin.me/blog/gatsby-to-astro/</id>
        <link href="https://sapegin.me/blog/gatsby-to-astro/"/>
        <updated>2023-08-10T01:28:49.333Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://sapegin.me/blog/gatsby-to-astro/">Migrating my blog from Gatsby to Astro</a></p><p><strong>概要：</strong></p><p>这篇文章是作者分享了他从 Gatsby 转向 Astro 重构个人网站和博客的经验。他对 Gatsby 的开发体验非常不满，认为其默认设置差劲，GraphQL API 过于复杂。此外，他也希望停止使用 React 渲染静态页面，并将主页和博客合并。在技术要求上，他希望继续使用 React 进行模板设计，并使用基础组件进行样式设计。最后，他选择了 Astro 和 vanilla-extract 来实现这些目标。

Astro 是一个注重性能且灵活的静态网站生成器，支持多种 UI 框架，包括 React、Vue 和 Svelte。它默认生成静态 HTML 页面，无需客户端 JavaScript，但也支持在静态页面中添加动态部分。Astro 的开发体验非常好，提供了许多用于构建博客或其他内容网站的功能，如基于文件的路由、内容集合、Markdown 语法高亮等。

Vanilla-extract 则允许在 JavaScript 中编写零运行时样式，支持主题，并有良好的 TypeScript 支持。但它也有一些限制，比如需要在单独的 *.css.ts 文件中编写样式，不能从 *.css.ts 文件中导出 React 组件，只能导出包含类名的字符串等。

总的来说，作者对 Astro 的评价较高，计划将更多项目从 Gatsby 迁移到 Astro。而对于 Vanilla-extract，虽然它能完成工作，但开发体验并不理想。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 TypeScript 5.2 RC - TypeScript]]></title>
        <id>https://devblogs.microsoft.com/typescript/announcing-typescript-5-2-rc/</id>
        <link href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-2-rc/"/>
        <updated>2023-08-10T00:53:52.777Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-2-rc/">Announcing TypeScript 5.2 RC - TypeScript</a></p><p><strong>概要：</strong></p><p>2023 年 8 月 9 日，TypeScript 5.2 的发布候选版本正式发布。在 TypeScript 5.2 稳定版发布之前，除了关键的 bug 修复外，不会有其他更改。新版本中包含了许多新特性，如使用声明和显式资源管理、装饰器元数据、命名和匿名元组元素、联合数组的简化方法使用、仅类型导入路径与 TypeScript 实现文件扩展名等。此外，还进行了内联变量重构，优化了持续类型兼容性检查，并进行了一些破坏性变更和正确性修复。在测试阶段，开发团队希望收集用户反馈，并只对新行为引入低风险变更，解决关键问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[帮助人们轻松地获取命令行？]]></title>
        <id>https://jvns.ca/blog/2023/08/08/what-helps-people-get-comfortable-on-the-command-line-/</id>
        <link href="https://jvns.ca/blog/2023/08/08/what-helps-people-get-comfortable-on-the-command-line-/"/>
        <updated>2023-08-09T05:58:01.682Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jvns.ca/blog/2023/08/08/what-helps-people-get-comfortable-on-the-command-line-/">What helps people get comfortable on the command line?</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了如何帮助初学者克服对命令行的恐惧，并提供了一些实用的建议。首先，减少风险是非常重要的，例如定期备份数据、使用 git 进行代码管理、避免使用通配符等。其次，找到自己感兴趣的 “杀手级应用” 可以增加动力，如 ripgrep、jq、wget /curl、git 等。此外，观察他人如何高效地使用命令行也能激发学习的欲望。还有一些资源可以帮助初学者更好地理解和使用命令行，如 explainshell 网站、历史记录、标签补全等功能。其他有用的工具包括 fzf（模糊搜索工具）、Raspberry Pi、oh-my-zsh 或 fish 等友好的 shell 设置等。最后，作者还推荐了一些书籍、文章和视频，以供读者进一步学习。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Supabase 本地开发：迁移、分支和可观察性]]></title>
        <id>https://supabase.com/blog/supabase-local-dev</id>
        <link href="https://supabase.com/blog/supabase-local-dev"/>
        <updated>2023-08-09T01:00:09.916Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://supabase.com/blog/supabase-local-dev">Supabase Local Dev: migrations, branching, and observability</a></p><p><strong>概要：</strong></p><p>Supabase 的目标之一是使 Postgres 开发变得愉快。为此，他们需要简化 CLI、代码编辑器和远程 Postgres 数据库之间的体验。最近，他们收到了关于本地开发体验的反馈，鼓励他们进行改进。这个迭代引入了许多新特性来解决这些反馈。他们推出了 Postgres 语言服务器，它能够直接从浏览器或移动应用程序通过无服务器 API 访问 Postgres 数据库。他们还增加了对 Postgres 的可观察性工具，如调试实用程序，以及通过 supabase 检查 db 命令识别生产问题。他们还简化了数据库备份和迁移，扩展了 CLI 迁移功能，并添加了仪表板支持。此外，他们还简化了数据库测试体验，增加了对 linting 的支持，并添加了对数据库播种的支持。他们还开发了一个官方的 GitHub Action，可以利用 CLI 在每个 PR 上生成类型，或者在每次提交时运行测试。他们还将 Supabase CLI 移至双周稳定发布周期，并为 CLI 添加了 beta 发布通道。最后，他们引入了分支和预览环境功能，这可能是最受期待的功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nuxt 3 的 24 个省时技巧]]></title>
        <id>https://masteringnuxt.com/blog/24-time-saving-tips-for-nuxt3</id>
        <link href="https://masteringnuxt.com/blog/24-time-saving-tips-for-nuxt3"/>
        <updated>2023-08-04T00:26:58.024Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://masteringnuxt.com/blog/24-time-saving-tips-for-nuxt3">24 Time Saving Tips for Nuxt 3</a></p><p><strong>概要：</strong></p><p>这篇文章列出了 24 个 Nuxt 的使用技巧，包括何时使用 /assets 和 /public 目录、如何理解通用渲染方式（以及它与 SPA 和 SSR 的区别）、如何添加基础缓存等。其中一些具体技巧包括懒加载组件、预渲染特定路由、使用内置键值存储、自动导入、控制 head 脚本的反应性、获取路由信息、处理客户端错误、嵌套路由、自定义 NuxtLink 组件、页面预取、外部链接、数据获取和关键参数、简单的授权、使用 useAsyncData 和 useFetch 函数、图像压缩、添加基础缓存、理解通用渲染的优点、在新标签页中打开 NuxtLinks、运行时配置和应用配置的选择等。此外，还推荐了一门名为 “Mastering Nuxt 3” 的课程。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原型的价值在于它所传递的洞察力，而不是代码。]]></title>
        <id>https://addyosmani.com/blog/prototypes/</id>
        <link href="https://addyosmani.com/blog/prototypes/"/>
        <updated>2023-08-04T00:13:43.421Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/prototypes/">The value of a prototype is in the insight it imparts, not the code.</a></p><p><strong>概要：</strong></p><p>原型的价值在于它能提供的洞察，而不是编写的代码。原型设计让我们可以快速且低成本地失败，或者获取决策所需的数据。它帮助回答 "如果我们尝试这个会怎么样？" 的问题。更重要的是，原型设计为我们提供了安全有效地失败的保护栏。失败是学习过程中不可或缺的一部分。

如果你有一个想要验证的想法，一个明确的反馈路径，或者需要进一步数据的提议，那么原型就是合适的工具。它提供关键的洞察来推动前进。通过创建一个你一直在考虑的特性或系统的粗糙版本，你获得了放弃这个想法或全力以赴的灵活性。这是一种帮助产品和工程团队做出关键业务决策的技能。

无论你正在开发的是网站、移动应用还是落地页，验证你的设计决策总是至关重要的。一些开发团队会延迟验证阶段，直到他们有一个几乎完整的解决方案。但这是一个极其危险的策略。因为我们都知道，问题出现得越晚，修复它的成本就越高。幸运的是，无论你处于设计过程的哪个点，都可以构建和测试你概念的具体形象 —— 一个原型。

原型并不专注于解决方案，而是专注于理解问题。它们问的问题是，"当我们尝试这个时会发生什么？" 也许我们会发现这是个好主意，但更可能的是，我们会了解到</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Replit 部署：速度快 3 倍，功能更丰富]]></title>
        <id>https://blog.replit.com/deployments-updates</id>
        <link href="https://blog.replit.com/deployments-updates"/>
        <updated>2023-08-02T06:11:19.296Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.replit.com/deployments-updates">Replit Deployments: 3x Faster and Even More Features</a></p><p><strong>概要：</strong></p><p>文章介绍了 Replit 在四月份发布的 Replit Deployments，这是一个从软件想法到生产的最快方式。该公司根据用户反馈重建了适用于生产级应用的托管基础设施。自四月份初次发布以来，Replit Deployments 进行了升级、修复 bug 和改进。其优点包括：应用托管在 Google Cloud VMs 上，更可靠稳定；为应用提供独立的 VM 资源，提高安全性和性能；可以控制何时向用户发布，以便在不影响生产的情况下修复应用；所有 VM 日志直接流向工作区的 Deployments 面板。此外，Replit Deployments 还通过减少读取磁盘时的限制、升级构建机器、修复部署过程中的 bug 等方式，使得具有大量包的 Repls 部署速度提高 2-3 倍。同时，该公司也一直在寻找新的方法确保每次点击 “部署” 都像魔术一样顺利，减少部署失败的情况。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么 DNS 仍然难学？]]></title>
        <id>https://jvns.ca/blog/2023/07/28/why-is-dns-still-hard-to-learn/</id>
        <link href="https://jvns.ca/blog/2023/07/28/why-is-dns-still-hard-to-learn/"/>
        <updated>2023-08-02T06:09:34.144Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jvns.ca/blog/2023/07/28/why-is-dns-still-hard-to-learn/">Why is DNS still hard to learn?</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了为什么学习和调试 DNS 问题很困难。首先，很多系统是隐藏的，比如解析器的缓存、你的电脑上哪个库代码正在进行 DNS 请求等。其次，处理隐藏系统的方法有：教人们隐藏系统是什么，以及通过 “鱼缸” 方法展示系统的一部分。作者建议扩展 DNS 以包含 “调试信息” 部分。此外，DNS 还有一些令人困惑的工具，例如 dig。对于这些工具，作者提出了改进的建议：解释输出、制作新的、更友好的工具，或者使 dig 的输出更友好。然后，DNS 还有一些奇怪的问题，例如负缓存、getaddrinfo 实现的差异等。最后，作者提到了其他两个原因：不频繁的接触和难以实验。文章最后，作者希望听到读者对学习 DNS 或其他神秘技术的困难之处的看法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redwood v6.0.0 现已发布]]></title>
        <id>https://community.redwoodjs.com/t/redwood-v6-0-0-is-now-available/5165</id>
        <link href="https://community.redwoodjs.com/t/redwood-v6-0-0-is-now-available/5165"/>
        <updated>2023-08-02T02:06:56.558Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://community.redwoodjs.com/t/redwood-v6-0-0-is-now-available/5165">Redwood v6.0.0 is now available</a></p><p><strong>概要：</strong></p><p>文章未提供内容，无法进行总结。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dnt - 发布 ESM 和 CommonJS 混合 npm 模块的最简单方法]]></title>
        <id>https://deno.com/blog/publish-esm-cjs-module-dnt</id>
        <link href="https://deno.com/blog/publish-esm-cjs-module-dnt"/>
        <updated>2023-08-02T01:27:12.050Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/publish-esm-cjs-module-dnt">dnt — the easiest way to publish a hybrid npm module for ESM and CommonJS</a></p><p><strong>概要：</strong></p><p>虽然浏览器和 JavaScript 已经取得了长足的进步，但编写和发布 JavaScript 模块仍然很痛苦。为了最大化采用，你的模块应该支持 CommonJS 和 ESM、带有 TypeScript 声明的 JavaScript，并能在 Deno、Node.js 和网络浏览器中工作。为了达到这个目标，许多人不得不使用复杂的发布流程或者维护两份具有略微不同模块语法的代码。dnt 是一个构建工具，可以将 Deno 模块转换成与 Node.js/npm 兼容的包。此外，转换后的包还支持 CommonJS 和 ESM，可以在 Node.js、Deno 和浏览器中运行，同时还支持 TypeScript 和 JavaScript。通过使用 dnt，你可以使用 TypeScript 等现代工具一次性编写模块，并将其转换以支持所有用例。当需要发布时，可以使用 dnt 将其导出为与 Node.js/npm 兼容的格式。此外，dnt 还可以与 GitHub Actions 配合使用，简化每次发布新版本时的操作。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区分前端框架的最重要因素]]></title>
        <id>https://themer.dev/blog/the-single-most-important-factor-that-differentiates-front-end-frameworks</id>
        <link href="https://themer.dev/blog/the-single-most-important-factor-that-differentiates-front-end-frameworks"/>
        <updated>2023-08-02T00:51:11.692Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://themer.dev/blog/the-single-most-important-factor-that-differentiates-front-end-frameworks">The single most impor­tant factor that dif­fer­enti­ates front-end frame­works</a></p><p><strong>概要：</strong></p><p>文章主要探讨了前端框架如何解决变更检测问题，即检测应用状态的变化以便相应地更新用户界面。主要对比了 React、Angular、Vue 和 Svelte 四个主要框架的变更检测方式。React 通过内部 API 直接更新状态，并在需要时重新渲染组件。Angular 则要求开发者自行处理状态变化并通知框架进行重新渲染，但这种方式在处理复杂应用时可能变得难以管理。Vue 则通过特殊工具监控状态对象的变化，从而实现变更检测。Svelte 采用编译时方法，通过分析组件代码的抽象语法树并在必要时更新 DOM。文章最后指出，选择适合应用需求的变更检测模式非常重要，否则将在项目生命周期中不断与之斗争。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[了解 React 服务器组件 - Vercel]]></title>
        <id>https://vercel.com/blog/understanding-react-server-components</id>
        <link href="https://vercel.com/blog/understanding-react-server-components"/>
        <updated>2023-08-02T00:15:52.124Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/understanding-react-server-components">Understanding React Server Components – Vercel</a></p><p><strong>概要：</strong></p><p>文章介绍了 React Server Components (RSCs) 的基本概念和应用，RSCs 扩展了 React 的基础功能，使其不仅是一个纯粹的渲染库，还能在框架内部整合数据获取和远程客户端 - 服务器通信。文章解释了为何需要创建 RSCs，它们最擅长的工作，以及何时使用它们。文章还讨论了 Next.js 如何通过 App Router 简化和增强 RSC 的实现细节。RSCs 可以帮助减少客户端 JavaScript 包的大小，提高加载性能。在 Next.js 中，RSCs 允许智能数据缓存、单次往返中的多次获取，以及自动 fetch () 请求去重，所有这些都最大限度地提高了将数据发送到客户端的效率。此外，你不再需要像 getServerSideProps () 和 getStaticProps () 这样的 Next.js 特定的页面级方法，这些方法对于单个组件来说控制力不够，而且往往会过度获取数据。总的来说，Next.js App Router 中的 React Server Components 是一种有效、安全、动态获取数据的强大工具，所有数据默认都是缓存的，以提供高性能的用户体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 中的可视化树迭代器]]></title>
        <id>https://blog.danieljanus.pl/2023/07/20/iterating-trees/</id>
        <link href="https://blog.danieljanus.pl/2023/07/20/iterating-trees/"/>
        <updated>2023-07-28T04:16:50.639Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.danieljanus.pl/2023/07/20/iterating-trees/">A visual tree iterator in Rust</a></p><p><strong>概要：</strong></p><p>作者分享了他在学习 Rust 编程语言的过程中，如何使用迭代器重写树打印函数的经历。他希望通过这种方式使代码更具可复用性，并能更容易地为 Cursive 实现一个树形视图。在这个过程中，他遇到了很多问题，但最终成功实现了功能。此外，他还分享了自己在学习过程中的一些心得和感悟，比如 Rust 的学习曲线初始阶段较为陡峭，需要花费大量时间去理解和掌握；而且，他发现在学习过程中反思错误并尝试改正是非常有价值的。最后，他推荐了 Amos 的博客，认为这是学习 Rust 的优秀资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在两分钟内创建标记符编辑器（使用 GitHub Copilot）]]></title>
        <id>https://dev.to/github/how-to-build-a-markdown-editor-in-two-minutes-with-github-copilot-khb</id>
        <link href="https://dev.to/github/how-to-build-a-markdown-editor-in-two-minutes-with-github-copilot-khb"/>
        <updated>2023-07-28T00:11:35.915Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/github/how-to-build-a-markdown-editor-in-two-minutes-with-github-copilot-khb">How to build a markdown editor in two minutes (with GitHub Copilot)</a></p><p><strong>概要：</strong></p><p>这篇博客文章介绍了如何使用 GitHub Copilot 在两分钟内构建一个 markdown 编辑器。首先，需要创建一个 Next.js 的 GitHub Codespace 模板，然后安装特定的依赖项，删除 index.js 文件中的代码，并通过注释提示 GitHub Copilot。然后触发 GitHub Copilot 的建议，保存文件并尝试运行。此外，还可以使用 Copilot 聊天来改善 markdown 编辑器的用户界面。但是，由于 GitHub Copilot 和其他生成 AI 工具是非确定性的，所以这些工具有时会生成不同的输出。作者还强调，虽然这个教程对今天（2023 年 6 月）仍然适用，但未来可能会过时。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Astro 2.9：视图转换（实验性） | Astro]]></title>
        <id>https://astro.build/blog/astro-290/</id>
        <link href="https://astro.build/blog/astro-290/"/>
        <updated>2023-07-27T06:17:03.682Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://astro.build/blog/astro-290/">Astro 2.9: View Transitions (experimental) | Astro</a></p><p><strong>概要：</strong></p><p>Astro 2.9 版本已经发布，新特性包括对视图过渡的实验性支持，重定向配置以及改进的脚本打包。现在，Astro 通过新的 <ViewTransitions /> 组件和 transition:animate 指令支持视图过渡，使得过渡更加顺畅，无需牺牲 MPA 的简单性。此外，重定向配置选项不再是实验性的，你可以在项目中安全地使用重定向。Astro 还改进了静态分析，使其能够确定哪些 < script > 标签需要一起打包，这使得脚本的使用在页面之间进行了优化，并将它们放在文档的头部，以尽可能早地下载。感谢社区贡献者 Ottomated 为这个新功能的开发做出的贡献。此版本还包括其他的错误修复和集成特性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 服务器组件提示]]></title>
        <id>https://echobind.com/post/react-server-components-tips</id>
        <link href="https://echobind.com/post/react-server-components-tips"/>
        <updated>2023-07-27T06:07:48.874Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://echobind.com/post/react-server-components-tips">React Server Components Tips</a></p><p><strong>概要：</strong></p><p>React 官方的数据获取解决方案为 React Server Components（RSC）。使用 RSC 需要深度集成打包器，且严格执行组件树结构和模块组合。使用 RSC 时，任何交互代码必须在特殊的客户端组件中完成。但是，RSC 也有诸多优点：可以在组件内部获取数据，避免客户端获取数据时常见的瀑布式获取，可以使用 <Suspense> 流数据以加快初始页面加载速度，可以在服务器上执行更多代码而无需将其发送到客户端，从而保持包大小较小。目前，唯一被广泛接受的 React Server Components 实现是 Next.js App Router。此外，还提供了一些使用 RSC 构建应用程序的技巧，如制作更多的组件，自由使用客户端组件，构建组件以便于组合，不要忘记共享组件等。最后，作为 Server Components 获取数据的对应部分，React 团队引入了 Server Actions 来执行变异。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - emilkowalski/vaul：React 的非样式抽屉组件。]]></title>
        <id>https://github.com/emilkowalski/vaul</id>
        <link href="https://github.com/emilkowalski/vaul"/>
        <updated>2023-07-26T04:40:19.231Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/emilkowalski/vaul">GitHub - emilkowalski/vaul: An unstyled drawer component for React.</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 Vaul 的 React 抽屉组件，可以用作平板和移动设备上的 Dialog 替代品。它使用 Radix 的 Dialog 原始组件，并受到一条推文的启发。要开始使用这个库，需要在项目中安装它，然后在应用程序中使用这个抽屉。文章还提供了几个例子以及 API 参考，包括 Root、Trigger、Content、Overlay、Title、Description、Close 和 Portal 等部分的详细说明。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Valibot，小于 1kb 的佐德替代品]]></title>
        <id>https://www.builder.io/blog/introducing-valibot</id>
        <link href="https://www.builder.io/blog/introducing-valibot"/>
        <updated>2023-07-26T04:10:17.404Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/introducing-valibot">Introducing Valibot, a < 1kb Zod Alternative</a></p><p><strong>概要：</strong></p><p>文章宣布了新的开源项目 Valibot，这是一个用于验证结构数据的模式库，与 Zod、Ajv、Joi 和 Yup 等相似。Valibot 的创新之处在于其 API 的模块化设计以及源代码的压缩优化，使得它能通过代码分割和压缩实现前所未有的包大小最小化，成为当前全栈空间创新的完美补充。Valibot 没有依赖性，可以在任何 JavaScript 或 TypeScript 项目中使用，以根据模式验证数据。作者 Fabian 介绍了 Valibot 的工作原理，它与其他解决方案的不同之处，以及它适合的使用场景。Valibot 的核心功能是创建模式，这可以与 TypeScript 中的类型定义进行比较。Valibot 几乎提供了与 TypeScript 相同的选项，例如，你可以用 partial 使对象的值变为可选，或者用 required 使它们变为必需。Valibot 是完全类型安全的，允许你推断模式的输入和输出类型。如果数据与模式不匹配，将抛出一个错误，带有有用的信息来修复问题。如果没有抛出错误，那么数据符合模式并返回类型。Valibot 的 API 设计部分基于 Zod，因为我们在各种项目中使用 Zod，并且它在新的 TypeScript 项目中几乎是标准的。尽管 API 在第一眼看起来与其他解决方案相似，但源代码的实施和结构却非常不同。Valibot 的 API 设计和源代码基于许多小而独立的函数，每个函数只有一个任务。这种模块化设计有几个优点，一方面，可以轻松地用外部代码扩展库的功能；另一</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 React Tweet - Vercel]]></title>
        <id>https://vercel.com/blog/introducing-react-tweet</id>
        <link href="https://vercel.com/blog/introducing-react-tweet"/>
        <updated>2023-07-26T03:12:03.586Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/introducing-react-tweet">Introducing React Tweet – Vercel</a></p><p><strong>概要：</strong></p><p>文章介绍了一个名为 react-tweet 的新工具，它可以将推特嵌入到任何 React 应用中，只需一行代码，且不会牺牲性能。与 Twitter 的原生嵌入相比，react-tweet 的客户端 JavaScript 少 35 倍。它支持 React 服务器组件，内置数据获取和缓存功能，并可与 Next.js、Vite、CRA 等任何 React 框架配合使用。传统上，嵌入推文需要使用 Twitter 的嵌入式 iframe，这会加载 560kb 的客户端 JavaScript，降低网站性能并导致布局移位。而使用 react-tweet，无需使用 iframes，只需一个简单的 React 组件即可。此外，它还改善了用户体验，使浏览器中的推文立即可见（无懒加载），并利用强大的 React 组件抽象进行构建。在对原生 Twitter 嵌入、iframe 嵌入和 react-tweet 进行比较后，react-tweet 所需的客户端 JavaScript 最少，只有 16kb。react-tweet 的工作原理是反向工程 Twitter 的嵌入 API，获取给定推文的数据，并以与 Twitter 的嵌入式 iframe 相同的样式呈现出来。你无需依赖 Twitter API v2 自己获取推文，从而节省了费用，也更容易将推文添加到你的网站上。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hono + htmx + Cloudflare 是一种新的堆栈 - Yusuke Wada]]></title>
        <id>https://blog.yusu.ke/hono-htmx-cloudflare/</id>
        <link href="https://blog.yusu.ke/hono-htmx-cloudflare/"/>
        <updated>2023-07-25T00:49:51.565Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.yusu.ke/hono-htmx-cloudflare/">Hono + htmx + Cloudflare is a new stack - Yusuke Wada</a></p><p><strong>概要：</strong></p><p>文章介绍了一种新的技术栈 Hono + htmx + Cloudflare。Hono 是一个 JavaScript 框架，包括 JSX 中间件，可用于编写 HTML，但仅限于服务器端渲染。htmx 是一个库，可以在不需要编写 JavaScript 的情况下启用 Ajax。这种技术栈还包括 Zod、Tailwind CSS、Cloudflare Workers 和 Cloudflare D1 等组件。Cloudflare D1 是一种在 Cloudflare 边缘运行 SQLite 的数据库服务，虽然目前处于 “alpha” 状态，不推荐用于生产使用，但已经非常快速，完全适合概念验证（PoC）项目。文章中的示例展示了如何使用这个技术栈创建一个真实的 Todo 应用示例，只需 100 行代码就能在边缘的 D1 SQLite 中插入和删除数据，执行速度快（约 100 毫秒），轻量级（gzip 压缩后的 worker 大小：22 KB）。作者表示，这种技术栈让他感到熟悉和舒适，它简单、干净，并且有很多优点，例如可以在边缘运行，可以使用 JavaScript/JSX，通过良好的代码组织可以避免出现意大利面条式代码。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 TypeScript 的 5 个难以启齿的真相]]></title>
        <id>https://oida.dev/5-truths-about-typescript/</id>
        <link href="https://oida.dev/5-truths-about-typescript/"/>
        <updated>2023-07-25T00:47:55.530Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://oida.dev/5-truths-about-typescript/">5 Inconvenient Truths about TypeScript</a></p><p><strong>概要：</strong></p><p>这篇文章是作者关于 TypeScript 的见解和经验分享。作者首先指出，TypeScript 并不能替代 JavaScript，它只是 JavaScript 的超集，继承了 JavaScript 的所有历史、怪癖和陷阱，但可以帮助避免错误，提供动态类型编程语言的支持。其次，TypeScript 会为项目增加复杂性，具有很多配置选项，需要开发者熟悉和掌握。然后，作者强调 TypeScript 并不是类型安全的，尤其在处理用户输入、文件访问、网络数据获取等 I/O 操作时，需要依赖开发者的类型注释或断言。此外，TypeScript 有许多版本和使用方式，每个团队都会找到适合自己的方式和工具。最后，尽管存在上述问题，但作者认为学习和使用 TypeScript 是值得的，因为它能使开发者的工作更有效率，也使代码更易于理解和维护。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 LangSmith，一个用于调试、测试、评估和监控 LLM 应用程序的统一平台]]></title>
        <id>https://blog.langchain.dev/announcing-langsmith/</id>
        <link href="https://blog.langchain.dev/announcing-langsmith/"/>
        <updated>2023-07-25T00:41:43.750Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.langchain.dev/announcing-langsmith/">Announcing LangSmith, a unified platform for debugging, testing, evaluating, and monitoring your LLM applications</a></p><p><strong>概要：</strong></p><p>LangChain 是一个开源 Python 包，旨在简化 LLM（Large Language Models）驱动的应用程序开发。然而，将应用程序从原型转变为生产版本仍然面临挑战，主要问题在于应用性能。为了解决这个问题，LangChain 推出了 LangSmith 平台，帮助开发者更好地从原型转向生产。该平台提供了一整套工具和实践，包括调试、测试、日志记录、监控等，使开发者可以专注于构建他们的应用程序。LangSmith 目前处于封闭测试阶段。它的五大核心功能包括：调试、测试、评估、监控以及统一平台。LangSmith 已经成功帮助了 Streamlit、Snowflake、波士顿咨询集团等公司实现了智能代理人的原型设计，并在 DeepLearningAI 的 LangChain 课程中帮助学生更好地理解模型。此外，LangSmith 还计划推出新的功能，如分析、协作、即时学习、提示创建等，并支持导出数据集以便进行微调或加载到其他分析引擎中。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何取得成功]]></title>
        <id>https://blog.samaltman.com/how-to-be-successful</id>
        <link href="https://blog.samaltman.com/how-to-be-successful"/>
        <updated>2023-07-24T04:41:08.273Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.samaltman.com/how-to-be-successful">How To Be Successful</a></p><p><strong>概要：</strong></p><p>这篇文章是由 Y Combinator 的合伙人 Sam Altman 撰写，分享了他对创业成功的 13 个观点。首先，他强调了复利效应的重要性，建议寻找并创造具有网络效应和极端可扩展性的业务。其次，他提倡培养过度的自我信念，独立思考，并学会销售。他还建议早期在职业生涯中冒险，保持专注并努力工作。此外，他鼓励大胆行事，坚定意志，难以与之竞争，并建立一个网络。他指出，通过拥有价值迅速增长的东西来致富，并主张内驱动。最后，他强调了自我激励的重要性，认为最成功的人通常是由内心驱动的，他们做事是为了给自己留下深刻印象，因为他们感到有必要在世界上做出一些事情。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们如何从典型 Rust SDK 生成 JavaScript 和 Python SDK - PostgresML]]></title>
        <id>https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk</id>
        <link href="https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk"/>
        <updated>2023-07-24T01:57:43.612Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk">How We Generate JavaScript and Python SDKs From Our Canonical Rust SDK – PostgresML</a></p><p><strong>概要：</strong></p><p>PostgresML 团队正在开发一种新的软件开发工具包（SDK），能够将用 Rust 编写的代码转化为 Python 和 JavaScript 模块。他们选择 Rust 作为主要语言，因为它能使代码更安全并加快开发周期。然而，大多数用户仍在使用 Python 和 JavaScript 等语言，所以他们决定制作一个可以在多种语言中使用的 SDK。他们的目标是只在 Rust 中编写一次 SDK，然后使其在任何目标语言中都可用。为此，他们创建了一种流程，通过使用自定义宏来生成 Pyo3 和 Neon Rust 所需的代码。他们还计划将这些宏推广出去，并添加对更多语言的支持。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jeremy Mikkola - 是什么让开发人员富有成效？]]></title>
        <id>https://jeremymikkola.com/posts/developer_productivity.html</id>
        <link href="https://jeremymikkola.com/posts/developer_productivity.html"/>
        <updated>2023-07-24T01:56:32.036Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jeremymikkola.com/posts/developer_productivity.html">Jeremy Mikkola - What makes developers productive?</a></p><p><strong>概要：</strong></p><p>这篇文章探讨了影响开发者生产力的多个因素。一些因素如构建时间容易衡量，但有些因素如开发者对系统的理解程度则难以直接衡量。文章指出，知道要构建什么、做更少的事情、使用反应迅速的工具、开发者头脑中的知识、有帮助的基础设施、低技术债务、低失败率、实用的生产实践、工程师的专注度和完成任务等都是影响生产力的重要因素。作者强调，尽管不能直接通过仪表板来衡量所有这些不同的因素，但任何开发者都能告诉你哪些因素正在影响他们的生产力。修复这些问题可能会大大提高完成任务的数量。例如，花几个小时写一份文档可能会为公司节省数千个小时。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 查询和 React 上下文]]></title>
        <id>https://tkdodo.eu/blog/react-query-and-react-context</id>
        <link href="https://tkdodo.eu/blog/react-query-and-react-context"/>
        <updated>2023-07-24T01:54:02.854Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tkdodo.eu/blog/react-query-and-react-context">React Query and React Context</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了 React Query 的实践应用，特别是在组件树中使用查询的优势。作者指出，React Query 允许我们在需要数据的地方获取数据，使组件解耦和独立。然而，这并非完美无缺，也存在一些权衡。例如，为了使组件自动化，它必须处理查询数据不可用的情况，如加载和错误状态。此外，还存在隐式依赖性问题，即只存在于我们头脑中的依赖关系，但在代码中却看不到。最后，作者提出了一个解决方案，即通过 React Context 使依赖性显性化。尽管 TypeScript 可能不喜欢这种方法，但我们可以通过添加一个不变量来确保在错误的地方访问 useCurrentUserContext 时能快速失败并给出好的错误信息。总的来说，虽然这种技术可能会产生网络瀑布等问题，但对于子树的必需数据（如用户信息）来说，这仍是一种可行的方法。</p>]]></content>
    </entry>
</feed>