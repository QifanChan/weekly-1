<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-07-20T07:10:08.310Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[不要指望每天都有动力]]></title>
        <id>https://addyosmani.com/blog/motivation/</id>
        <link href="https://addyosmani.com/blog/motivation/"/>
        <updated>2023-07-20T00:51:20.291Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/motivation/">Don't expect to be motivated everyday</a></p><p><strong>概要：</strong></p><p>这篇文章强调了纪律对于实现目标的重要性，而不是仅仅依赖动力。动力虽然能驱使我们完成伟大的事情，但它并不可靠且短暂。作者建议通过以下三种策略来培养纪律：开始小，比如每天写 100 个单词或完成 5 分钟的锻炼；保持一致，选择一个特定的时间或提示来执行你的习惯，并将其变成日常生活中不可更改的部分；接受失败，理解挫折是过程的自然部分，当你犯错误时，从中学习并继续前进。纪律为创建习惯奠定基础，从而形成例行公事，最终定义我们每天的自我。因此，下次当你缺乏动力时，不要感到绝望，而是依赖你的纪律帮助你度过困难时期并保持对目标的追求。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[是时候升级显示器了]]></title>
        <id>https://tonsky.me/blog/monitors/</id>
        <link href="https://tonsky.me/blog/monitors/"/>
        <updated>2023-07-20T00:48:28.727Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tonsky.me/blog/monitors/">Time to upgrade your monitor</a></p><p><strong>概要：</strong></p><p>这篇文章是作者根据自身经验，讨论了编程人员最佳显示器选择的观点。他认为，对于大多数编程工作，高分辨率和清晰的字体显示至关重要。他建议购买 4K 分辨率的显示器，并使用 2 倍的缩放以获得更好的文本渲染效果。此外，作者还推荐使用 120Hz 的刷新率，尽管这对于文本工作并非必须，但可以提供更流畅的动画和滚动效果，使系统感觉更加响应迅速。不过，他也指出，在 MacOS 上运行 4K 120Hz 显示可能会遇到一些问题，需要进行一些设置调整。总的来说，作者认为独立的高分辨率显示器对于编程工作来说是最佳选择。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[故事书 7.1]]></title>
        <id>https://storybook.js.org/blog/storybook-7-1/</id>
        <link href="https://storybook.js.org/blog/storybook-7-1/"/>
        <updated>2023-07-20T00:45:07.545Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://storybook.js.org/blog/storybook-7-1/">Storybook 7.1</a></p><p><strong>概要：</strong></p><p>Storybook 是 UI 组件开发、文档编写和测试的行业标准工作室，被 Twitter、GitHub、BBC 和纽约时报等团队使用。自今年四月发布 Storybook 7.0 后，我们计划推出更频繁且体积更小的未来版本，以便 Storybook 能够与前端生态系统中的变化保持同步，同时使我们的用户升级过程更加顺畅。今天，我们很高兴为您带来这些版本中的第一个：Storybook 7.1，其中包含了许多改进。此外，Storybook 支持 React、Vue、Angular、Web 组件、Svelte、Webpack 和 Vite 以及超过 400 种集成，使其成为迄今为止最强大的组件工作室。在 Storybook 7.1 中，我们通过为新用户引入入门流程来降低学习曲线。此外，Storybook 7.1 还为 Tailwind、Material UI、Emotion 和 styled-components 等提供了零配置样式支持。我们还为配置文件、ArgTypes 和 Doc 块引入了 API 参考文档，并将 Storybook 的文档制作为 TypeScript 优先，因为 TS 占据了所有 Storybook 项目的 80% 以上。此外，我们还增加了对 Vue 3 源片段和反应性改进的支持，并为文档添加了目录。我们还为 Figma 设计插件提供了官方支持，并进行了数百项修复和改进。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建自己的 FaaS：在 Fly 上自主托管 Cloudflare Worker 和 javascript 函数 | BreakpDev 博客]]></title>
        <id>https://www.breakp.dev/blog/build-your-own-faas/</id>
        <link href="https://www.breakp.dev/blog/build-your-own-faas/"/>
        <updated>2023-07-19T03:25:22.732Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.breakp.dev/blog/build-your-own-faas/">Build your own FaaS: Self-host Cloudflare workers and javascript functions on Fly and everywhere | BreakpDev Blog</a></p><p><strong>概要：</strong></p><p>本文提供了如何构建和自我托管一个完整的 FaaS（Function as a Service）架构的逐步指南。文章首先解释了什么是云计算中的函数以及 FaaS，然后阐述了为什么要自我托管 FaaS。接着，文章详细介绍了如何创建自己的 FaaS，包括设置发布者和工作人员、准备配置、进行干运行和部署等步骤。最后，文章还提供了一些额外的内容，如保护发布者 API、在发布时自动重启工作人员、发布命令行工具等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在网络上使用表情符号]]></title>
        <id>https://fullystacked.net/posts/using-emoji-on-the-web/</id>
        <link href="https://fullystacked.net/posts/using-emoji-on-the-web/"/>
        <updated>2023-07-19T01:29:38.563Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://fullystacked.net/posts/using-emoji-on-the-web/">Using emoji on the web</a></p><p><strong>概要：</strong></p><p>文章讨论了在不同操作系统和浏览器上使用表情符号的问题。大多数浏览器默认使用操作系统提供的表情字体，例如 ChromeOS 和大多数 Android 设备使用 Google 的 Noto Color Emoji，iOS 和 macOS 使用 Apple Color Emoji，Windows 使用 Microsoft Segoe Color Emoji。然而，Firefox 在 Windows 和 Linux 上是个例外，它使用 Twitter 的 Twemoji 字体。在 HTML 标记中使用表情符号通常可以正常工作，但也存在一些问题。例如，一些旧的表情符号可能以单色图标或多色表情符号呈现；Windows 用户（除 Firefox 浏览器外）无法看到国家旗帜的表情符号；老版本操作系统的用户无法获取新的表情符号。解决方案包括显式设置表情字体、使用 CSS 属性 font-variant-emoji、使用 color fonts 等。此外，还可以使用开源的 color emoji 字体，如 Google 的 Noto Color、Adobe 的 Emoji One、Twitter 的 Twemoji、Mozilla 的 FxEmoji 和 Microsoft 的 Fluent Emoji。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动画 SVG 徽标]]></title>
        <id>https://antfu.me/posts/animated-svg-logo</id>
        <link href="https://antfu.me/posts/animated-svg-logo"/>
        <updated>2023-07-19T01:21:42.778Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/animated-svg-logo">Animated SVG Logo</a></p><p><strong>概要：</strong></p><p>文章作者 Anthony Fu 分享了他如何将网站左上角的 Logo 替换为动态 SVG。首次看到这种 SVG 描边动画是在 Vjacheslav Trushkin 的 Material Line Icons 中，但直到在 Mu-An Chiou 的网站上看到类似的设计，才萌生了自己也要做一个的想法。通过研究 Mu-An 的 SVG 代码和参考 Material Line Icons，作者发现他们是通过动画化 stroke-dasharray 来实现这种效果的。原始 Logo 是 8 年前作者用 Surface Pro 4 上的压感笔绘制的，之后用 Adobe Illustrator 进行图像追踪得到 SVG 版本。作者需要用单个描边重新绘制 Logo，然后手动添加样式到导出的 SVG 中，从而得到一个不错的动态 Logo。唯一的缺点是描边在所有地方都均匀粗细，使其看起来不太像签名。作者试图寻找解决方案，最后发现 SVG 支持遮罩功能，于是尝试让描边在遮罩内部动画，并取得了成功。虽然这种方法并非完美，因为无法控制描边宽度，所以描边会稍微偏离遮罩，但作者认为这已经很好了。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fresh 1.3 - 简化的路由组件及其他]]></title>
        <id>https://deno.com/blog/fresh-1.3</id>
        <link href="https://deno.com/blog/fresh-1.3"/>
        <updated>2023-07-19T00:44:37.401Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/fresh-1.3">Fresh 1.3 – Simplified Route Components and More</a></p><p><strong>概要：</strong></p><p>自从我们发布 Fresh 1.2 后仅过去一个月，我们已经回来发布另一个版本！我们计划每个月都发布新的小版本。这个周期包含了社区的许多令人难以置信的 PR，这简直太棒了！文档得到了扩展和改进，修复了许多错误并添加了新功能。感谢所有帮助完成此次发布的人。但话不多说，让我们看看我们对 Fresh 进行了哪些改进。

异步路由组件
从插件中添加路由和 / 或中间件
500 错误模板回退
错误边界
在同一文件中导出多个岛屿
Fresh linting 规则
支持 Deno.serve
更多提高生活质量的改进

异步路由组件我们听到很多反馈，从路由处理程序传递数据到页面的组件需要一些烦人的样板文件。为了确保类型安全，你总是需要为组件的 props 创建一个接口，将其作为通用的传递给 Handlers 类型，并在组件定义中使用它。这真是很多步骤！
由于 GET 处理程序往往与它将呈现的组件高度耦合，显而易见的问题是，为什么我们不直接将两者合并在一起？这正是我们所做的。在 Fresh 1.3 中，我们可以大大简化之前的代码片段：
由于处理程序和组件都在同一个函数中，因此无需声明一个中间接口来在两者之间传递数据；你可以直接传递数据。
但是别担心，没有必要重写所有的路由。实际上，我们并不喜欢重写代码。新的方式只是一个额外的选项，可以使简单的路由更容易编写。使用异步路由并非</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Copilot 7 月 14 日更新]]></title>
        <id>https://github.blog/changelog/2023-07-14-github-copilot-july-14th-update/</id>
        <link href="https://github.blog/changelog/2023-07-14-github-copilot-july-14th-update/"/>
        <updated>2023-07-19T00:26:16.401Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/changelog/2023-07-14-github-copilot-july-14th-update/">GitHub Copilot July 14th Update</a></p><p><strong>概要：</strong></p><p>2023 年 7 月 14 日，GitHub 为其 Visual Studio Code 和 Visual Studio 扩展中的 Chat 功能进行了许多改进，并为管理员提供了新的能力。首先，他们推出了针对 Copilot for Business 的 User Management API（beta），使管理员可以列出所有启用 Copilot 的组织成员及其详细信息，并为个人和团队添加 / 删除访问权限，从而实现大规模的自动化访问管理。此外，他们还在 Visual Studio Code 1.80 中引入了新的创建命令，如 /search, /createWorkspace 等，以帮助用户创建项目和笔记本，并在工作空间中搜索文本。同时，他们还对 Visual Studio 扩展进行了改进，包括更好地支持其他编程语言，保存和恢复聊天历史，清除聊天历史，多行提示框，显示内容的流媒体支持，测试生成的特定插入，以及改善整个聊天体验的各种生活质量更新。最后，他们还引入了基于嵌入的上下文感知操作，如文档，解释和生成测试，这些操作利用现有的内联上下文并制定特定的意图，以提供最佳的任务体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 18 如何提高应用程序性能 - Vercel]]></title>
        <id>https://vercel.com/blog/how-react-18-improves-application-performance</id>
        <link href="https://vercel.com/blog/how-react-18-improves-application-performance"/>
        <updated>2023-07-19T00:24:43.774Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/how-react-18-improves-application-performance">How React 18 Improves Application Performance – Vercel</a></p><p><strong>概要：</strong></p><p>React 18 引入了并发特性，从根本上改变了 React 应用的渲染方式。当我们在浏览器中运行 JavaScript 时，JavaScript 引擎在单线程环境中执行代码，这通常被称为主线程。主线程负责处理其他任务，包括管理用户交互、处理网络事件、定时器、更新动画和管理浏览器重排和重绘。任何运行时间超过 50 毫秒的任务都被视为 "长任务"。React 18 引入了一个新的并发渲染器，它在后台操作。这个渲染器为我们提供了一些方法，使得某些渲染标记为非紧急。此外，这个并发渲染器能够 “并发” 地在后台渲染组件树的多个版本，而不是立即提交结果。React 服务器组件是 React 18 的实验性功能，但已经准备好让框架采用。使用 Suspense，我们可以延迟渲染一个组件，直到满足某些条件，如从远程源加载数据。总的来说，React 18 的最新特性在很多方面提高了性能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023 年的 Npm 状态：概述]]></title>
        <id>https://blog.sandworm.dev/state-of-npm-2023-the-overview</id>
        <link href="https://blog.sandworm.dev/state-of-npm-2023-the-overview"/>
        <updated>2023-07-18T10:52:05.295Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.sandworm.dev/state-of-npm-2023-the-overview">State Of Npm 2023: The Overview</a></p><p><strong>概要：</strong></p><p>这篇文章是 "npm 状态 2023" 系列的一部分。在这个系列中，Sandworm 团队深入探讨了 npm 的当前状况，挖掘出了有趣的统计数据，并揭示了有关注册表的引人入胜的事实。

在软件开发的广阔领域中，一个名字已经成为 JavaScript 生态系统的代名词：npm。作为全球数百万开发者的首选包管理器，npm 在革新我们构建和分享 JavaScript 代码的方式上发挥了关键作用。随着其庞大的注册表不断收纳更多的包，npm 已经成为了一种不可或缺的工具，推动创新并赋予开发者轻松创建出色应用的能力。

在本系列中，Sandworm 团队深入探讨了 npm 的当前状况，挖掘出了有趣的统计数据，并揭示了有关注册表的引人入胜的事实。从包的数量到最受欢迎的库，我们将探索这个为 JavaScript 社区提供动力的强大工具的内部运作。让我们一起来更深入地了解 npm 的状态，并洞察其中的趋势、模式和充满活力的生态系统。

npm 的初始提交是由 Isaac Z. Schlueter（isaacs）在 2009 年 9 月 29 日推送的。它最初是一个在 VPS 上的单一 CouchDB 服务。"npm" 原本代表 "Node Package Manager"，但后来被改为递归的反向首字母缩写，意思是 "npm 不是首字母缩写"。npm 在 2014 年作为一家公司成立，当时它筹集了 260 万美元以持续资助其迅速增长的社</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - 0xpayne/gpt-migrate：轻松地将代码库从一个框架或语言迁移到另一个框架或语言。]]></title>
        <id>https://github.com/0xpayne/gpt-migrate</id>
        <link href="https://github.com/0xpayne/gpt-migrate"/>
        <updated>2023-07-18T08:16:27.616Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/0xpayne/gpt-migrate">GitHub - 0xpayne/gpt-migrate: Easily migrate your codebase from one framework or language to another.</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 GPT-Migrate 的项目，该项目能够帮助用户轻松地将代码库从一个框架或语言迁移到另一个。尽管迁移是一个昂贵、繁琐且非平凡的问题，但借助开源社区的集体智慧和大型语言模型的当前状态，这个问题变得可以处理。GPT-Migrate 首先为目标语言创建一个 Docker 环境，然后评估现有代码以识别第三方依赖项，并选择相应的目标语言依赖项。接着，它从指定的源文件开始递归地构建新的目标语言代码。然后，它启动带有新代码库的 Docker 环境，并根据需要进行迭代调试。它使用 Python 的 unittest 框架开发单元测试，并可选择性地针对运行中的原始应用程序进行测试。最后，它会在日志、错误消息、相关文件和目录结构的上下文中为你迭代地调试代码。新的代码库完成后将存在于目标目录中。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[软件工程：解决问题和批判性思维]]></title>
        <id>https://addyosmani.com/blog/softeng-problem-solving/</id>
        <link href="https://addyosmani.com/blog/softeng-problem-solving/"/>
        <updated>2023-07-18T04:44:54.270Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/softeng-problem-solving/">Software engineering: problem-solving and critical-thinking</a></p><p><strong>概要：</strong></p><p>这篇文章强调了软件工程不仅仅是编码，更重要的是解决问题和批判性思考。软件工程被误解为只涉及编码，但实际上，它涉及到解决问题和批判性思考的方面，编码只是冰山一角，是分析严谨、抽象推理和创造性问题解决过程的具体输出。软件工程的核心不仅仅在于编码，更在于进行编码之前的过程。在软件工程中，每一个软件都是为了解决特定的问题或一系列问题而创建的，工程师首先需要理解他们需要解决的问题，然后概念化可能的解决方案。批判性思考是软件工程的基础，它涉及到对问题的客观分析和评估以形成判断，在设计阶段、实施阶段和测试阶段都需要应用批判性思考。总的来说，软件工程是解决问题和批判性思考的复杂结合，编码只是其表现形式。随着软件越来越深入地融入我们社会的结构中，软件工程师的角色也在扩大，他们不仅需要擅长编码，还必须是熟练的问题解决者和批判性思考者。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博雅发布 v0.17 - Boa]]></title>
        <id>https://boajs.dev/posts/2023-07-08-boa-release-17/</id>
        <link href="https://boajs.dev/posts/2023-07-08-boa-release-17/"/>
        <updated>2023-07-18T04:09:46.861Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://boajs.dev/posts/2023-07-08-boa-release-17/">Boa release v0.17 - Boa</a></p><p><strong>概要：</strong></p><p>Boa v0.17 已经发布，这是自项目开始以来最大的一次 Boa 发布。在大约 7 个月的开发后，我们很高兴向您展示 Boa JavaScript 引擎的最新版本。Boa 使得在你的项目中嵌入 JS 引擎变得简单，你甚至可以从 WebAssembly 中使用它。在此版本中，我们的符合性从官方 ECMAScript 测试套件（Test262）的 74.53% 增长到 78.74%，我们现在通过了比上一版本多 6079 个测试。此外，此版本的重大变化不在于符合性，而在于巨大的内部增强和新的 API。此次大规模发布部分得益于 Lit Protocol 的资助。此外，Boa 现在有了一个新的域名 boajs.dev。在此版本中，我们添加了 HostHooks 和 JobQueue 特性到 Context，这将允许主机实现自定义事件循环和其他主机特定功能。此外，Boa 现在有了国际化支持，尽管我们还在努力完全符合 ecma402 规范，但我们已经有了一些 Intl 工具。此版本的 Boa 还包含了一些新的功能，如 JsPromise, JsRegExp, JsGenerator, JsDate 和 JsDataView 等内置对象包装器。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不健康冲突与健康冲突]]></title>
        <id>https://addyosmani.com/blog/healthy-unhealthy-conflict/</id>
        <link href="https://addyosmani.com/blog/healthy-unhealthy-conflict/"/>
        <updated>2023-07-17T10:36:07.588Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/healthy-unhealthy-conflict/">Unhealthy conflict vs. healthy conflict</a></p><p><strong>概要：</strong></p><p>这篇文章探讨了健康冲突和不健康冲突的区别，以及如何利用冲突的积极方面促进成长。不健康的冲突以对抗性心态为特征，人们将彼此视为对手，重点在于个人胜利而非解决问题。健康的冲突则将分歧视为需要共同解决的问题，这种心态培养出合作和相互尊重的氛围。文章还提供了一些策略来培养健康冲突的文化，包括设定基本的尊重沟通原则、积极倾听他人的观点、使用 "I" 语句表达自己的感受和观察、寻找共同立场以及提供和接受妥协。健康的冲突可以成为促进成长的催化剂。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[尽可能长时间地坚持乏味的建筑风格]]></title>
        <id>https://addyosmani.com/blog/boring-architecture/</id>
        <link href="https://addyosmani.com/blog/boring-architecture/"/>
        <updated>2023-07-17T10:35:36.345Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/boring-architecture/">Stick to boring architecture for as long as possible</a></p><p><strong>概要：</strong></p><p>Kelsey Hightower 建议在新项目开始时，尽可能坚持使用 "无聊" 的架构，并将大部分时间和资源投入到客户愿意付费的产品建设中。他认为，虽然工程师们天生对新奇的解决方案有吸引力，但是区分什么是激动人心的，什么是适合你的用例是至关重要的。通常，“无聊” 的技术 —— 那些稳定、被理解并且可能是上一代的工具 —— 有很多可以提供的。它们经过试验和测试，已证明可扩展性，且配有详细的文档和社区支持。在采用新技术之前，需要问自己：这是否解决了一个特定的问题或显著增强了我的产品？这是否值得学习曲线和潜在的不稳定性？这是否会在未来帮助我们？Hightower 还提出了 "创新点原则"，即每个项目都有一个 “创新点”，可以用来采用 “激动人心” 的技术或架构。这个单一的点迫使你做出深思熟虑的选择。除非新技术显然给你的项目增加了实质价值，否则应依赖于你知道的有效工作。最后，他建议从基于良好理解的技术的坚实基础开始你的项目，随着项目的发展和你对挑战的深入理解，评估是否有充分的理由引入更先进的技术。这是一种有意识的进展：从无聊开始，然后有策略地创新。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - tc39/proposal-defer-import-eval：关于引入模块延迟评估方法的建议]]></title>
        <id>https://github.com/tc39/proposal-defer-import-eval</id>
        <link href="https://github.com/tc39/proposal-defer-import-eval"/>
        <updated>2023-07-17T00:05:33.260Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/tc39/proposal-defer-import-eval">GitHub - tc39/proposal-defer-import-eval: A proposal for introducing a way to defer evaluate of a module</a></p><p><strong>概要：</strong></p><p>文章介绍了一种名为 "推迟模块评估"（曾被称为 "懒惰模块初始化"）的新技术，其目标是提高大型 JavaScript 应用程序的性能。这项技术旨在解决在应用程序初始化期间由于代码编写方式导致的 CPU 瓶颈问题。推迟模块评估的提案是引入一种新的语法形式，该形式只会返回一个命名空间异构对象。使用此形式时，模块及其依赖项不会被执行，但会在模块图被认为已加载之前完全加载到可执行状态。只有在访问此模块的属性时，才会执行执行操作（如果需要）。这样，模块命名空间异构对象就像是模块评估的代理，有效地触发同步评估并返回定义的绑定。然而，这项技术还存在一些问题，例如无法推迟执行使用顶级等待的模块的评估，以及在导入使用推迟导入语法的模块时，其异步依赖项及其自身的传递依赖项将被积极评估，只有图形的同步部分被推迟。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[交互设计的隐形细节]]></title>
        <id>https://rauno.me/craft/interaction-design</id>
        <link href="https://rauno.me/craft/interaction-design"/>
        <updated>2023-07-14T12:14:37.127Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://rauno.me/craft/interaction-design">Invisible Details of Interaction Design</a></p><p><strong>概要：</strong></p><p>这篇文章探讨了交互设计的科学性和直觉性，作者通过深入研究并试图解构出优秀的交互设计背后的原因。他认为，伟大的设计启示往往源于创造过程中遇到的问题，而不仅仅是坐下来深思熟虑。文章还分析了一些常用但很少被思考的交互细节，如隐喻、动态物理、滑动手势、反应式手势等，并强调了设计决策的重要性。作者认为，交互设计不仅需要形式和功能之间的平衡，也需要对人类行为的深入理解。此外，文章还讨论了如何通过反思和模仿界面来建立更强的设计直觉和词汇表，并提出了 “无输入” 即上下文作为输入的理念，以及 Fitts 定律等概念。最后，作者强调了理解和阐述为何某样东西感觉对的重要性，这有助于培养品味，提高执行水平，并增加对卓越追求的欣赏。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3种常见的测试自动化类型]]></title>
        <id>https://web.dev/ta-types/</id>
        <link href="https://web.dev/ta-types/"/>
        <updated>2023-07-14T01:01:52.841Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://web.dev/ta-types/">3 common types of test automation</a></p><p><strong>概要：</strong></p><p>这篇文章主要探讨了如何进行 web 开发测试，包括两种一般的测试模式和三种常见的自动化测试类型。首先，我们需要确定我们应用程序质量需要保证的部分以及如何实现。在开始编写实际的测试代码之前，我们需要有一个计划。本文主要关注的是如何进行测试。我们的主要目标是规划正确的测试策略，但我们将在这里介绍最初的步骤：让我们发现可以用来从共同基础开始的测试类型。手动测试和自动化测试是两种基本的测试方式，然后详细介绍了不透明盒子测试（又称黑盒测试）和清晰盒子测试（又称白盒测试）两种测试程序。接着，文章介绍了单元测试、集成测试、端到端测试、视觉 UI 测试和静态分析等五种测试类型。最后，文章提出了五种常见的测试策略：测试金字塔、测试钻石、测试冰锥、测试蜂巢和测试奖杯。在下一篇文章中，我们将更详细地讨论这些不同的策略，并解释如何为你的项目选择最合适的策略。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js中的矢量数据库入门]]></title>
        <id>https://thecodebarbarian.com/getting-started-with-vector-databases-in-node-js.html</id>
        <link href="https://thecodebarbarian.com/getting-started-with-vector-databases-in-node-js.html"/>
        <updated>2023-07-14T00:56:16.725Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://thecodebarbarian.com/getting-started-with-vector-databases-in-node-js.html">Getting Started with Vector Databases in Node.js</a></p><p><strong>概要：</strong></p><p>向量数据库是当前的热门话题，其结合 AI 工具如 ChatGPT，可以实现语义相似性搜索：找出与此物体相似的物品。这种搜索形式比基本搜索引擎或文本搜索更复杂，因为搜索算法能够解释文本的语义，而不仅仅是尝试匹配关键词。一个语义搜索的应用是主题分类：给定一段文本，确定预定列表中哪个类别最符合该文本。例如，给定句子 "apple jumped 10% today"，这句话是关于 "Food" 还是 "Stocks"？传统的关键词搜索在这种区别上会有困难，因为没有办法在不解释文本语义的情况下区分苹果（水果）和 Apple（公司）。本教程将指导你使用 Node.js 和一个名为 Chroma 的向量数据库来构建一个玩具主题分类工具。

要在本地运行 Chroma，你应该克隆 Chroma 的 GitHub 仓库，并按照以下方式运行他们的 docker-compose 文件。一旦你运行了 Chroma，如果你还没有 OpenAI 的密钥，你也应该获取一个。然后，你可以使用你的 OpenAI 密钥在 Chroma 中存储给定句子的嵌入。嵌入是表示给定文本特征的向量。

主题分类的一个简单方法是为每个主题插入一些样本文本的嵌入，对于任何给定的文本，找到最接近该文本的向量。例如，让我们使用 "apple jumped 10% today" 作为 "Stocks" 类别的代表，"i like apple pie" 作为 "Food" 类别的代表。以下代码为这两个句子生成嵌入，并将它们与相关类别的元数据一起插入</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[您应该在项目配置中包含的5个TS编译器标志]]></title>
        <id>https://egorkonovalov.github.io/flycatcher/posts/3/</id>
        <link href="https://egorkonovalov.github.io/flycatcher/posts/3/"/>
        <updated>2023-07-14T00:55:42.107Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://egorkonovalov.github.io/flycatcher/posts/3/">5 TS Compiler Flags You Should Include In Your Project's Config</a></p><p><strong>概要：</strong></p><p>新发布的 TypeScript 5.0 主要更新引入了许多重大变化，如稳定的装饰器，常规枚举被联合枚举替代等。但是，我在阅读发布说明时发现了一些新的编译器选项，这让我思考是否有理由设置自定义编译器设置？简短的答案是 - 是的。本文介绍了五个可以提高开发体验的 TypeScript 编译器标志：noImplicitOverride、noUncheckedIndexedAccess、noPropertyAccessFromIndexSignature、allowUnreachableCode 和 noFallthroughCasesInSwitch。通过利用这些编译器设置，你可以提高代码库的安全性、可读性和可维护性。虽然默认配置已经过测试并且可靠，但花时间探索和调整编译器设置可以提供宝贵的见解和优化。然而，必须在便利和定制之间找到平衡，尝试与团队讨论你将使用的风格，并构建所有人都喜欢的环境。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prettier 3.0: 你好, ECMAScript 模块！- 袩褉芯懈蟹胁芯写褋褌胁械薪薪褘械]]></title>
        <id>https://prettier.io/blog/2023/07/05/3.0.0.html</id>
        <link href="https://prettier.io/blog/2023/07/05/3.0.0.html"/>
        <updated>2023-07-14T00:53:38.099Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://prettier.io/blog/2023/07/05/3.0.0.html">Prettier 3.0: Hello, ECMAScript Modules! · Prettier</a></p><p><strong>概要：</strong></p><p>Prettier 团队发布了新版本，其中包括对 ECMAScript 模块的全面使用。这一改变极大地提高了开发体验。此次更新带来了一些重大变化，例如在 markdown 格式中，拉丁字符和中文或日文字符之间不再插入空格。另外，trailingComma 的默认值已更改为 "all"。此次发布还对插件接口进行了重大改造，现在 Prettier 支持使用 ECMAScript 模块和异步解析器编写的插件。此外，该版本还包括许多格式化改进和错误修复。如果你赞赏 Prettier 并希望支持我们的工作，请考虑直接通过我们的 OpenCollective 赞助我们，或者赞助我们依赖的项目，如 typescript-eslint、remark 和 Babel。感谢你的持续支持！</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[超越浏览器：JavaScript标准的长远未来]]></title>
        <id>https://thenewstack.io/beyond-browsers-the-longterm-future-of-javascript-standards/</id>
        <link href="https://thenewstack.io/beyond-browsers-the-longterm-future-of-javascript-standards/"/>
        <updated>2023-07-14T00:53:08.776Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://thenewstack.io/beyond-browsers-the-longterm-future-of-javascript-standards/">Beyond Browsers: The Longterm Future of JavaScript Standards</a></p><p><strong>概要：</strong></p><p>JavaScript，被许多排名认为是最流行和最广泛使用的语言，已经从浏览器中崭露头角，并在其初始平台之外变得非常有用。然而，该语言的 ECMAScript 标准仍主要受到浏览器需求的驱动。即使在新环境中，如服务器端和嵌入式 JavaScript 运行时，这些运行时仍在使用来自浏览器的 JavaScript 引擎，尽管他们的需求往往大不相同。

WinterCG 社区组织于去年在 W3C 成立，目的是关注浏览器和非浏览器运行时之间的跨运行时互操作性，倡导对服务器端 JavaScript 环境重要的特性，这些特性可能对浏览器并不那么重要。WinterCG 并非一个竞争性的标准机构，而是关于协调的，识别共同需求并通过标准机构或其他地方进行协商。

WinterCG 正在试图协调一种适合服务器的 fetch 版本，以及支持 Web API，如文本编码器和设置超时 API，在各个运行时中以兼容的方式运行。这并不是创建一个新的规范，而是从实际的 fetch 规范开始，剔除对服务器不适用的部分。

对于 JavaScript 开发者来说，能够依赖所有 Web 互操作运行时的全面统一 API 表面将是理想的基础。支持浏览器中可用的子集的通用方式，将使开发者和运行时创建者构建新功能更加经济和可持续。

异步上下文是一种简化代码追踪发生情况的方式，通过共享变量。这种分布式追</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[滚动驱动动画性能案例研究 - Chrome Developers]]></title>
        <id>https://developer.chrome.com/blog/scroll-animation-performance-case-study/</id>
        <link href="https://developer.chrome.com/blog/scroll-animation-performance-case-study/"/>
        <updated>2023-07-14T00:52:23.163Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/blog/scroll-animation-performance-case-study/">A case study on scroll-driven animations performance - Chrome Developers</a></p><p><strong>概要：</strong></p><p>文章介绍了滚动驱动动画，这是一种通过用户的滚动位置触发的方式，增加网站或网络应用的互动性和视觉吸引力。过去，创建滚动驱动动画的唯一方式是在主线程上响应滚动事件，这存在两个主要问题：滚动是在单独的进程上执行并异步传递滚动事件；主线程动画容易出现卡顿。因此，创建与滚动同步且高效的滚动驱动动画非常困难。现在，我们引入了一套新的 API 来支持滚动驱动动画，可以通过 CSS 或 JavaScript 使用。新 API 尽可能少地使用主线程资源，使得实现滚动驱动动画更加容易和流畅。文章还通过对比新旧方法，展示了新 API 如何轻松实现平滑的滚动驱动动画。最后，文章指出新 API 不仅限于 CSS，还可以使用 JavaScript 创建流畅的滚动驱动动画，与 CSS 版本的底层技术相同，尽可能少地使用主线程资源，使动画比传统的 JavaScript 方法更流畅。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prisma 5: 默认速度更快]]></title>
        <id>https://www.prisma.io/blog/prisma-5-f66prwkjx72s</id>
        <link href="https://www.prisma.io/blog/prisma-5-f66prwkjx72s"/>
        <updated>2023-07-14T00:51:29.466Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.prisma.io/blog/prisma-5-f66prwkjx72s">Prisma 5: Faster by Default</a></p><p><strong>概要：</strong></p><p>Prisma 4.8.0 版本开始，我们加大了改善 Prisma 性能和开发者体验的努力，特别是在无服务器环境中提高 Prisma 的启动性能。通过改进，我们发现了一些效率问题并解决了它们。为了说明我们提升性能的成果，以下是在我们进行改进之前和之后的 AWS Lambda 部署应用（带有大型 Prisma 模式，含 500 个模型）的启动性能对比图。你可以看到，Prisma 的启动性能有了显著的改善。在 Prisma 4.11.0 版本之前，Prisma 使用类似 GraphQL 的协议在 Prisma 客户端和查询引擎之间通信，这对于 Prisma 客户端的性能产生了影响，尤其是在无服务器环境的冷启动中。我们注意到，当前的实现方式增加了相当大的 CPU 和内存开销，尤其是对于较大的模式。我们的解决方案之一是完全重新设计我们的线协议。使用 JSON，我们能够使 Prisma 客户端和查询引擎之间的通信变得更加高效。此外，我们还优化了查询引擎的内部机制，包括减少了 Prisma 客户端的依赖数量，移除了之前的类似 GraphQL 的协议实现，优化了数据库连接和 Prisma 模式转换等过程，从而显著提高了运行时性能。同时，我们鼓励用户升级到 Prisma 5.0.0 版本，并期待听到您的反馈。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[外部磁盘上的 pnpm]]></title>
        <id>https://antfu.me/posts/pnpm-external-disk</id>
        <link href="https://antfu.me/posts/pnpm-external-disk"/>
        <updated>2023-07-14T00:49:36.458Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/pnpm-external-disk">pnpm on External disk</a></p><p><strong>概要：</strong></p><p>如果你试图在外部磁盘上安装使用 pnpm 的项目，可能无法立即工作，因为 pnpm 严重依赖于符号链接，而这在跨挂载点时无法工作。为了解决这个问题，你可以在.npmrc 中添加以下配置：这将使 pnpm 复制文件而不是创建它们的符号链接，并正确地在 node_modules/.bin 中显示可执行文件。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无需 Figma 的网页设计]]></title>
        <id>https://world.hey.com/dhh/design-for-the-web-without-figma-4bc3a218</id>
        <link href="https://world.hey.com/dhh/design-for-the-web-without-figma-4bc3a218"/>
        <updated>2023-07-13T06:10:35.094Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://world.hey.com/dhh/design-for-the-web-without-figma-4bc3a218">Design for the web without Figma</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了 Figma 设计工具的使用和网页设计的最佳实践。虽然 Figma 是一个非常出色的设计工具，被 37signals 等公司广泛使用，但在开发 Basecamp 或 HEY 等网络应用时，他们并不主要依赖 Figma，而是直接在 HTML 和 CSS 中进行设计。因为无论 Figma 多么优秀，它仍然是一种中间抽象层，像之前的 Photoshop 一样。如果你在网络上工作，没有这种抽象层的设计过程会使程序员和设计师的协作更加顺畅。37signals 的两人团队就是通过这种方式提高生产力和可行性的。他们所有的网络设计师都直接使用 HTML、CSS，甚至大量的 JavaScript 和 Ruby。设计过程及其迭代通过更新真实运行的应用程序的代码，并尽快对真实数据进行反馈。作者认为，创造力源于限制，设计师应该熟练掌握网络的材料，而不必成为前端开发的专家。他们应该努力提高他们的 HTML、CSS、JavaScript 技能，甚至后端语言技能，作为他们职业发展的关键部分。虽然找到既能设计又能实现创意的设计师可能很难，但 37signals 已经多次做到了，从而大大提高了生产力。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[克劳德 2]]></title>
        <id>https://www.anthropic.com/index/claude-2</id>
        <link href="https://www.anthropic.com/index/claude-2"/>
        <updated>2023-07-13T06:09:09.973Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.anthropic.com/index/claude-2">Claude 2</a></p><p><strong>概要：</strong></p><p>我们很高兴地宣布推出新模型 Claude 2。Claude 2 的性能得到了提升，响应更长，可以通过 API 以及新的公开测试网站 claude.ai 进行访问。用户反馈称，Claude 易于交谈，清晰解释其思考过程，不太可能产生有害输出，并且记忆力更强。我们在编码、数学和推理方面对上一代模型进行了改进。例如，我们的最新模型在律师资格考试的多项选择题部分得分为 76.5%，比 Claude 1.3 的 73.0% 有所提高。Claude 2 在 GRE 阅读和写作考试中的得分超过了 90% 的申请研究生的成绩，而在定量推理方面的得分与中位数申请人相似。Claude 2 的输入和输出长度都得到了增加，用户可以在每个提示中输入多达 100K 的标记，这意味着 Claude 可以处理数百页的技术文档甚至一本书。Claude 现在也可以一次性写出更长的文件 —— 从备忘录到信件到故事，所有这些都可以一次性完成。此外，我们的最新模型在编码技能方面有了显著的提高。Claude 2 在 Codex HumanEval 的 Python 编码测试中得分为 71.2%，高于 56.0%。在 GSM8k（一套大型小学数学问题集）中，Claude 2 的得分为 88.0%，高于 85.2%。我们已经为 Claude 2 规划了一系列令人兴奋的功能改进计划，并将在未来几个月中逐步部署。Claude 2 目前在美国和英国普遍可用，我们正在</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[您可能不需要Jest - Node.js原生测试运行器非常棒 | pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/you-might-not-need-jest-the-node-js-native-test-runner-is-great/</id>
        <link href="https://pawelgrzybek.com/you-might-not-need-jest-the-node-js-native-test-runner-is-great/"/>
        <updated>2023-07-12T14:59:06.342Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/you-might-not-need-jest-the-node-js-native-test-runner-is-great/">You might not need Jest — the Node.js native test runner is great | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>文章主要介绍了 Node.js 原生测试运行器的一些特性和使用方法。现代的 JavaScript 运行时环境，如 Deno 和 Bun，以及像 Go 和 Rust 这样的现代编程语言都具备测试功能，Node.js 也在逐步跟上。Node.js 的测试运行器模块在 18 版本中首次实验性引入，并在 20 版本中稳定下来。此模块在出现错误时返回进程退出代码 1，否则返回 0。此外，文章还介绍了如何使用 node:assert 模块简化断言，以及如何执行所有匹配文件的测试。Node.js 在添加测试设施时功能有限，但几次迭代后，我们现在可以使用许多更常用的测试特性，如分组、模拟、挂钩等。此外，Node.js 在 18.11 版本中添加了观察模式，稍后在 19.2 版本中为测试运行器添加了观察模式。默认的人类可读测试报告（spec）可以替换为紧凑（dot）格式，如果这些选项都不符合你的需求，可以使用 npm 安装自定义报告，或者创建一个遵循 TAP（Test Anything Protocol）规范的自定义报告。最后，作者表示，使用 jest 也是可以的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用耳语转录播客]]></title>
        <id>https://www.swyx.io/whisper-for-podcasts</id>
        <link href="https://www.swyx.io/whisper-for-podcasts"/>
        <updated>2023-07-12T04:33:06.092Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.swyx.io/whisper-for-podcasts">Using Whisper to Transcribe Podcasts</a></p><p><strong>概要：</strong></p><p>该文章是作者在邀请读者订阅他们的时事通讯，包括 AI 新闻和 DevRel/DevTools 新闻。目前已有超过 10,000 的订阅者，并会不定期更新新的帖子和项目。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - privatenumber/minification-benchmarks: 🏃‍♂️🏃‍♀️🏃 JS minification benchmarks: babel-minify, esbuild, terser, uglify-js, swc, google closure compiler, tdewolff/minify]]></title>
        <id>https://github.com/privatenumber/minification-benchmarks</id>
        <link href="https://github.com/privatenumber/minification-benchmarks"/>
        <updated>2023-07-12T04:29:20.988Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/privatenumber/minification-benchmarks">GitHub - privatenumber/minification-benchmarks: 🏃‍♂️🏃‍♀️🏃 JS minification benchmarks: babel-minify, esbuild, terser, uglify-js, swc, google closure compiler, tdewolff/minify</a></p><p><strong>概要：</strong></p><p>这篇文章是一个关于 JavaScript 压缩器性能对比的报告，涵盖了 babel-minify、esbuild、google-closure-compiler、minify-js、swc、tdewolff/minify、terser 和 uglify-js 等多种压缩器。每个压缩器都在自己的进程中执行，设定了 20 秒的超时时间，并在压缩前后进行了完整性测试。压缩器的排名依据是压缩后文件的大小。测试结果显示，在多数情况下，uglify-js 和 swc 的表现最佳，它们不仅能有效地减小文件大小，还能在较短的时间内完成压缩任务。</p>]]></content>
    </entry>
</feed>