<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-07-24T05:51:39.716Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[如何取得成功]]></title>
        <id>https://blog.samaltman.com/how-to-be-successful</id>
        <link href="https://blog.samaltman.com/how-to-be-successful"/>
        <updated>2023-07-24T04:41:08.273Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.samaltman.com/how-to-be-successful">How To Be Successful</a></p><p><strong>概要：</strong></p><p>这篇文章是由 Y Combinator 的合伙人 Sam Altman 撰写，分享了他对创业成功的 13 个观点。首先，他强调了复利效应的重要性，建议寻找并创造具有网络效应和极端可扩展性的业务。其次，他提倡培养过度的自我信念，独立思考，并学会销售。他还建议早期在职业生涯中冒险，保持专注并努力工作。此外，他鼓励大胆行事，坚定意志，难以与之竞争，并建立一个网络。他指出，通过拥有价值迅速增长的东西来致富，并主张内驱动。最后，他强调了自我激励的重要性，认为最成功的人通常是由内心驱动的，他们做事是为了给自己留下深刻印象，因为他们感到有必要在世界上做出一些事情。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们如何从典型 Rust SDK 生成 JavaScript 和 Python SDK - PostgresML]]></title>
        <id>https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk</id>
        <link href="https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk"/>
        <updated>2023-07-24T01:57:43.612Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk">How We Generate JavaScript and Python SDKs From Our Canonical Rust SDK – PostgresML</a></p><p><strong>概要：</strong></p><p>PostgresML 团队正在开发一种新的软件开发工具包（SDK），能够将用 Rust 编写的代码转化为 Python 和 JavaScript 模块。他们选择 Rust 作为主要语言，因为它能使代码更安全并加快开发周期。然而，大多数用户仍在使用 Python 和 JavaScript 等语言，所以他们决定制作一个可以在多种语言中使用的 SDK。他们的目标是只在 Rust 中编写一次 SDK，然后使其在任何目标语言中都可用。为此，他们创建了一种流程，通过使用自定义宏来生成 Pyo3 和 Neon Rust 所需的代码。他们还计划将这些宏推广出去，并添加对更多语言的支持。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jeremy Mikkola - 是什么让开发人员富有成效？]]></title>
        <id>https://jeremymikkola.com/posts/developer_productivity.html</id>
        <link href="https://jeremymikkola.com/posts/developer_productivity.html"/>
        <updated>2023-07-24T01:56:32.036Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jeremymikkola.com/posts/developer_productivity.html">Jeremy Mikkola - What makes developers productive?</a></p><p><strong>概要：</strong></p><p>这篇文章探讨了影响开发者生产力的多个因素。一些因素如构建时间容易衡量，但有些因素如开发者对系统的理解程度则难以直接衡量。文章指出，知道要构建什么、做更少的事情、使用反应迅速的工具、开发者头脑中的知识、有帮助的基础设施、低技术债务、低失败率、实用的生产实践、工程师的专注度和完成任务等都是影响生产力的重要因素。作者强调，尽管不能直接通过仪表板来衡量所有这些不同的因素，但任何开发者都能告诉你哪些因素正在影响他们的生产力。修复这些问题可能会大大提高完成任务的数量。例如，花几个小时写一份文档可能会为公司节省数千个小时。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 查询和 React 上下文]]></title>
        <id>https://tkdodo.eu/blog/react-query-and-react-context</id>
        <link href="https://tkdodo.eu/blog/react-query-and-react-context"/>
        <updated>2023-07-24T01:54:02.854Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tkdodo.eu/blog/react-query-and-react-context">React Query and React Context</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了 React Query 的实践应用，特别是在组件树中使用查询的优势。作者指出，React Query 允许我们在需要数据的地方获取数据，使组件解耦和独立。然而，这并非完美无缺，也存在一些权衡。例如，为了使组件自动化，它必须处理查询数据不可用的情况，如加载和错误状态。此外，还存在隐式依赖性问题，即只存在于我们头脑中的依赖关系，但在代码中却看不到。最后，作者提出了一个解决方案，即通过 React Context 使依赖性显性化。尽管 TypeScript 可能不喜欢这种方法，但我们可以通过添加一个不变量来确保在错误的地方访问 useCurrentUserContext 时能快速失败并给出好的错误信息。总的来说，虽然这种技术可能会产生网络瀑布等问题，但对于子树的必需数据（如用户信息）来说，这仍是一种可行的方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最重要的编码习惯]]></title>
        <id>https://puppycoding.com/2023/07/22/healthy-coding-habits/</id>
        <link href="https://puppycoding.com/2023/07/22/healthy-coding-habits/"/>
        <updated>2023-07-24T01:53:42.324Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://puppycoding.com/2023/07/22/healthy-coding-habits/">The Most Important Coding Habits</a></p><p><strong>概要：</strong></p><p>这篇文章的作者分享了他因长时间低头对着键盘编程，导致脊椎间盘突出（俗称 “椎间盘滑脱”）的痛苦经历。他认为，对于程序员来说，最重要的习惯并不是提高代码的可读性、一致性或组织性，而是保持健康的身体以便能长期从事这项工作。他建议大家每天进行拉伸运动，定时休息，避免深夜编程，并改善工作环境，比如使用站立式办公桌等。他希望大家能从他的错误中吸取教训，享受健康编程的乐趣。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[好的代码就像一封情书，写给下一个维护它的开发人员。]]></title>
        <id>https://addyosmani.com/blog/good-code/</id>
        <link href="https://addyosmani.com/blog/good-code/"/>
        <updated>2023-07-24T01:53:22.928Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/good-code/">Good code is like a love letter to the next developer who will maintain it.</a></p><p><strong>概要：</strong></p><p>这篇文章将编程比作写情书，强调了编码的实质是沟通。好的代码就像一封爱情信件，是开发者之间的亲密对话。好的代码个性化、真诚、无需多余复杂性，且考虑到下一个维护它的开发者。我们有设计模式和原则来塑造我们的代码，使其可扩展、可维护、高效，同时也易读和易懂。好的代码会巧妙地利用这些模式，就像熟练的诗人使用诗歌设备来创造共鸣。SOLID, DRY, KISS 和 YAGNI 不仅仅是原则，而是编写好代码的基石。好的代码还遵循既定的最佳实践，如适当的命名规范、模块化和详尽的注释。同样重要的是进行严格的测试和采用测试驱动开发（TDD）的做法。最后，编写他人能阅读、理解和维护的代码，是对专业尊重的体现。因此，好的代码不仅是一封情书，更是我们留给后来者的持久遗产。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有效的代码审查]]></title>
        <id>https://addyosmani.com/blog/code-reviews/</id>
        <link href="https://addyosmani.com/blog/code-reviews/"/>
        <updated>2023-07-24T01:52:59.652Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/code-reviews/">Effective Code Reviews</a></p><p><strong>概要：</strong></p><p>这篇文章主要讲述了进行有效代码审查的指导方针。对于代码作者，应尊重审查者的时间，首先自我审查代码，分解大的更改列表，自动化简单任务，严格限定代码变更范围，积极回应批评，减少审查轮次之间的延迟，明确询问不清楚的信息，并明确沟通反馈。同时，不要忘记编写文档。对于审查者来说，应验证代码是否必需且设计良好，是否易读且目标明确，注释是否解释了代码存在的原因而非其功能，代码是否过于复杂，是否遵循团队的样式指南，以及是否经过充分测试和文档记录。此外，审查评论应专注于代码本身，避免贬低或模糊的评论，而是提供明确、具体且适当的正面反馈。审查过程中需要考虑多个标准，如代码是否满足需求，逻辑是否正确，是否安全等。总的来说，代码审查应尊重、建设性且有针对性，作者和审查者都在维护代码质量和保证其长期可维护性上发挥关键作用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - vantezzen/auto-form：基于 zod 模式自动创建 @shadcn/ui 表单的 React 组件。]]></title>
        <id>https://github.com/vantezzen/auto-form</id>
        <link href="https://github.com/vantezzen/auto-form"/>
        <updated>2023-07-24T01:36:39.348Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/vantezzen/auto-form">GitHub - vantezzen/auto-form: 🌟  A React component that automatically creates a @shadcn/ui form based on a zod schema.</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 AutoForm 的 React 组件，它能根据 zod 模式自动创建一个 @shadcn/ui 表单。安装该组件需要依赖于 shadcn/ui 的多个组件，如：折叠面板、按钮、日历、卡片、复选框、表单、输入框、标签、弹出窗、单选组、选择器、分隔符、开关、文本区和切换等。目前支持的字段类型有：布尔值（复选框、开关）、日期（日期选择器）、枚举（选择器、单选组）、数字（输入框）和字符串（输入框、文本字段）。使用时只能在客户端的 React 组件中使用，如果在 Next.js 应用中使用，需要将组件标记为 "使用客户端"。你可以通过 describe 方法为每个字段设置标签和描述，如果没有设置标签，将使用字段名称并取消驼峰命名。所有字段默认都是必填的，可以通过 optional 方法将字段设置为可选。你还可以通过 default 方法为字段设置默认值。你可以使用 inputProps 属性将 props 传递给输入组件。你可以使用 description 属性在字段下方添加描述。你可以使用 renderParent 属性自定义输入的父元素。有两种方式可以访问表单数据：onSubmit 和 Controlled form。你可以使用 AutoFormSubmit 组件创建提交按钮。所有传递给 AutoForm 组件的子元素都将在表单下方渲染。最后，该组件的许可证为 MIT。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Turborepo 如何从 Go 移植到 Rust - Vercel]]></title>
        <id>https://vercel.com/blog/how-turborepo-is-porting-from-go-to-rust</id>
        <link href="https://vercel.com/blog/how-turborepo-is-porting-from-go-to-rust"/>
        <updated>2023-07-24T01:33:07.553Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/how-turborepo-is-porting-from-go-to-rust">How Turborepo is porting from Go to Rust – Vercel</a></p><p><strong>概要：</strong></p><p>文章讲述了为何以及如何将 Turborepo，一个高性能的 JavaScript 和 TypeScript 构建系统，从 Go 语言迁移到 Rust 语言。首先，他们确定了迁移是可行的，并开始了这个过程。在迁移策略上，他们选择了逐步迁移而非全面重写，因为全面重写会带来一些问题，例如需要暂停新功能的开发，可能导致用户体验下降等。逐步迁移则可以保持原有代码的行为不变，同时进行 Go 和 Rust 代码的互操作。他们首先用 Rust 编写了一个小的新功能，然后逐渐将更多的代码迁移到 Rust。在这个过程中，他们遇到了一些挑战，例如在不同的操作系统和 Linux 版本上测试代码时出现的问题，但最终都得到了解决。通过这次迁移，他们认识到序列化对于互操作性非常有用，逐步迁移需要充分的准备和测试，跨平台、跨语言的发布工程非常具有挑战性，但对他们来说，从 Go 迁移到 Rust 是值得的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 React 中使用 svg 精灵图标]]></title>
        <id>https://www.jacobparis.com/content/svg-icons</id>
        <link href="https://www.jacobparis.com/content/svg-icons"/>
        <updated>2023-07-24T01:32:02.963Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.jacobparis.com/content/svg-icons">Use svg sprite icons in React</a></p><p><strong>概要：</strong></p><p>文章介绍了在 React 应用中使用 svg 图标的方法。最直观但效率最低的方式是将 svg 代码直接写入组件作为 JSX，这会增加包的大小。最好的方式是使用 svg spritesheet，它是一种包含许多精灵（本例中的图标）的单个图像。我们可以通过加载一个大图像并通过代码只显示需要的部分来优化图像加载。网站可以使用同样的策略将许多图标存储在一个 svg 文件中，称为 svg spritesheet。每个图标精灵都存储为 svg 文件内的 <symbol> 元素，我们可以通过使用 < use > 元素并引用图标的 id 来显示特定的图标。文章详细介绍了如何构建一个脚本，将一个文件夹的 svg 图标编译成一个单独的 svg spritesheet，以及如何构建一个 React 组件，通过名称显示特定的图标，并为可用的图标提供完全类型安全的自动完成功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[制作开发人员想要的东西]]></title>
        <id>https://leerob.io/blog/make-something-developers-want</id>
        <link href="https://leerob.io/blog/make-something-developers-want"/>
        <updated>2023-07-21T06:39:33.921Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://leerob.io/blog/make-something-developers-want">Make Something Developers Want</a></p><p><strong>概要：</strong></p><p>Y Combinator 以他们的建议而闻名：制造人们想要的东西。然而，当这些客户是开发者时，我会认为执行这个建议的方式看起来有所不同，可能与人们通常想要的相反。以下是你应该做的，以制造开发者想要的东西：你应该接受开源；你应该有一个免费的层级；你应该有优秀的文档；你应该能够得到开发者的支持；你应该是一个社区的一部分。1. 你应该接受开源，因为经验丰富的开发者喜欢开源产品，新手开发者也喜欢开源产品，因为他们正在学习帮助他们在职业生涯中提升的技能。2. 你应该有一个免费的层级，开发者不想和你的销售团队交谈，他们想尽可能少的摩擦地试用产品。3. 你应该有优秀的文档，文档越好，开发者就越可能尝试你的产品。4. 你应该能够得到开发者的支持，当开发者在你的文档中找不到答案时，他们会寻求支持。5. 你应该成为一个社区的一部分，开发者去哪里玩？在线和线下社区。你需要在那里提供价值。这是一个长期的游戏，有时需要花费几年时间才能实现价值，但事后看来是显而易见的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SvelteJS：我的生态系统比你的大 - HackMD]]></title>
        <id>https://hackmd.io/@roguegpu/r1RKQMdt3</id>
        <link href="https://hackmd.io/@roguegpu/r1RKQMdt3"/>
        <updated>2023-07-21T01:52:32.582Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://hackmd.io/@roguegpu/r1RKQMdt3">SvelteJS: My ecosystem is bigger than yours  - HackMD</a></p><p><strong>概要：</strong></p><p>文章主要讨论了 Svelte 和 React 之间的差异，以及为何使用 Svelte 可能是更好的选择。作者指出，尽管 Svelte 的生态系统相比 React 较小，但这并不意味着它的功能有所欠缺。事实上，Svelte 的一些特性，如内置的状态管理 API 和转换 API，使得开发者无需寻找额外的库就能解决问题。此外，Svelte 还允许直接在框架中进行样式设置，而无需引入其他库。作者还展示了如何在 Svelte 中使用 ag-grid 和 chart.js 等库，并指出与 React 相比，Svelte 可以更直接地使用这些库，而无需通过封装器。最后，作者总结道，虽然使用 React 可能需要学习更多的封装器，但使用 Svelte 则可以更直接地学习和使用底层库。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Persson Dennis - 为何选择服务器组件 - 网络简史]]></title>
        <id>https://www.perssondennis.com/articles/why-server-components-a-brief-history-of-web</id>
        <link href="https://www.perssondennis.com/articles/why-server-components-a-brief-history-of-web"/>
        <updated>2023-07-21T01:37:12.848Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.perssondennis.com/articles/why-server-components-a-brief-history-of-web">Persson Dennis - Why Server Components - A Brief History of Web</a></p><p><strong>概要：</strong></p><p>根据 Stack Overflow 2023 年的调查，Next.js 现在是开发人员最想要的 web 框架中的第三名，也是最受欢迎的第六名。尽管他们的旧版 Pages Router 非常出色，但他们在框架的第 13 版中引入了新的 App Router。随着这个变化，他们还迁移到使用 Server Components，这可以被视为下一级别的服务器渲染。本文将从网络的起源开始，通过各种类型的服务器渲染及其所有优点，到最新的 Next.js Server Components 的网络开发状态，来帮助你理解为什么 Next.js 和 Server Components 不仅仅是传统的客户端 React 应用程序。文章中还详细讨论了服务器渲染与 SPA 的转变，以及客户端组件与服务器组件的对比等内容。总的来说，Next.js 现在允许为每个组件决定是否应该在服务器上预渲染，或者是否需要在客户端上渲染。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于最大化 Rust 代码的性能 | Jonathan Becker]]></title>
        <id>https://jbecker.dev/research/on-writing-performant-rust</id>
        <link href="https://jbecker.dev/research/on-writing-performant-rust"/>
        <updated>2023-07-21T01:31:31.958Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jbecker.dev/research/on-writing-performant-rust">On Maximizing Your Rust Code's Performance | Jonathan Becker</a></p><p><strong>概要：</strong></p><p>文章内容为空，无法进行总结。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JPEG XL 的崛起：苹果公司的支持和图像压缩见解]]></title>
        <id>https://cloudinary.com/blog/jpeg-xl-how-it-started-how-its-going</id>
        <link href="https://cloudinary.com/blog/jpeg-xl-how-it-started-how-its-going"/>
        <updated>2023-07-21T01:26:45.140Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://cloudinary.com/blog/jpeg-xl-how-it-started-how-its-going">Rise of JPEG XL: Apple's Support and Image Compression Insights</a></p><p><strong>概要：</strong></p><p>在上个月的全球开发者大会上，苹果宣布支持 JPEG XL。JPEG XL 是 2018 年 JPEG 委员会启动的下一代图像压缩提案中的一个，由 Google 的 PIK 和 Cloudinary 的 FUIF 提案合并而成。到 2020 年底，主要技术工作完成，比特流冻结，即不再做任何会改变解码器视角的格式更改。然后，在 2023 年 6 月 5 日，苹果的年度全球开发者大会 (WWDC23) 上，Safari 浏览器的新功能列表中出现了 “JPEG XL”。Safari 17 不仅将添加 JPEG XL 支持，新版本的 iOS、iPadOS、macOS、watchOS 和 visionOS 也将支持 JPEG XL。这对 JPEG XL 的采用无疑是好消息。图像压缩是我们在 Cloudinary 的重要工作，我们需要深入理解何时使用哪种编码器，或者说，使用哪种编码器和设置。因此，我们做了一个大实验，创建了 Cloudinary Image Dataset (CID22)，一个大型的人工注释压缩图像数据集。这有助于我们更好地理解压缩对感知质量的影响。目前，JPEG XL 是平均压缩性能最好的编码器，但各种图像的表现存在很大的差异。因此，我们正在研究一个 AI 驱动的新版本的 f_auto,q_auto 特性，可以自动选择最优的格式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 Next13 中使用服务器组件的 5 个常见陷阱（附示例）]]></title>
        <id>https://www.propelauth.com/post/5-common-pitfalls-with-server-components-in-next13-with-examples</id>
        <link href="https://www.propelauth.com/post/5-common-pitfalls-with-server-components-in-next13-with-examples"/>
        <updated>2023-07-21T01:18:56.684Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.propelauth.com/post/5-common-pitfalls-with-server-components-in-next13-with-examples">5 Common Pitfalls with Server Components in Next13 (with examples)</a></p><p><strong>概要：</strong></p><p>NextJS 13 引入了一个新特性 ——App Router，现已成为创建新的 NextJS 应用时推荐的选项，这有效地取代了 Pages Router。App Router 最显著的不同之处在于，默认情况下所有组件都是服务器组件，而非客户端组件。服务器组件与客户端组件有几个重大的差异，可能会引起混淆。本文主要解析了以下几个常见问题：1. 在服务器组件中使用 React Hooks；2. 在服务器组件中使用事件处理器（如 onClick）；3. 直接将服务器组件导入到客户端组件中；4. 假设服务器组件会重新渲染；5. 在服务器组件中设置 cookies；6. 尝试从服务器传递非序列化属性到客户端。对于每个问题，文章都提供了修复方法和替代方案。总的来说，虽然服务器组件是 Next13 的强大功能，但也需要注意一些潜在问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么 Zustand Typescript 的实现如此丑陋？]]></title>
        <id>https://blog.axlight.com/posts/why-zustand-typescript-implementation-is-so-ugly/</id>
        <link href="https://blog.axlight.com/posts/why-zustand-typescript-implementation-is-so-ugly/"/>
        <updated>2023-07-21T01:18:06.716Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.axlight.com/posts/why-zustand-typescript-implementation-is-so-ugly/">Why Zustand Typescript Implementation Is So Ugly</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了 Zustand 库在 TypeScript 中的实现。虽然 Zustand 的 JavaScript 实现非常简洁，但其在 TypeScript 中的实现却相当复杂。文章分析了其中一个原因 ——SetStateInternal 类型。这种类型使用了 TypeScript 的一种技巧，如果不使用这种技巧，会导致某些情况下无法正常工作。文章强调，作为库的使用者，无需知道这背后的原理，这是 TypeScript 专家应该处理的问题。文章还提到，Zustand 在 TypeScript 中的实现复杂性还有其他原因，可能会在未来的文章中进行探讨。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用 NextJS 13 应用路由器解密 React 服务器组件]]></title>
        <id>https://demystifying-rsc.vercel.app/</id>
        <link href="https://demystifying-rsc.vercel.app/"/>
        <updated>2023-07-21T01:17:39.270Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://demystifying-rsc.vercel.app/">Demystifying React Server Components with NextJS 13 App Router</a></p><p><strong>概要：</strong></p><p>这个应用程序的目的是以一种揭示真实情况的方式展示 NextJS13 中 React Server 组件的概念和代码。目标受众是有经验的 React 开发者，可能对 RSC 不熟悉，或者正在使用 RSC 并希望更深入理解其工作原理。这个教程可以在 GitHub 上克隆。本教程旨在线性步骤中进行，但你可以跳到下面的任何页面。重要内容包括静态内容、虚拟 DOM、整合客户端组件、水合失败、禁用客户端组件的 SSR、禁用服务器端的组件 SSR、客户端组件详情、服务器组件作为客户端组件的子代、将服务器组件导入到客户端组件、异步服务器组件、服务器端暂停流、动态更新服务器渲染内容、RSC 缓存、服务器功能？、RSC 常见问题、App 路由器演示等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 TypeChat - TypeChat]]></title>
        <id>https://microsoft.github.io/TypeChat/blog/introducing-typechat/</id>
        <link href="https://microsoft.github.io/TypeChat/blog/introducing-typechat/"/>
        <updated>2023-07-21T01:09:00.943Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://microsoft.github.io/TypeChat/blog/introducing-typechat/">Introducing TypeChat - TypeChat</a></p><p><strong>概要：</strong></p><p>2023 年 7 月 20 日，Anders Hejlsberg、Steve Lucco、Daniel Rosenwasser、Pierce Boggan、Umesh Madan、Mike Hopcroft 和 Gayathri Chandrasekaran 发布了一款名为 TypeChat 的实验性库。这个库旨在解决如何将大型语言模型最好地集成到现有的应用界面中，以及如何使用 AI 将用户请求转化为应用可以操作的内容等问题。TypeChat 利用代码库中的类型定义来获取结构化且类型安全的 AI 响应。此外，TypeChat 还能与任何语言模型配合使用。开发者们发现，由于大型语言模型已经看到了许多类型定义，因此类型也可以作为 AI 应该如何响应的指导。TypeChat 是开源的，且设计出来是为了适应各种模型。尽管目前它与 OpenAI API 和 Azure OpenAI 服务有基本的集成，但理论上它应该适用于任何你想使用的聊天补全式 API。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[过去并非真实]]></title>
        <id>https://sive.rs/pnt</id>
        <link href="https://sive.rs/pnt"/>
        <updated>2023-07-20T07:56:20.540Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://sive.rs/pnt">The past is not true</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了作者在 17 岁时，因驾驶不慎撞到了一辆迎面而来的车，导致对方司机的脊柱受伤，无法行走。这件事让他背负了巨大的罪恶感，直到 35 岁时才决定去找这个女人道歉。然而当他找到她并道歉时，发现她并没有因为那次事故而丧失行走能力，反而因此更加注重健康，身体状况比以前更好。原来，他们两人都被告知是自己的错，并为此感到内疚了 18 年。这让作者意识到，过去的记忆和故事并非完全真实，微小的误解可以随着时间的推移被放大，形成误解。历史并非绝对真实，我们可以改变历史，因为真正的事实只占很小的一部分，其余都是解释和理解。所以，改变故事永远不会太晚。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不要指望每天都有动力]]></title>
        <id>https://addyosmani.com/blog/motivation/</id>
        <link href="https://addyosmani.com/blog/motivation/"/>
        <updated>2023-07-20T00:51:20.291Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/motivation/">Don't expect to be motivated everyday</a></p><p><strong>概要：</strong></p><p>这篇文章强调了纪律对于实现目标的重要性，而不是仅仅依赖动力。动力虽然能驱使我们完成伟大的事情，但它并不可靠且短暂。作者建议通过以下三种策略来培养纪律：开始小，比如每天写 100 个单词或完成 5 分钟的锻炼；保持一致，选择一个特定的时间或提示来执行你的习惯，并将其变成日常生活中不可更改的部分；接受失败，理解挫折是过程的自然部分，当你犯错误时，从中学习并继续前进。纪律为创建习惯奠定基础，从而形成例行公事，最终定义我们每天的自我。因此，下次当你缺乏动力时，不要感到绝望，而是依赖你的纪律帮助你度过困难时期并保持对目标的追求。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[是时候升级显示器了]]></title>
        <id>https://tonsky.me/blog/monitors/</id>
        <link href="https://tonsky.me/blog/monitors/"/>
        <updated>2023-07-20T00:48:28.727Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tonsky.me/blog/monitors/">Time to upgrade your monitor</a></p><p><strong>概要：</strong></p><p>这篇文章是作者根据自身经验，讨论了编程人员最佳显示器选择的观点。他认为，对于大多数编程工作，高分辨率和清晰的字体显示至关重要。他建议购买 4K 分辨率的显示器，并使用 2 倍的缩放以获得更好的文本渲染效果。此外，作者还推荐使用 120Hz 的刷新率，尽管这对于文本工作并非必须，但可以提供更流畅的动画和滚动效果，使系统感觉更加响应迅速。不过，他也指出，在 MacOS 上运行 4K 120Hz 显示可能会遇到一些问题，需要进行一些设置调整。总的来说，作者认为独立的高分辨率显示器对于编程工作来说是最佳选择。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[故事书 7.1]]></title>
        <id>https://storybook.js.org/blog/storybook-7-1/</id>
        <link href="https://storybook.js.org/blog/storybook-7-1/"/>
        <updated>2023-07-20T00:45:07.545Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://storybook.js.org/blog/storybook-7-1/">Storybook 7.1</a></p><p><strong>概要：</strong></p><p>Storybook 是 UI 组件开发、文档编写和测试的行业标准工作室，被 Twitter、GitHub、BBC 和纽约时报等团队使用。自今年四月发布 Storybook 7.0 后，我们计划推出更频繁且体积更小的未来版本，以便 Storybook 能够与前端生态系统中的变化保持同步，同时使我们的用户升级过程更加顺畅。今天，我们很高兴为您带来这些版本中的第一个：Storybook 7.1，其中包含了许多改进。此外，Storybook 支持 React、Vue、Angular、Web 组件、Svelte、Webpack 和 Vite 以及超过 400 种集成，使其成为迄今为止最强大的组件工作室。在 Storybook 7.1 中，我们通过为新用户引入入门流程来降低学习曲线。此外，Storybook 7.1 还为 Tailwind、Material UI、Emotion 和 styled-components 等提供了零配置样式支持。我们还为配置文件、ArgTypes 和 Doc 块引入了 API 参考文档，并将 Storybook 的文档制作为 TypeScript 优先，因为 TS 占据了所有 Storybook 项目的 80% 以上。此外，我们还增加了对 Vue 3 源片段和反应性改进的支持，并为文档添加了目录。我们还为 Figma 设计插件提供了官方支持，并进行了数百项修复和改进。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建自己的 FaaS：在 Fly 上自主托管 Cloudflare Worker 和 javascript 函数 | BreakpDev 博客]]></title>
        <id>https://www.breakp.dev/blog/build-your-own-faas/</id>
        <link href="https://www.breakp.dev/blog/build-your-own-faas/"/>
        <updated>2023-07-19T03:25:22.732Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.breakp.dev/blog/build-your-own-faas/">Build your own FaaS: Self-host Cloudflare workers and javascript functions on Fly and everywhere | BreakpDev Blog</a></p><p><strong>概要：</strong></p><p>本文提供了如何构建和自我托管一个完整的 FaaS（Function as a Service）架构的逐步指南。文章首先解释了什么是云计算中的函数以及 FaaS，然后阐述了为什么要自我托管 FaaS。接着，文章详细介绍了如何创建自己的 FaaS，包括设置发布者和工作人员、准备配置、进行干运行和部署等步骤。最后，文章还提供了一些额外的内容，如保护发布者 API、在发布时自动重启工作人员、发布命令行工具等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在网络上使用表情符号]]></title>
        <id>https://fullystacked.net/posts/using-emoji-on-the-web/</id>
        <link href="https://fullystacked.net/posts/using-emoji-on-the-web/"/>
        <updated>2023-07-19T01:29:38.563Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://fullystacked.net/posts/using-emoji-on-the-web/">Using emoji on the web</a></p><p><strong>概要：</strong></p><p>文章讨论了在不同操作系统和浏览器上使用表情符号的问题。大多数浏览器默认使用操作系统提供的表情字体，例如 ChromeOS 和大多数 Android 设备使用 Google 的 Noto Color Emoji，iOS 和 macOS 使用 Apple Color Emoji，Windows 使用 Microsoft Segoe Color Emoji。然而，Firefox 在 Windows 和 Linux 上是个例外，它使用 Twitter 的 Twemoji 字体。在 HTML 标记中使用表情符号通常可以正常工作，但也存在一些问题。例如，一些旧的表情符号可能以单色图标或多色表情符号呈现；Windows 用户（除 Firefox 浏览器外）无法看到国家旗帜的表情符号；老版本操作系统的用户无法获取新的表情符号。解决方案包括显式设置表情字体、使用 CSS 属性 font-variant-emoji、使用 color fonts 等。此外，还可以使用开源的 color emoji 字体，如 Google 的 Noto Color、Adobe 的 Emoji One、Twitter 的 Twemoji、Mozilla 的 FxEmoji 和 Microsoft 的 Fluent Emoji。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动画 SVG 徽标]]></title>
        <id>https://antfu.me/posts/animated-svg-logo</id>
        <link href="https://antfu.me/posts/animated-svg-logo"/>
        <updated>2023-07-19T01:21:42.778Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/animated-svg-logo">Animated SVG Logo</a></p><p><strong>概要：</strong></p><p>文章作者 Anthony Fu 分享了他如何将网站左上角的 Logo 替换为动态 SVG。首次看到这种 SVG 描边动画是在 Vjacheslav Trushkin 的 Material Line Icons 中，但直到在 Mu-An Chiou 的网站上看到类似的设计，才萌生了自己也要做一个的想法。通过研究 Mu-An 的 SVG 代码和参考 Material Line Icons，作者发现他们是通过动画化 stroke-dasharray 来实现这种效果的。原始 Logo 是 8 年前作者用 Surface Pro 4 上的压感笔绘制的，之后用 Adobe Illustrator 进行图像追踪得到 SVG 版本。作者需要用单个描边重新绘制 Logo，然后手动添加样式到导出的 SVG 中，从而得到一个不错的动态 Logo。唯一的缺点是描边在所有地方都均匀粗细，使其看起来不太像签名。作者试图寻找解决方案，最后发现 SVG 支持遮罩功能，于是尝试让描边在遮罩内部动画，并取得了成功。虽然这种方法并非完美，因为无法控制描边宽度，所以描边会稍微偏离遮罩，但作者认为这已经很好了。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fresh 1.3 - 简化的路由组件及其他]]></title>
        <id>https://deno.com/blog/fresh-1.3</id>
        <link href="https://deno.com/blog/fresh-1.3"/>
        <updated>2023-07-19T00:44:37.401Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/fresh-1.3">Fresh 1.3 – Simplified Route Components and More</a></p><p><strong>概要：</strong></p><p>自从我们发布 Fresh 1.2 后仅过去一个月，我们已经回来发布另一个版本！我们计划每个月都发布新的小版本。这个周期包含了社区的许多令人难以置信的 PR，这简直太棒了！文档得到了扩展和改进，修复了许多错误并添加了新功能。感谢所有帮助完成此次发布的人。但话不多说，让我们看看我们对 Fresh 进行了哪些改进。

异步路由组件
从插件中添加路由和 / 或中间件
500 错误模板回退
错误边界
在同一文件中导出多个岛屿
Fresh linting 规则
支持 Deno.serve
更多提高生活质量的改进

异步路由组件我们听到很多反馈，从路由处理程序传递数据到页面的组件需要一些烦人的样板文件。为了确保类型安全，你总是需要为组件的 props 创建一个接口，将其作为通用的传递给 Handlers 类型，并在组件定义中使用它。这真是很多步骤！
由于 GET 处理程序往往与它将呈现的组件高度耦合，显而易见的问题是，为什么我们不直接将两者合并在一起？这正是我们所做的。在 Fresh 1.3 中，我们可以大大简化之前的代码片段：
由于处理程序和组件都在同一个函数中，因此无需声明一个中间接口来在两者之间传递数据；你可以直接传递数据。
但是别担心，没有必要重写所有的路由。实际上，我们并不喜欢重写代码。新的方式只是一个额外的选项，可以使简单的路由更容易编写。使用异步路由并非</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Copilot 7 月 14 日更新]]></title>
        <id>https://github.blog/changelog/2023-07-14-github-copilot-july-14th-update/</id>
        <link href="https://github.blog/changelog/2023-07-14-github-copilot-july-14th-update/"/>
        <updated>2023-07-19T00:26:16.401Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/changelog/2023-07-14-github-copilot-july-14th-update/">GitHub Copilot July 14th Update</a></p><p><strong>概要：</strong></p><p>2023 年 7 月 14 日，GitHub 为其 Visual Studio Code 和 Visual Studio 扩展中的 Chat 功能进行了许多改进，并为管理员提供了新的能力。首先，他们推出了针对 Copilot for Business 的 User Management API（beta），使管理员可以列出所有启用 Copilot 的组织成员及其详细信息，并为个人和团队添加 / 删除访问权限，从而实现大规模的自动化访问管理。此外，他们还在 Visual Studio Code 1.80 中引入了新的创建命令，如 /search, /createWorkspace 等，以帮助用户创建项目和笔记本，并在工作空间中搜索文本。同时，他们还对 Visual Studio 扩展进行了改进，包括更好地支持其他编程语言，保存和恢复聊天历史，清除聊天历史，多行提示框，显示内容的流媒体支持，测试生成的特定插入，以及改善整个聊天体验的各种生活质量更新。最后，他们还引入了基于嵌入的上下文感知操作，如文档，解释和生成测试，这些操作利用现有的内联上下文并制定特定的意图，以提供最佳的任务体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 18 如何提高应用程序性能 - Vercel]]></title>
        <id>https://vercel.com/blog/how-react-18-improves-application-performance</id>
        <link href="https://vercel.com/blog/how-react-18-improves-application-performance"/>
        <updated>2023-07-19T00:24:43.774Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/how-react-18-improves-application-performance">How React 18 Improves Application Performance – Vercel</a></p><p><strong>概要：</strong></p><p>React 18 引入了并发特性，从根本上改变了 React 应用的渲染方式。当我们在浏览器中运行 JavaScript 时，JavaScript 引擎在单线程环境中执行代码，这通常被称为主线程。主线程负责处理其他任务，包括管理用户交互、处理网络事件、定时器、更新动画和管理浏览器重排和重绘。任何运行时间超过 50 毫秒的任务都被视为 "长任务"。React 18 引入了一个新的并发渲染器，它在后台操作。这个渲染器为我们提供了一些方法，使得某些渲染标记为非紧急。此外，这个并发渲染器能够 “并发” 地在后台渲染组件树的多个版本，而不是立即提交结果。React 服务器组件是 React 18 的实验性功能，但已经准备好让框架采用。使用 Suspense，我们可以延迟渲染一个组件，直到满足某些条件，如从远程源加载数据。总的来说，React 18 的最新特性在很多方面提高了性能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023 年的 Npm 状态：概述]]></title>
        <id>https://blog.sandworm.dev/state-of-npm-2023-the-overview</id>
        <link href="https://blog.sandworm.dev/state-of-npm-2023-the-overview"/>
        <updated>2023-07-18T10:52:05.295Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.sandworm.dev/state-of-npm-2023-the-overview">State Of Npm 2023: The Overview</a></p><p><strong>概要：</strong></p><p>这篇文章是 "npm 状态 2023" 系列的一部分。在这个系列中，Sandworm 团队深入探讨了 npm 的当前状况，挖掘出了有趣的统计数据，并揭示了有关注册表的引人入胜的事实。

在软件开发的广阔领域中，一个名字已经成为 JavaScript 生态系统的代名词：npm。作为全球数百万开发者的首选包管理器，npm 在革新我们构建和分享 JavaScript 代码的方式上发挥了关键作用。随着其庞大的注册表不断收纳更多的包，npm 已经成为了一种不可或缺的工具，推动创新并赋予开发者轻松创建出色应用的能力。

在本系列中，Sandworm 团队深入探讨了 npm 的当前状况，挖掘出了有趣的统计数据，并揭示了有关注册表的引人入胜的事实。从包的数量到最受欢迎的库，我们将探索这个为 JavaScript 社区提供动力的强大工具的内部运作。让我们一起来更深入地了解 npm 的状态，并洞察其中的趋势、模式和充满活力的生态系统。

npm 的初始提交是由 Isaac Z. Schlueter（isaacs）在 2009 年 9 月 29 日推送的。它最初是一个在 VPS 上的单一 CouchDB 服务。"npm" 原本代表 "Node Package Manager"，但后来被改为递归的反向首字母缩写，意思是 "npm 不是首字母缩写"。npm 在 2014 年作为一家公司成立，当时它筹集了 260 万美元以持续资助其迅速增长的社</p>]]></content>
    </entry>
</feed>