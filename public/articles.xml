<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-05-19T01:06:17.832Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[Nuxt 3.5 - Nuxt]]></title>
        <id>https://nuxt.com/blog/v3-5</id>
        <link href="https://nuxt.com/blog/v3-5"/>
        <updated>2023-05-19T01:04:44.665Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nuxt.com/blog/v3-5">Nuxt 3.5 · Nuxt</a></p><p><strong>概要：</strong></p><p>Nuxt 3.5.0 发布了，带来了许多令人兴奋的功能，特别是在类型支持方面。此外还有 Nitropack v2.4 和丰富的 JSON 负载等更新。Nuxt 3.5.0 还支持交互式服务器组件、环境配置、完全类型化页面和 “捆绑器” 模块解析等功能。除此之外，该版本还修复了一些错误和问题。建议升级到最新版本，并阅读完整的发行说明和变更日志。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 TypeScript 5.1 RC - TypeScript]]></title>
        <id>https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-rc/</id>
        <link href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-rc/"/>
        <updated>2023-05-19T00:31:59.629Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-rc/">Announcing TypeScript 5.1 RC - TypeScript</a></p><p><strong>概要：</strong></p><p>TypeScript 5.1 has been released as a Release Candidate, with no further changes expected before the stable release apart from critical bug fixes. The new version includes easier implicit returns for undefined-returning functions, unrelated types for getters and setters, decoupled type-checking between JSX elements and JSX tag types, namespaced JSX attributes, and more. TypeScript 5.1 also supports linked cursors for JSX tags, snippet completions for @param JSDoc tags, and optimizations such as avoiding unnecessary type instantiation and negative case checks for union literals. However, there are also breaking changes, such as ES2020 and Node.js 14.17 being minimum runtime requirements, and explicit typeRoots disabling upward walks for node_modules/@types. The TypeScript team is already working on TypeScript 5.2, with a public iteration plan available.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在科技会议上从参会者到演讲者的9个技巧 | GitHub博客]]></title>
        <id>https://github.blog/2023-05-18-9-tips-to-go-from-attendee-to-speaker-at-a-tech-conference/</id>
        <link href="https://github.blog/2023-05-18-9-tips-to-go-from-attendee-to-speaker-at-a-tech-conference/"/>
        <updated>2023-05-19T00:30:35.220Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/2023-05-18-9-tips-to-go-from-attendee-to-speaker-at-a-tech-conference/">9 tips to go from attendee to speaker at a tech conference | The GitHub Blog</a></p><p><strong>概要：</strong></p><p>GitHub Universe 是一年一度的全球开发者和客户活动，今年将于 11 月 8 日至 9 日在线上和线下举行。文章提供了一些撰写成功演讲提案的技巧，例如标题要吸引人、具体说明内容的收获、突出会议性质等。此外，还提供了演讲者个人介绍的公式和其他有用资源，如往年活动的回顾、联系前任演讲者、关注行业热点等。最后，文章呼吁有兴趣参加演讲的人提交他们的想法，并列出了被选中的好处。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - DukeLuo/eslint-plugin-check-file：ESLint规则的一致的文件名和文件夹。允许你为文件名和文件夹强制执行一致的命名模式。]]></title>
        <id>https://github.com/DukeLuo/eslint-plugin-check-file</id>
        <link href="https://github.com/DukeLuo/eslint-plugin-check-file"/>
        <updated>2023-05-19T00:27:28.162Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/DukeLuo/eslint-plugin-check-file">GitHub - DukeLuo/eslint-plugin-check-file: ESLint rules for consistent filename and folder. Allows you to enforce a consistent naming pattern for the filename and folder.</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 eslint-plugin-check-file 的 ESLint 插件，该插件可以帮助开发者强制规范化文件和文件夹的命名方式。插件支持多种规则，例如强制指定文件夹名称、文件名命名规范等。开发者只需要在.eslintrc 配置文件中添加相应的规则即可使用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么我们选择Astro而不是Nuxt]]></title>
        <id>https://www.blackspike.com/blog/why-we-chose-astro-over-nuxt/</id>
        <link href="https://www.blackspike.com/blog/why-we-chose-astro-over-nuxt/"/>
        <updated>2023-05-19T00:26:56.550Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.blackspike.com/blog/why-we-chose-astro-over-nuxt/">Why we chose Astro over Nuxt</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个网站建设过程中的问题：由于使用了 Three.js 等大量 JavaScript 库，导致页面加载缓慢和卡顿。为了解决这个问题，作者尝试了 Astro 框架，它可以将 JavaScript 编译成 HTML 和 CSS，从而减少页面的 JavaScript 代码量。作者发现，对于博客和静态营销网站等项目，Astro 是一个很好的选择。但对于有交互部分的网站，如头条 Shopify 网站或单页应用程序，则更适合使用 Nuxt 框架。文章最后总结了两种框架的优缺点。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[揭开魔法的面纱：探索各种框架的反应性]]></title>
        <id>https://www.builder.io/blog/reactivity-across-frameworks</id>
        <link href="https://www.builder.io/blog/reactivity-across-frameworks"/>
        <updated>2023-05-19T00:26:15.754Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/reactivity-across-frameworks">Unveiling the Magic: Exploring Reactivity Across Various Frameworks</a></p><p><strong>概要：</strong></p><p>本文深入探讨了各种前端框架中的响应性（reactivity）机制，着重比较了粗粒度和细粒度响应性之间的差异。React 和 Angular 属于粗粒度系统，需要重新执行组件树来检测更改并更新 DOM；Svelte、Vue、Qwik 和 Solid 属于细粒度系统，可以更加高效地检测和更新 DOM。Qwik 是唯一一个不需要预热的框架，它通过 SSR/SSG 将状态与 DOM 相关联，并在客户端恢复这些信息，从而避免了下载大量应用代码的问题。作者认为，虽然粗粒度系统 “随便用” 会更方便，但是使用细粒度系统可能会更高效，因为后者已经进行了优化。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍一下Legend-State 1.0：更快地构建更快的应用程序]]></title>
        <id>https://legendapp.com/open-source/legend-state-v1/</id>
        <link href="https://legendapp.com/open-source/legend-state-v1/"/>
        <updated>2023-05-19T00:25:43.116Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://legendapp.com/open-source/legend-state-v1/">Introducing Legend-State 1.0: Build faster apps faster</a></p><p><strong>概要：</strong></p><p>文章介绍了一个名为 Legend-State 的 React 状态库，它具有极快的速度、易用性、自然的细粒度反应和内置持久性等四个主要优点。该库基于可观察对象实现，使用 Proxy 跟踪对象中的路径，从而在速度和内存使用方面超越其他 React 状态库。使用该库不需要繁琐的模板代码和上下文、动作、规约、分派器等，只需调用 get () 获取原始数据并使用 set () 更改数据即可。此外，该库还支持细粒度反应，使得组件能够在特定值更改时更新，从而减少重新渲染的次数。最后，该库还内置了持久化功能，可以保存和同步应用程序状态。未来，该库将添加更多的持久化插件和辅助可观察对象和钩子函数。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[管理GitHub通知 - GitHub维护者峰会2023]]></title>
        <id>https://antfu.me/posts/manage-github-notifcations-2023</id>
        <link href="https://antfu.me/posts/manage-github-notifcations-2023"/>
        <updated>2023-05-17T15:43:54.393Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/manage-github-notifcations-2023">Manage GitHub Notifications - GitHub Maintainer Summit 2023</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一种名为 “Notification-driven Developement” 的方法来管理 GitHub 上的项目。该作者通过使用 GitHub 的通知系统来管理他所维护的各种规模的项目，以保持项目的活跃度和稳定性。他提出了 “Inbox-Zero” 概念，即每天处理完所有收到的通知，以便快速响应社区成员并控制维护工作量。文章还分享了一些减少通知数量和组织通知的技巧，并介绍了一个用户脚本来自动化通知处理。最后，作者强调了享受工作和保持良好的工作与生活平衡的重要性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[馒头捆绑器]]></title>
        <id>https://bun.sh/blog/bun-bundler</id>
        <link href="https://bun.sh/blog/bun-bundler"/>
        <updated>2023-05-17T04:41:23.198Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bun.sh/blog/bun-bundler">The Bun Bundler</a></p><p><strong>概要：</strong></p><p>Bun bundler 是一个快速的本地打包工具，现在已经进入了 beta 测试阶段。它可以通过 bun build CLI 命令或新的 Bun.build () JavaScript API 来使用。该工具可以用于构建前端应用程序，并提供了内置的 Bun.build () 函数和 bun build CLI 命令。文章指出，JavaScript 生态系统的复杂性不断增加，如何运行 TypeScript 文件、如何为生产环境构建 / 打包代码等问题使得开发变得越来越复杂。Bun bundler 的目标是将打包引入 JavaScript 运行时，从而使前端和全栈代码的发布更简单、更快速。该工具的优点包括：插件执行快速、生成预转换文件以提高运行性能、统一的插件 API、构建输出数组、支持 ESM 模块系统、支持 tree-shaking、支持源码映射、支持 JS 压缩器等。未来，Bun bundler 还将与 Bun 的 HTTP 服务器 API（Bun.serve）集成，从而实现用简单的声明式 API 代替</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[充满惊喜的JavaScript生态圈]]></title>
        <id>https://fly.io/blog/js-ecosystem-delightfully-wierd/</id>
        <link href="https://fly.io/blog/js-ecosystem-delightfully-wierd/"/>
        <updated>2023-05-16T01:46:08.086Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://fly.io/blog/js-ecosystem-delightfully-wierd/">The JavaScript Ecosystem is Delightfully Weird</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了 JavaScript 生态系统的奇怪之处。作者认为，JavaScript 在不到 10 年前非常糟糕，缺乏许多现代语言特性，而且主要运行在浏览器的 DOM 中，很难处理。然而，随着时间的推移，JavaScript 的发展迅速改善，出现了许多编译器和转换工具，如 CoffeeScript、Babel 和 esbuild，使得开发人员可以使用更加现代化的语言特性来编写 JavaScript 代码。同时，JavaScript 生态系统也变得越来越庞大，涵盖了许多框架和库，但是这些框架和库并没有完全遵循 ECMAScript 标准，而是进行了一些自己的扩展和修改，例如 TypeScript 和 JSX。最近，React Server Components (RSC) 出现了，它通过与打包工具的合作，实现了将 React 组件编译成 HTML 或 JSON 流的功能，从而引发了人们对于 JavaScript 语言本身的重新思考。总</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用Qt和Rust构建一个桌面应用程序 - LogRocket博客]]></title>
        <id>https://blog.logrocket.com/build-desktop-app-qt-rust/</id>
        <link href="https://blog.logrocket.com/build-desktop-app-qt-rust/"/>
        <updated>2023-05-15T07:17:16.737Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.logrocket.com/build-desktop-app-qt-rust/">Build a desktop app with Qt and Rust - LogRocket Blog</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 Rust 和 Qt 框架构建桌面应用程序。作者首先讨论了桌面应用程序的优点，然后介绍了 Rust 在桌面应用程序开发中的流行程度和可靠性。接着，作者演示了如何使用 Qt 和 Rust 构建一个简单的 “Hello World” 应用程序，并逐步添加了加密和解密功能。最后，作者还介绍了如何使用 GitHub CI 工作流程来确保代码正确性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[将Next.js App Router用于生产的5条经验之谈]]></title>
        <id>https://www.inngest.com/blog/5-lessons-learned-from-taking-next-js-app-router-to-production</id>
        <link href="https://www.inngest.com/blog/5-lessons-learned-from-taking-next-js-app-router-to-production"/>
        <updated>2023-05-15T04:52:42.154Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.inngest.com/blog/5-lessons-learned-from-taking-next-js-app-router-to-production">5 Lessons Learned From Taking Next.js App Router to Production</a></p><p><strong>概要：</strong></p><p>Next.js 13 的新功能 App Router 引入了 Nested Layouts、Server Components 和 Streaming 等多项新特性，是第一个开源实现 React 18 原语的工具。从 Next.js 13.4 开始，App Router 已被认为是生产就绪状态。使用 App Router 可以更轻松地在路由之间共享 UI、更好地利用服务器组件、更快地展示页面部分内容以及准备未来。但是，在应用 App Router 时需要注意两个缓存、URL 搜索参数在布局服务器组件中的问题、文件结构的优点以及学习新技术和资源有限的挑战。建议先仔细阅读官方文档，如果遇到问题可以查看 GitHub 和 Twitter 上的讨论，并且分享经验和解决方案有助于建立更加实质性的知识库。总体而言，采用 App Router 可以提高用户和开发者的体验，但需要耐心和深入挖掘。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解useRef和useState用于跟踪React中的组件渲染次数]]></title>
        <id>https://peterkellner.net//2023/05/05/Understanding-useRef-and-useState-for-Tracking-Component-Render-Count-in-React/</id>
        <link href="https://peterkellner.net//2023/05/05/Understanding-useRef-and-useState-for-Tracking-Component-Render-Count-in-React/"/>
        <updated>2023-05-15T04:52:16.782Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://peterkellner.net//2023/05/05/Understanding-useRef-and-useState-for-Tracking-Component-Render-Count-in-React/">Understanding useRef and useState for Tracking Component Render Count in React</a></p><p><strong>概要：</strong></p><p>本文介绍了在 React 中使用 useRef 和 useState 来追踪组件渲染次数的实际例子。通过自定义一个名为 useComponentRenderCount 的 hook，使用 useRef 来存储渲染次数，并使用 useState 来管理组件内的不同状态值。通过将状态值分开控制，可以提高代码可读性并更轻松地管理每个值的状态更新。理解何时使用 useRef 以及如何与 useState 一起使用对于管理复杂的组件行为至关重要。在开发 React 应用程序时，需要平衡性能和功能，才能创建高质量的应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反应全局状态为局部状态]]></title>
        <id>https://webup.org/blog/react-global-state-as-local-state/</id>
        <link href="https://webup.org/blog/react-global-state-as-local-state/"/>
        <updated>2023-05-15T04:51:55.382Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://webup.org/blog/react-global-state-as-local-state/">React Global State as Local State</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一种基于 React 的全局状态管理方案，使用 useGlobalState 钩子来读取全局存储对象，并在其更新时强制所有已订阅的组件重新渲染。相比于 Redux 和 Context，这种方案更加简单且没有繁琐的代码。该方案不需要依赖库，支持测试和 TypeScript。文章详细介绍了如何实现这个钩子，包括 JavaScript 和 TypeScript 的实现以及测试用例。作者表示这种方案虽然简单，但也具有可扩展性，可以在其上构建中间件、错误处理和动作等功能。作者在几个项目中尝试了 createGlobalState，目前已成为他的默认选择。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[罗马 v12.1.0]]></title>
        <id>https://rome.tools/blog/2023/05/10/rome12_1/</id>
        <link href="https://rome.tools/blog/2023/05/10/rome12_1/"/>
        <updated>2023-05-15T02:08:46.595Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://rome.tools/blog/2023/05/10/rome12_1/">Rome v12.1.0</a></p><p><strong>概要：</strong></p><p>Rome v12.1.0 发布了，支持新的 Stage 3 装饰器、VCS 集成和新的 lint 规则。现在，Rome 可以解析和格式化大多数框架中的装饰器，并且支持 git VCS 集成。此外，还添加了许多新的 lint 规则，并提供了一个新的命令来更新配置文件。还有一个新的 CLI 帮助提示库，可以从源代码生成输出。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[掌握 TypeScript 中的 infer - JavaScript in Plain English]]></title>
        <id>https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86</id>
        <link href="https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86"/>
        <updated>2023-05-14T16:28:12.103Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86">Mastering infer in TypeScript - JavaScript in Plain English</a></p><p><strong>概要：</strong></p><p>本文介绍了 TypeScript 中 infer 关键字的用法，它可以从现有的代码中提取和推断类型。使用 infer 关键字可以增加代码的类型安全性、效率和组织性。infer 关键字可以在泛型类型、函数参数和返回值、映射类型中使用，但只能在条件类型中使用。同时，文章还提供了一些实际的例子来展示 infer 关键字的使用方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Dart 3 - Dart - Medium]]></title>
        <id>https://medium.com/dartlang/announcing-dart-3-53f065a10635</id>
        <link href="https://medium.com/dartlang/announcing-dart-3-53f065a10635"/>
        <updated>2023-05-14T16:11:21.730Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://medium.com/dartlang/announcing-dart-3-53f065a10635">Announcing Dart 3 - Dart - Medium</a></p><p><strong>概要：</strong></p><p>Google 在 I/O 2023 上宣布了 Dart 3 的发布，这是迄今为止最大的 Dart 版本，包括三个主要进展：100％的声音空安全、记录、模式和类修饰符的重大新语言特性以及通过 Wasm 编译实现对 Web 的本地代码支持。其中，100％空安全意味着 Dart 具有可靠的类型系统，可以避免某些编码错误，如空指针异常，并允许编译器和运行时优化代码。此外，Dart 3 还引入了记录、模式和类修饰符等新功能，使 Dart 更加表达和精简，同时提供了一种详细控制大型 API 表面的方法。最后，Dart 3 还提供了未来的预览，即通过 Wasm 编译实现对 Web 的本地代码支持。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Fresh、OpenAI 和 Supabase 构建您自己的 ChatGPT 风格文档搜索。]]></title>
        <id>https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh</id>
        <link href="https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh"/>
        <updated>2023-05-13T07:30:37.930Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh">Build your own ChatGPT-style doc search with Fresh, OpenAI, and Supabase</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 OpenAI Text Completion API 创建自定义的 ChatGPT 风格文档搜索，以及如何在 Supabase 的免费托管 PostgresDB 中存储嵌入和执行向量相似性搜索。文章详细介绍了构建自定义 ChatGPT 的四个步骤，包括预处理知识库、存储嵌入、运行时执行向量相似性搜索和将内容注入到 OpenAI GPT-3 文本完成提示中并将响应流式传输给客户端。此外，文章还提供了一些有关使用 OpenAI 和 ChatGPT 构建的其他资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Deno 在 Rust 中运行 JavaScript]]></title>
        <id>https://austinpoor.com/blog/js-in-rs</id>
        <link href="https://austinpoor.com/blog/js-in-rs"/>
        <updated>2023-05-13T07:28:48.597Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://austinpoor.com/blog/js-in-rs">Running JavaScript in Rust with Deno</a></p><p><strong>概要：</strong></p><p>本文介绍了作者创建的一个名为 “js-in-rs” 的基于 Rust 的 CLI 工具，用于使用 JavaScript 表达式过滤文件。与 grep 工具使用正则表达式不同，js-in-rs 使用 JavaScript 表达式进行过滤。文章详细介绍了 js-in-rs 的工作原理和代码实现，并探讨了在 Rust 应用程序中运行 JavaScript 代码的潜在应用，例如 Web 服务器、数据管道和数据库用户定义函数等。此外，作者还提到 Deno 运行时具有有趣的权限管理方法，允许用户开启或关闭运行时功能，以防止恶意代码访问资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery 3.7.0 发布：保持顺序]]></title>
        <id>https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/</id>
        <link href="https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/"/>
        <updated>2023-05-13T07:28:14.090Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/">jQuery 3.7.0 Released: Staying in Order</a></p><p><strong>概要：</strong></p><p>jQuery 3.7.0 发布了，包含了 bug 修复、新方法和性能提升等内容。此次更新中，jQuery 删除了其长期使用的选择器引擎 Sizzle，并将其代码直接放入了 jQuery 核心中，以便为未来版本的选择做准备。同时，jQuery 增加了一个可链接的.uniqueSort () 方法，解决了某些情况下.prevAll () 方法返回元素顺序相反的问题。jQuery 还添加了对更多 CSS 属性的支持，避免自动添加 “px” 单位。此外，该版本还优化了.manipulation () 方法的性能，修复了在 IE 中焦点事件异步触发的问题。该版本与之前的版本兼容，可以从 jQuery CDN 或 npm 获取。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Vue 3.3 | Vue 点击]]></title>
        <id>https://blog.vuejs.org/posts/vue-3-3</id>
        <link href="https://blog.vuejs.org/posts/vue-3-3"/>
        <updated>2023-05-13T07:13:47.996Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.vuejs.org/posts/vue-3-3">Announcing Vue 3.3 | The Vue Point</a></p><p><strong>概要：</strong></p><p>Vue 3.3 "Rurouni Kenshin" has been released, with a focus on improving developer experience when using Vue with TypeScript. The update includes improvements to SFC <script setup> usage with TypeScript, imported and complex types support in macros, generic components, more ergonomic defineEmits, typed slots with defineSlots, and experimental features such as reactive props destructure and defineModel. Other notable features include defineOptions, better getter support with toRef and toValue, and JSX import source support. Maintenance infrastructure improvements have also been made, allowing for faster builds, tests, and types generation. The Vue team plans to make smaller and more frequent feature releases starting in 2023.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 协调：它是如何工作的，为什么我们应该关心]]></title>
        <id>https://www.developerway.com/posts/reconciliation-in-react</id>
        <link href="https://www.developerway.com/posts/reconciliation-in-react"/>
        <updated>2023-05-13T07:12:20.250Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developerway.com/posts/reconciliation-in-react">React reconciliation: how it works and why should we care</a></p><p><strong>概要：</strong></p><p>本文详细介绍了 React 的协调算法，以及它如何影响我们的日常代码。文章探讨了条件渲染、"key" 属性和为什么不应该在其他组件内声明组件等问题，并提供了解决方法。作者通过分析 React 的虚拟 DOM 和状态更新过程，解释了为什么在条件渲染中声明组件会重新挂载，以及为什么需要使用 "key" 属性来避免组件重复挂载或保证元素的唯一性。最后，作者提供了多个示例来说明这些概念。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Deopt Explorer - TypeScript]]></title>
        <id>https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/</id>
        <link href="https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/"/>
        <updated>2023-05-13T01:41:30.924Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/">Introducing Deopt Explorer - TypeScript</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用内联缓存（inline caching）优化 JavaScript 代码的性能，并讲解了在 TypeScript 编译器中如何使用 Deopt Explorer 工具来分析性能问题和减少多态现象。文章详细介绍了内联缓存的概念、不同类型的缓存以及多态现象的产生原因。通过实例分析，作者展示了如何使用 Deopt Explorer 工具来分析 V8 引擎生成的 ICs 和对象类型，并通过优化 Symbol 类型的属性访问，将编译时间平均缩短了 8-10%。最后，作者介绍了 Deopt Explorer 工具的使用方法和开源地址。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用性能 API 测量页面加载时间]]></title>
        <id>https://www.silvestar.codes/articles/how-to-measure-page-loading-time-with-performance-api/</id>
        <link href="https://www.silvestar.codes/articles/how-to-measure-page-loading-time-with-performance-api/"/>
        <updated>2023-05-11T01:09:04.045Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.silvestar.codes/articles/how-to-measure-page-loading-time-with-performance-api/">How to measure page loading time with Performance API</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 Performance API 来测量网页的加载时间。作者最初从 Tim Kadlec 的博客中发现了一个显示页面加载时间的特性，但是在调整代码时遇到了一些问题。最终，作者通过使用 Performance API 的 performance.mark () 方法来解决了这个问题，并分享了获取页面加载时间的最终代码。此外，作者还提供了一个名为 page-loaded-in 的 NPM 包来帮助读者快速实现该特性。文章强调了在开发基于 Web 的项目时优化性能的重要性，并提供了使用 Performance API 来衡量页面性能的方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的混音之路]]></title>
        <id>https://redd.one/blog/my-struggle-with-remix</id>
        <link href="https://redd.one/blog/my-struggle-with-remix"/>
        <updated>2023-05-11T01:08:33.697Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://redd.one/blog/my-struggle-with-remix">My Struggle With Remix</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了作者使用 Remix 框架的经验和遇到的问题。作者认为 Remix 是一个很好的框架，但是也存在一些缺点。作者提出了四个主要问题：开发体验、路由过于神秘、仍然不够成熟以及控制不是默认的。作者指出，Remix 在某些方面缺乏对开发者的控制权，例如构建过程和静态资源处理。此外，Remix 的路由语法可能会使人感到困惑，并且更新时可能会出现问题。尽管存在这些问题，作者仍然认为 Remix 是一个优秀的框架，特别适用于数据密集型应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[滑动进入动画]]></title>
        <id>https://antfu.me/posts/sliding-enter-animation</id>
        <link href="https://antfu.me/posts/sliding-enter-animation"/>
        <updated>2023-05-11T01:07:22.715Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/sliding-enter-animation">Sliding Enter Animation</a></p><p><strong>概要：</strong></p><p>本文介绍了一种通过 CSS 动画实现页面元素滑动进入的效果，并提供了一个示例代码。作者在文章中还尝试了使用 CSS 计数器来简化应用到 Markdown 页面内容的过程，但由于计数器函数返回字符串而无法直接转换为数字，因此最终采用了 nth-child () 选择器来手动实现该效果。最后，作者将该效果应用到了自己的博客页面中，并分享了源代码。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - dai-shi/will-this-react-global-state-work-in-concurrent-rendering: 在 React 并发渲染中测试撕裂和分支。]]></title>
        <id>https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-rendering</id>
        <link href="https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-rendering"/>
        <updated>2023-05-10T01:49:33.357Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-rendering">GitHub - dai-shi/will-this-react-global-state-work-in-concurrent-rendering: Test tearing and branching in React concurrent rendering</a></p><p><strong>概要：</strong></p><p>本文介绍了 React 18 中的一个新特性 —— 并发渲染，以及在全局状态下可能出现的 “tearing” 问题。作者通过测试不同的全局状态库，如 react-redux、zustand、recoil 等，来验证它们在并发渲染下的表现。测试包括更新和挂载时是否存在 tearing，以及暂时是否存在 tearing 等情况。文章指出，这些测试结果仅供参考，因为 tearing 和状态分支可能取决于应用程序的要求，并且测试方法有限。此外，作者还提到了另一个仓库，用于列出全局状态库的比较，欢迎贡献。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不阻塞事件循环的实用指南]]></title>
        <id>https://www.bbss.dev/posts/eventloop/</id>
        <link href="https://www.bbss.dev/posts/eventloop/"/>
        <updated>2023-05-09T08:34:39.705Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.bbss.dev/posts/eventloop/">Practical Guide To Not Blocking The Event Loop</a></p><p><strong>概要：</strong></p><p>本文介绍了 JavaScript 在单线程环境下的事件循环机制，以及如何避免同步任务阻塞事件循环。作者提出了三种解决方案：增加节点数量、将同步任务改为异步任务、将同步任务转移到另一个线程。其中，将同步任务转移到另一个线程需要使用 Worker，并且有数据传输限制。作者还介绍了将同步任务改为异步任务的具体实现方法，即通过将代码块分散到事件循环中来添加同步执行之间的间隙，从而让事件循环得以运行。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2.4 | 天文学]]></title>
        <id>https://astro.build/blog/astro-240/</id>
        <link href="https://astro.build/blog/astro-240/"/>
        <updated>2023-05-09T08:33:23.736Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://astro.build/blog/astro-240/">Astro 2.4 | Astro</a></p><p><strong>概要：</strong></p><p>Astro 2.4 发布了，新增了几个功能：更强大的 CSS 作用域、升级了 <Code /> 组件、在站点地图中支持服务器端渲染、中间件（实验性）和 CSS 内联（实验性）。其中，scopedStyleStrategy 允许使用类选择器来配置更高的特异性，<Code /> 组件升级到了 Shiki 0.14 版本，@astrojs/sitemaps 包更新以支持服务器端渲染，中间件支持拦截请求和响应并动态注入行为，CSS 内联可以通过配置将样式表嵌入到 < style > 标签中。此外，还包括一些 bug 修复和集成功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[粘性菜单的问题及替代方案]]></title>
        <id>https://adamsilver.io/blog/the-problem-with-sticky-menus-and-what-to-do-instead/</id>
        <link href="https://adamsilver.io/blog/the-problem-with-sticky-menus-and-what-to-do-instead/"/>
        <updated>2023-05-09T02:33:14.398Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://adamsilver.io/blog/the-problem-with-sticky-menus-and-what-to-do-instead/">The problem with sticky menus and what to do instead</a></p><p><strong>概要：</strong></p><p>本文讨论了粘性菜单（即固定在视口边缘的菜单）对用户体验的负面影响。这些菜单会占用页面空间、遮挡内容、缩放时出现问题、难以访问、容易使内部页面锚点失效、距离键盘用户较远并遮挡链接和其他可聚焦元素。作者建议解决根本原因，让页面变短，让用户自由滚动；将相关链接放入上下文中；使用返回顶部链接等方式来替代粘性菜单。</p>]]></content>
    </entry>
</feed>