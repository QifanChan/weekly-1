<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-07-14T01:02:04.505Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[3种常见的测试自动化类型]]></title>
        <id>https://web.dev/ta-types/</id>
        <link href="https://web.dev/ta-types/"/>
        <updated>2023-07-14T01:01:52.841Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://web.dev/ta-types/">3 common types of test automation</a></p><p><strong>概要：</strong></p><p>这篇文章主要探讨了如何进行 web 开发测试，包括两种一般的测试模式和三种常见的自动化测试类型。首先，我们需要确定我们应用程序质量需要保证的部分以及如何实现。在开始编写实际的测试代码之前，我们需要有一个计划。本文主要关注的是如何进行测试。我们的主要目标是规划正确的测试策略，但我们将在这里介绍最初的步骤：让我们发现可以用来从共同基础开始的测试类型。手动测试和自动化测试是两种基本的测试方式，然后详细介绍了不透明盒子测试（又称黑盒测试）和清晰盒子测试（又称白盒测试）两种测试程序。接着，文章介绍了单元测试、集成测试、端到端测试、视觉 UI 测试和静态分析等五种测试类型。最后，文章提出了五种常见的测试策略：测试金字塔、测试钻石、测试冰锥、测试蜂巢和测试奖杯。在下一篇文章中，我们将更详细地讨论这些不同的策略，并解释如何为你的项目选择最合适的策略。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js中的矢量数据库入门]]></title>
        <id>https://thecodebarbarian.com/getting-started-with-vector-databases-in-node-js.html</id>
        <link href="https://thecodebarbarian.com/getting-started-with-vector-databases-in-node-js.html"/>
        <updated>2023-07-14T00:56:16.725Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://thecodebarbarian.com/getting-started-with-vector-databases-in-node-js.html">Getting Started with Vector Databases in Node.js</a></p><p><strong>概要：</strong></p><p>向量数据库是当前的热门话题，其结合 AI 工具如 ChatGPT，可以实现语义相似性搜索：找出与此物体相似的物品。这种搜索形式比基本搜索引擎或文本搜索更复杂，因为搜索算法能够解释文本的语义，而不仅仅是尝试匹配关键词。一个语义搜索的应用是主题分类：给定一段文本，确定预定列表中哪个类别最符合该文本。例如，给定句子 "apple jumped 10% today"，这句话是关于 "Food" 还是 "Stocks"？传统的关键词搜索在这种区别上会有困难，因为没有办法在不解释文本语义的情况下区分苹果（水果）和 Apple（公司）。本教程将指导你使用 Node.js 和一个名为 Chroma 的向量数据库来构建一个玩具主题分类工具。

要在本地运行 Chroma，你应该克隆 Chroma 的 GitHub 仓库，并按照以下方式运行他们的 docker-compose 文件。一旦你运行了 Chroma，如果你还没有 OpenAI 的密钥，你也应该获取一个。然后，你可以使用你的 OpenAI 密钥在 Chroma 中存储给定句子的嵌入。嵌入是表示给定文本特征的向量。

主题分类的一个简单方法是为每个主题插入一些样本文本的嵌入，对于任何给定的文本，找到最接近该文本的向量。例如，让我们使用 "apple jumped 10% today" 作为 "Stocks" 类别的代表，"i like apple pie" 作为 "Food" 类别的代表。以下代码为这两个句子生成嵌入，并将它们与相关类别的元数据一起插入</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[您应该在项目配置中包含的5个TS编译器标志]]></title>
        <id>https://egorkonovalov.github.io/flycatcher/posts/3/</id>
        <link href="https://egorkonovalov.github.io/flycatcher/posts/3/"/>
        <updated>2023-07-14T00:55:42.107Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://egorkonovalov.github.io/flycatcher/posts/3/">5 TS Compiler Flags You Should Include In Your Project's Config</a></p><p><strong>概要：</strong></p><p>新发布的 TypeScript 5.0 主要更新引入了许多重大变化，如稳定的装饰器，常规枚举被联合枚举替代等。但是，我在阅读发布说明时发现了一些新的编译器选项，这让我思考是否有理由设置自定义编译器设置？简短的答案是 - 是的。本文介绍了五个可以提高开发体验的 TypeScript 编译器标志：noImplicitOverride、noUncheckedIndexedAccess、noPropertyAccessFromIndexSignature、allowUnreachableCode 和 noFallthroughCasesInSwitch。通过利用这些编译器设置，你可以提高代码库的安全性、可读性和可维护性。虽然默认配置已经过测试并且可靠，但花时间探索和调整编译器设置可以提供宝贵的见解和优化。然而，必须在便利和定制之间找到平衡，尝试与团队讨论你将使用的风格，并构建所有人都喜欢的环境。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prettier 3.0: 你好, ECMAScript 模块！- 袩褉芯懈蟹胁芯写褋褌胁械薪薪褘械]]></title>
        <id>https://prettier.io/blog/2023/07/05/3.0.0.html</id>
        <link href="https://prettier.io/blog/2023/07/05/3.0.0.html"/>
        <updated>2023-07-14T00:53:38.099Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://prettier.io/blog/2023/07/05/3.0.0.html">Prettier 3.0: Hello, ECMAScript Modules! · Prettier</a></p><p><strong>概要：</strong></p><p>Prettier 团队发布了新版本，其中包括对 ECMAScript 模块的全面使用。这一改变极大地提高了开发体验。此次更新带来了一些重大变化，例如在 markdown 格式中，拉丁字符和中文或日文字符之间不再插入空格。另外，trailingComma 的默认值已更改为 "all"。此次发布还对插件接口进行了重大改造，现在 Prettier 支持使用 ECMAScript 模块和异步解析器编写的插件。此外，该版本还包括许多格式化改进和错误修复。如果你赞赏 Prettier 并希望支持我们的工作，请考虑直接通过我们的 OpenCollective 赞助我们，或者赞助我们依赖的项目，如 typescript-eslint、remark 和 Babel。感谢你的持续支持！</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[超越浏览器：JavaScript标准的长远未来]]></title>
        <id>https://thenewstack.io/beyond-browsers-the-longterm-future-of-javascript-standards/</id>
        <link href="https://thenewstack.io/beyond-browsers-the-longterm-future-of-javascript-standards/"/>
        <updated>2023-07-14T00:53:08.776Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://thenewstack.io/beyond-browsers-the-longterm-future-of-javascript-standards/">Beyond Browsers: The Longterm Future of JavaScript Standards</a></p><p><strong>概要：</strong></p><p>JavaScript，被许多排名认为是最流行和最广泛使用的语言，已经从浏览器中崭露头角，并在其初始平台之外变得非常有用。然而，该语言的 ECMAScript 标准仍主要受到浏览器需求的驱动。即使在新环境中，如服务器端和嵌入式 JavaScript 运行时，这些运行时仍在使用来自浏览器的 JavaScript 引擎，尽管他们的需求往往大不相同。

WinterCG 社区组织于去年在 W3C 成立，目的是关注浏览器和非浏览器运行时之间的跨运行时互操作性，倡导对服务器端 JavaScript 环境重要的特性，这些特性可能对浏览器并不那么重要。WinterCG 并非一个竞争性的标准机构，而是关于协调的，识别共同需求并通过标准机构或其他地方进行协商。

WinterCG 正在试图协调一种适合服务器的 fetch 版本，以及支持 Web API，如文本编码器和设置超时 API，在各个运行时中以兼容的方式运行。这并不是创建一个新的规范，而是从实际的 fetch 规范开始，剔除对服务器不适用的部分。

对于 JavaScript 开发者来说，能够依赖所有 Web 互操作运行时的全面统一 API 表面将是理想的基础。支持浏览器中可用的子集的通用方式，将使开发者和运行时创建者构建新功能更加经济和可持续。

异步上下文是一种简化代码追踪发生情况的方式，通过共享变量。这种分布式追</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[滚动驱动动画性能案例研究 - Chrome Developers]]></title>
        <id>https://developer.chrome.com/blog/scroll-animation-performance-case-study/</id>
        <link href="https://developer.chrome.com/blog/scroll-animation-performance-case-study/"/>
        <updated>2023-07-14T00:52:23.163Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/blog/scroll-animation-performance-case-study/">A case study on scroll-driven animations performance - Chrome Developers</a></p><p><strong>概要：</strong></p><p>文章介绍了滚动驱动动画，这是一种通过用户的滚动位置触发的方式，增加网站或网络应用的互动性和视觉吸引力。过去，创建滚动驱动动画的唯一方式是在主线程上响应滚动事件，这存在两个主要问题：滚动是在单独的进程上执行并异步传递滚动事件；主线程动画容易出现卡顿。因此，创建与滚动同步且高效的滚动驱动动画非常困难。现在，我们引入了一套新的 API 来支持滚动驱动动画，可以通过 CSS 或 JavaScript 使用。新 API 尽可能少地使用主线程资源，使得实现滚动驱动动画更加容易和流畅。文章还通过对比新旧方法，展示了新 API 如何轻松实现平滑的滚动驱动动画。最后，文章指出新 API 不仅限于 CSS，还可以使用 JavaScript 创建流畅的滚动驱动动画，与 CSS 版本的底层技术相同，尽可能少地使用主线程资源，使动画比传统的 JavaScript 方法更流畅。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prisma 5: 默认速度更快]]></title>
        <id>https://www.prisma.io/blog/prisma-5-f66prwkjx72s</id>
        <link href="https://www.prisma.io/blog/prisma-5-f66prwkjx72s"/>
        <updated>2023-07-14T00:51:29.466Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.prisma.io/blog/prisma-5-f66prwkjx72s">Prisma 5: Faster by Default</a></p><p><strong>概要：</strong></p><p>Prisma 4.8.0 版本开始，我们加大了改善 Prisma 性能和开发者体验的努力，特别是在无服务器环境中提高 Prisma 的启动性能。通过改进，我们发现了一些效率问题并解决了它们。为了说明我们提升性能的成果，以下是在我们进行改进之前和之后的 AWS Lambda 部署应用（带有大型 Prisma 模式，含 500 个模型）的启动性能对比图。你可以看到，Prisma 的启动性能有了显著的改善。在 Prisma 4.11.0 版本之前，Prisma 使用类似 GraphQL 的协议在 Prisma 客户端和查询引擎之间通信，这对于 Prisma 客户端的性能产生了影响，尤其是在无服务器环境的冷启动中。我们注意到，当前的实现方式增加了相当大的 CPU 和内存开销，尤其是对于较大的模式。我们的解决方案之一是完全重新设计我们的线协议。使用 JSON，我们能够使 Prisma 客户端和查询引擎之间的通信变得更加高效。此外，我们还优化了查询引擎的内部机制，包括减少了 Prisma 客户端的依赖数量，移除了之前的类似 GraphQL 的协议实现，优化了数据库连接和 Prisma 模式转换等过程，从而显著提高了运行时性能。同时，我们鼓励用户升级到 Prisma 5.0.0 版本，并期待听到您的反馈。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[外部磁盘上的 pnpm]]></title>
        <id>https://antfu.me/posts/pnpm-external-disk</id>
        <link href="https://antfu.me/posts/pnpm-external-disk"/>
        <updated>2023-07-14T00:49:36.458Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/pnpm-external-disk">pnpm on External disk</a></p><p><strong>概要：</strong></p><p>如果你试图在外部磁盘上安装使用 pnpm 的项目，可能无法立即工作，因为 pnpm 严重依赖于符号链接，而这在跨挂载点时无法工作。为了解决这个问题，你可以在.npmrc 中添加以下配置：这将使 pnpm 复制文件而不是创建它们的符号链接，并正确地在 node_modules/.bin 中显示可执行文件。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无需 Figma 的网页设计]]></title>
        <id>https://world.hey.com/dhh/design-for-the-web-without-figma-4bc3a218</id>
        <link href="https://world.hey.com/dhh/design-for-the-web-without-figma-4bc3a218"/>
        <updated>2023-07-13T06:10:35.094Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://world.hey.com/dhh/design-for-the-web-without-figma-4bc3a218">Design for the web without Figma</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了 Figma 设计工具的使用和网页设计的最佳实践。虽然 Figma 是一个非常出色的设计工具，被 37signals 等公司广泛使用，但在开发 Basecamp 或 HEY 等网络应用时，他们并不主要依赖 Figma，而是直接在 HTML 和 CSS 中进行设计。因为无论 Figma 多么优秀，它仍然是一种中间抽象层，像之前的 Photoshop 一样。如果你在网络上工作，没有这种抽象层的设计过程会使程序员和设计师的协作更加顺畅。37signals 的两人团队就是通过这种方式提高生产力和可行性的。他们所有的网络设计师都直接使用 HTML、CSS，甚至大量的 JavaScript 和 Ruby。设计过程及其迭代通过更新真实运行的应用程序的代码，并尽快对真实数据进行反馈。作者认为，创造力源于限制，设计师应该熟练掌握网络的材料，而不必成为前端开发的专家。他们应该努力提高他们的 HTML、CSS、JavaScript 技能，甚至后端语言技能，作为他们职业发展的关键部分。虽然找到既能设计又能实现创意的设计师可能很难，但 37signals 已经多次做到了，从而大大提高了生产力。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[克劳德 2]]></title>
        <id>https://www.anthropic.com/index/claude-2</id>
        <link href="https://www.anthropic.com/index/claude-2"/>
        <updated>2023-07-13T06:09:09.973Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.anthropic.com/index/claude-2">Claude 2</a></p><p><strong>概要：</strong></p><p>我们很高兴地宣布推出新模型 Claude 2。Claude 2 的性能得到了提升，响应更长，可以通过 API 以及新的公开测试网站 claude.ai 进行访问。用户反馈称，Claude 易于交谈，清晰解释其思考过程，不太可能产生有害输出，并且记忆力更强。我们在编码、数学和推理方面对上一代模型进行了改进。例如，我们的最新模型在律师资格考试的多项选择题部分得分为 76.5%，比 Claude 1.3 的 73.0% 有所提高。Claude 2 在 GRE 阅读和写作考试中的得分超过了 90% 的申请研究生的成绩，而在定量推理方面的得分与中位数申请人相似。Claude 2 的输入和输出长度都得到了增加，用户可以在每个提示中输入多达 100K 的标记，这意味着 Claude 可以处理数百页的技术文档甚至一本书。Claude 现在也可以一次性写出更长的文件 —— 从备忘录到信件到故事，所有这些都可以一次性完成。此外，我们的最新模型在编码技能方面有了显著的提高。Claude 2 在 Codex HumanEval 的 Python 编码测试中得分为 71.2%，高于 56.0%。在 GSM8k（一套大型小学数学问题集）中，Claude 2 的得分为 88.0%，高于 85.2%。我们已经为 Claude 2 规划了一系列令人兴奋的功能改进计划，并将在未来几个月中逐步部署。Claude 2 目前在美国和英国普遍可用，我们正在</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[您可能不需要Jest - Node.js原生测试运行器非常棒 | pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/you-might-not-need-jest-the-node-js-native-test-runner-is-great/</id>
        <link href="https://pawelgrzybek.com/you-might-not-need-jest-the-node-js-native-test-runner-is-great/"/>
        <updated>2023-07-12T14:59:06.342Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/you-might-not-need-jest-the-node-js-native-test-runner-is-great/">You might not need Jest — the Node.js native test runner is great | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>文章主要介绍了 Node.js 原生测试运行器的一些特性和使用方法。现代的 JavaScript 运行时环境，如 Deno 和 Bun，以及像 Go 和 Rust 这样的现代编程语言都具备测试功能，Node.js 也在逐步跟上。Node.js 的测试运行器模块在 18 版本中首次实验性引入，并在 20 版本中稳定下来。此模块在出现错误时返回进程退出代码 1，否则返回 0。此外，文章还介绍了如何使用 node:assert 模块简化断言，以及如何执行所有匹配文件的测试。Node.js 在添加测试设施时功能有限，但几次迭代后，我们现在可以使用许多更常用的测试特性，如分组、模拟、挂钩等。此外，Node.js 在 18.11 版本中添加了观察模式，稍后在 19.2 版本中为测试运行器添加了观察模式。默认的人类可读测试报告（spec）可以替换为紧凑（dot）格式，如果这些选项都不符合你的需求，可以使用 npm 安装自定义报告，或者创建一个遵循 TAP（Test Anything Protocol）规范的自定义报告。最后，作者表示，使用 jest 也是可以的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用耳语转录播客]]></title>
        <id>https://www.swyx.io/whisper-for-podcasts</id>
        <link href="https://www.swyx.io/whisper-for-podcasts"/>
        <updated>2023-07-12T04:33:06.092Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.swyx.io/whisper-for-podcasts">Using Whisper to Transcribe Podcasts</a></p><p><strong>概要：</strong></p><p>该文章是作者在邀请读者订阅他们的时事通讯，包括 AI 新闻和 DevRel/DevTools 新闻。目前已有超过 10,000 的订阅者，并会不定期更新新的帖子和项目。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - privatenumber/minification-benchmarks: 🏃‍♂️🏃‍♀️🏃 JS minification benchmarks: babel-minify, esbuild, terser, uglify-js, swc, google closure compiler, tdewolff/minify]]></title>
        <id>https://github.com/privatenumber/minification-benchmarks</id>
        <link href="https://github.com/privatenumber/minification-benchmarks"/>
        <updated>2023-07-12T04:29:20.988Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/privatenumber/minification-benchmarks">GitHub - privatenumber/minification-benchmarks: 🏃‍♂️🏃‍♀️🏃 JS minification benchmarks: babel-minify, esbuild, terser, uglify-js, swc, google closure compiler, tdewolff/minify</a></p><p><strong>概要：</strong></p><p>这篇文章是一个关于 JavaScript 压缩器性能对比的报告，涵盖了 babel-minify、esbuild、google-closure-compiler、minify-js、swc、tdewolff/minify、terser 和 uglify-js 等多种压缩器。每个压缩器都在自己的进程中执行，设定了 20 秒的超时时间，并在压缩前后进行了完整性测试。压缩器的排名依据是压缩后文件的大小。测试结果显示，在多数情况下，uglify-js 和 swc 的表现最佳，它们不仅能有效地减小文件大小，还能在较短的时间内完成压缩任务。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sass：浏览器中的Sass]]></title>
        <id>https://sass-lang.com/blog/sass-in-the-browser/</id>
        <link href="https://sass-lang.com/blog/sass-in-the-browser/"/>
        <updated>2023-07-12T01:33:34.590Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://sass-lang.com/blog/sass-in-the-browser/">Sass: Sass in the Browser</a></p><p><strong>概要：</strong></p><p>Natalie Weizenbaum 在 2023 年 7 月 7 日发布的文章中提到，Sass 现在可以直接在浏览器中运行。这得益于 Dart Sass 1.63 版本的发布，它正式支持 sass npm 包在浏览器中直接运行，不再需要通过服务器来编译 Sass。此外，Sass 还可以通过多种方式加载，包括 CommonJS require () 和 ES6 import，也可以通过打包工具（如 esbuild、Rollup、Vite 和 webpack）或者直接在浏览器中无需打包就可以加载。唯一的注意事项是，如果你在没有任何打包的情况下使用它，你需要设置一个导入地图以找到它所依赖的 Immutable 库。此外，Sass 网站上新增了一个长期期待的功能：Sass Playground，用户可以在浏览器中直接测试 Sass，并且始终使用最新版本的所有最新功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[循环依赖空间切换]]></title>
        <id>https://kizu.dev/cyclic-toggles/</id>
        <link href="https://kizu.dev/cyclic-toggles/"/>
        <updated>2023-07-11T09:35:32.067Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://kizu.dev/cyclic-toggles/">Cyclic Dependency Space Toggles</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一种新的 CSS 技术，即通过切换单个自定义属性从列表中选择值。作者首先展示了代码，然后解释了这种被称为 “循环切换” 的技术。这种技术利用了 CSS 变量的循环依赖性，使得当我们跨引用自定义属性时，所有变量都会变成 “保证无效值”。作者还探讨了这种技术的限制，包括继承、动画和命名等问题。此外，作者也提到了这种技术的使用案例，如主题选择、组件 API 等。最后，作者强调了分享和请求特定功能的重要性，因为这有助于推动 CSS 的发展。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[亲身体验Node.js测试运行器]]></title>
        <id>https://www.sonarsource.com/blog/node-js-test-runner/</id>
        <link href="https://www.sonarsource.com/blog/node-js-test-runner/"/>
        <updated>2023-07-11T09:32:39.333Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.sonarsource.com/blog/node-js-test-runner/">Hands on with the Node.js test runner</a></p><p><strong>概要：</strong></p><p>Node.js 在 18 版本中发布了一个实验性的测试运行器，并在 20 版本中将其稳定化。这意味着我们作为 JavaScript 开发者可以使用内置的测试运行器，而无需依赖第三方包，如 Mocha、Jasmine 或 Jest。这减少了维护成本和配置复杂性。此外，该测试运行器还提供了一套基础原语，供测试框架标准化使用。文章还介绍了如何使用 Node.js 测试运行器编写测试，包括创建测试文件、执行测试命令、使用断言模块、跳过测试等操作。最后，文章表示，尽管 Node.js 测试运行器还提供了内置的模拟功能、实验性的观察模式和测试覆盖率收集，但对于小型项目，测试运行器和断言模块已经足够用来编写测试套件。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 MDN Playground：让您的代码栩栩如生！| MDN 博客]]></title>
        <id>https://developer.mozilla.org/en-US/blog/introducing-the-mdn-playground/</id>
        <link href="https://developer.mozilla.org/en-US/blog/introducing-the-mdn-playground/"/>
        <updated>2023-07-11T09:31:00.549Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.mozilla.org/en-US/blog/introducing-the-mdn-playground/">Introducing the MDN Playground: Bring your code to life! | MDN Blog</a></p><p><strong>概要：</strong></p><p>Mozilla 宣布推出 MDN Playground，这是一个可以预览 HTML、CSS 和 JavaScript 的简单方式。MDN Playground 提供了快速原型设计和测试想法的无障碍方式，用户只需将代码粘贴到 playground 中，就可以立即在预览区域看到结果。此外，它还支持实时交互，使用户能够实时与代码进行交互，进行更改并立即观察其效果。MDN Playground 还扩展了代码示例，解决了在文档中阅读代码示例而无法立即试验的问题。当用户在 MDN 上遇到代码示例时，现在会找到一个方便的 “播放” 按钮，点击它将在 MDN Playground 中打开示例，准备供用户探索和修改。此外，MDN Playground 还支持协作，使得与同事合作或寻求社区帮助变得比以往任何时候都更容易。用户可以与他人分享代码 playground，让他们查看和重新混合代码。要开始使用 MDN Playground，只需访问 developer.mozilla.org/en-US/play 并深入交互式 Web 开发的世界。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[svelte.dev：全面改版]]></title>
        <id>https://svelte.dev/blog/svelte-dev-overhaul</id>
        <link href="https://svelte.dev/blog/svelte-dev-overhaul"/>
        <updated>2023-07-11T09:30:19.823Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://svelte.dev/blog/svelte-dev-overhaul">svelte.dev: A complete overhaul</a></p><p><strong>概要：</strong></p><p>Svelte 的新网站发布了，采用全新设计，并增加了多项新功能和底部导航栏。新网站对旧版进行了全面改革，文档已经分为多个页面，所有页面在右侧边栏列出各自的章节。新网站还配备了搜索栏，可以通过它在文档和 API 表面进行搜索。此外，新网站还提供 JavaScript / TypeScript 切换功能，使用户可以以自己喜欢的方式查看文档。新网站还添加了深色模式开关，并与操作系统的深色模式设置同步。此外，REPL 也被重新编写，完全类型安全，并带有深色模式等功能。新网站的首页也得到了更新，与 kit.svelte.dev 保持一致，并展示了由 @vedam 制作的美丽的 Svelte Machine。最后，新网站还实现了网站的统一，现在 svelte.dev、kit.svelte.dev 和 learn.svelte.dev 都使用相同的设计系统，彼此之间更加一致，这使得在网站之间导航变得更加容易，也使维护工作变得更加容易。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布regex 1.9 | Rust博客]]></title>
        <id>https://blog.rust-lang.org/2023/07/05/regex-1.9.html</id>
        <link href="https://blog.rust-lang.org/2023/07/05/regex-1.9.html"/>
        <updated>2023-07-07T10:00:52.513Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.rust-lang.org/2023/07/05/regex-1.9.html">Announcing regex 1.9 | Rust Blog</a></p><p><strong>概要：</strong></p><p>正则表达式小组宣布发布了 regex 1.9 版本。regex 库由 Rust 项目维护，是在 Rust 中使用正则表达式的推荐方式。其定义特性是保证最坏情况下线性时间搜索，相对于被搜索字符串的大小。虽然 regex 库的发布通常不会在此博客上公告，但由于在 1.9 版本中，其内部的大部分已经被重写，因此这个公告旨在鼓励额外的审查。如果你遇到任何问题或性能回归，请在问题跟踪器上报告或在讨论论坛上提问。新版本进行了一些 API 添加，值得一提的是 Captures::extract 方法，这将使在某些情况下获取捕获组更加方便。否则，人们应该看到的主要变化是搜索时间更快。你可以在 CHANGELOG 和更深入的关于 regex 库内部作为库的博客文章中阅读更多信息。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript Gom Jabbar]]></title>
        <id>https://frantic.im/javascript-gom-jabbar/</id>
        <link href="https://frantic.im/javascript-gom-jabbar/"/>
        <updated>2023-07-07T09:42:16.725Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://frantic.im/javascript-gom-jabbar/">JavaScript Gom Jabbar</a></p><p><strong>概要：</strong></p><p>这篇文章描述了一个拥有 10 年 JavaScript 经验的开发者面对一项任务：打开并阅读一个充满挑战的 package.json 文件。作者表达出对各种编程问题和困扰的痛苦，包括版本管理、包命名冲突、模块迁移、复杂的脚本、依赖管理等。他提到了许多具体的库和工具，如 Isomorphic JavaScript, watchman, gulp, left-pad, moment.js, eslint, postcss, jest 等，以及它们带来的问题。同时，他也表达了对维护过时依赖包、处理编译错误、配置测试运行器等任务的恐惧和压力。尽管如此，他仍然坚持下去，因为他知道这是程序员的日常工作。最后，他鼓励读者订阅他的博客以获取更多编程、软件设计和项目相关的信息。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lenz Weber-Tronic (phryneas) - 我对当前React与服务器组件争议的看法]]></title>
        <id>https://phryneas.de/react-server-components-controversy</id>
        <link href="https://phryneas.de/react-server-components-controversy"/>
        <updated>2023-07-07T09:41:07.910Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://phryneas.de/react-server-components-controversy">Lenz Weber-Tronic (phryneas) - My take on the current React & Server Components controversy</a></p><p><strong>概要：</strong></p><p>这篇文章是一位技术人员对 React Server Components（RSC）和 React 团队的沟通方式表达了自己的挫败感。他认为，虽然每个人都有自己的立场，但我们大多数人都以最不生产的方式进行交流。

文章作者身为 Apollo Client、Redux Toolkit 和 RTK Query 等库的维护者，他发现帮助用户变得更加困难。因为人们遇到了一些奇怪的问题，他无法为他们解决所有问题。比如，StackOverflow 上的用户面临着他们无法理解的错误信息。他们在 React 主页上创建了一个新的 React 项目，然后只是应用了默认设置。他们不知道什么是 Server Component，但他们现在正在编写 Server Components。而这三个库在 Server Components 中的工作方式与之前完全不同。

作者还提出了一些建议，包括在 Canaries 中隐藏实验性功能，试图使客户端和服务器用户体验保持一致，以及提供一些缺失的 API 等。他希望通过这篇文章引起人们的关注，并愿意就这些想法进行交谈并提供帮助。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在2023年与SVG-in-JS决裂]]></title>
        <id>https://kurtextrem.de/posts/svg-in-js</id>
        <link href="https://kurtextrem.de/posts/svg-in-js"/>
        <updated>2023-07-07T09:40:25.177Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://kurtextrem.de/posts/svg-in-js">Breaking Up with SVG-in-JS in 2023</a></p><p><strong>概要：</strong></p><p>去年 12 月，一篇题为 “为什么我们要和 CSS-in-JS 分手” 的文章引起了轰动，解释了为什么你不再希望在 JS 包中包含 CSS。然而，现在 JS 包中不仅有 CSS，还有 SVG，正如 Preact 的作者 Jason Miller 所展示的那样：“请不要将 SVG 作为 JSX 导入，这是最昂贵的形式，比其他技术至少贵 3 倍，而且会影响运行时（渲染）性能和内存使用。” 他还指出，一个流行网站的包中，几乎 50% 都是 SVG 图标（250kb），大部分都没有用到。因此，我们需要把 SVG 从 JS 包中移出，重新回归到 HTML 中。本文将探讨在保持 JS 包小巧和高效的同时，更好地使用 SVG 的技术。这些技术包括：使用 < img > 标签加载 SVG、使用 < use > 创建 SVG 精灵、通过 CSS 和 currentcolor 移除更多的 JS、使用 React 的服务器组件等。另外，如果遇到 CORS 问题，可以使用 CSS 进行救援。此外，我们还需要权衡性能和加载时间，决定是否内联 SVG。最后，我们可以使用一些工具和代码片段来实现这些操作。总的来说，通过使用这些技巧，你可以使你的 JavaScript 包变得更小、更高效，这对于旧设备和慢速设备非常有帮助，也使互联网变得更加包容。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js应用程序路由器更新]]></title>
        <id>https://nextjs.org/blog/june-2023-update</id>
        <link href="https://nextjs.org/blog/june-2023-update"/>
        <updated>2023-07-06T03:02:01.177Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nextjs.org/blog/june-2023-update">Next.js App Router Update</a></p><p><strong>概要：</strong></p><p>Next.js 团队正在专注于改进性能、稳定性和开发者教育。他们已经设计了一种新的基础设施 ——App Router，以满足更大规模应用的需求。这个新工具允许开发者逐步迁移到新的 API，而不需要对整个应用进行重写。目前，团队正在探索更多使增量采用变得更容易的机会。在性能方面，他们正在专注于提高本地迭代速度、生产构建时间和无服务器性能。他们还在努力优化现有的 webpack 架构的性能，并计划用 Turbopack 替换 webpack。为了改善稳定性，他们正在修复 App Router 中的 bug，并感谢社区的反馈。最后，他们正在重新编写 Next.js 的文档，并计划发布更多的教育资源，以帮助开发者理解新的特性和概念。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[npm生态系统核心的巨大错误]]></title>
        <id>https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem</id>
        <link href="https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem"/>
        <updated>2023-07-06T03:01:33.182Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem">The massive bug at the heart of the npm ecosystem</a></p><p><strong>概要：</strong></p><p>文章是由前 npm CLI 团队的工程经理撰写，主要讨论了 npm 包的 "manifest confusion" 问题。npm 包的清单与其 tarball 独立发布，且从未完全验证过它们的内容是否一致。这导致任何使用公共注册表的工具或洞察可能易受攻击或不准确，恶意行为者可以在直接或转移依赖项中隐藏恶意软件和脚本而不被检测到。作者认为，应该进一步调查以确定受影响的注册表条目的范围，并尽快记录 npm 公共注册表 API 及其各自的请求 / 响应对象。同时，建议开发者联系任何已知依赖于 npm 注册表的 manifest 数据的工具作者 / 维护者，并确保他们在适当时开始使用包的内容作为元数据。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高级macOS命令 - saurabhs.org]]></title>
        <id>https://saurabhs.org/advanced-macos-commands</id>
        <link href="https://saurabhs.org/advanced-macos-commands"/>
        <updated>2023-07-06T03:00:40.075Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://saurabhs.org/advanced-macos-commands">Advanced macOS Commands - saurabhs.org</a></p><p><strong>概要：</strong></p><p>文章介绍了 macOS 系统中的一些高级命令行工具，包括 Unix 标准工具和 macOS 特有的功能。这些工具包括：caffeinate 用于设置 Mac 的睡眠行为；pbcopy 和 pbpaste 用于与系统剪贴板交互；networkQuality 用于测量互联网速度；sips 用于图像操作；open 用于打开文件和应用程序；textutil 是文档文件转换器；mdfind 和 mdls 用于使用 Spotlight 进行搜索；screencapture 用于截屏；taskpolicy 用于控制进程的调度；say 是文本转语音引擎；pmset 用于配置电源管理；networksetup 用于配置网络设置；softwareupdate 用于管理操作系统更新；system_profiler 用于查看系统信息。每个工具都有详细的使用说明和例子，可以通过运行 man <command> 查看完整的文档。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[现代JavaScript中的安全数据获取]]></title>
        <id>https://www.builder.io/blog/safe-data-fetching</id>
        <link href="https://www.builder.io/blog/safe-data-fetching"/>
        <updated>2023-07-06T02:59:43.875Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/safe-data-fetching">Safe Data Fetching in Modern JavaScript</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了 JavaScript 中 Fetch 函数的使用方法和常见问题，作者指出直接使用 Fetch 可能会遇到错误处理不当和信息丢失等问题。为了解决这些问题，作者提出了创建自定义错误类和封装 Fetch 函数的方法，使得错误处理更加智能和方便。但是，这种方法仍然需要开发者每次都写一定量的样板代码。因此，作者推荐使用 Axios、Redaxios 和 Wretch 等开源解决方案，它们可以自动处理上述问题，同时还有更多的文档、测试和社区支持。无论选择哪种方式，作者强调要正确地获取数据，以保证用户体验和团队效率。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[现代Javascript：过去10年中你错过的一切]]></title>
        <id>https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years</id>
        <link href="https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years"/>
        <updated>2023-07-06T02:59:21.311Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years">Modern Javascript: Everything you missed over the last 10 years</a></p><p><strong>概要：</strong></p><p>这篇文章是一份 JavaScript 的速查表，作者总结了近年来在现代浏览器中广泛支持的 JavaScript 新语法和功能。包括内置数组函数、const/let 关键字、空值合并和可选链运算符、Async/Await 关键字、箭头函数、for...of 循环、异步迭代、类、get/set 函数、函数默认参数、命名参数、剩余参数、Object.assign 和展开运算符、解构、简写函数、Promise.all、模板字面量、代理以及模块导入 / 导出等。每个主题都附有示例代码和进一步文档的链接。此外，作者还提供了其他参考资源，如 Map、Set、生成器、严格模式、数组方法、对象静态方法、反射、URL 等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ember 5.0发布]]></title>
        <id>https://blog.emberjs.com/ember-5-0-released/</id>
        <link href="https://blog.emberjs.com/ember-5-0-released/"/>
        <updated>2023-07-06T02:53:30.631Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.emberjs.com/ember-5-0-released/">Ember 5.0 Released</a></p><p><strong>概要：</strong></p><p>EmberJS 5.0 代表了开发者对 Ember 生态系统稳定性和可靠性的承诺。Ember 团队努力去除所有弃用的部分，并向 Polaris 迈进。这篇文章介绍了我们的发布策略，如何升级，预期结果，以及被移除的过时 API。
这是根据 RFC 830 提出的新发布策略和目标下的第一个主要版本。总结来说，每 12 个小版本，Ember 将发布一个新的主要版本，移除任何针对该主要版本的过时代码。
在引入新功能时，Ember 通常旨在在小版本中发布新功能，同时为现有代码提供向后兼容性，同时让开发者有机会尝试新功能。这种方法减少了团队面临的主要升级挑战，相比于制作带有大量新功能的大型、突破性、引人注目的主要版本。
在 Ember 4.x 的小版本中，我们添加了一些特性（当然还有各种错误修复）：
在 Ember 4.1 中，我们发布了一系列改善生活质量的改进：
缓存昂贵 getter 的 @cached 装饰器
@service 装饰器，所以你不再需要导入 {inject as service}
Ember 路由器上的刷新方法，使整个当前路由树的数据刷新更容易
在 Ember 4.4 中，我们发布了一个 {{unique-id}} 助手，使编写可访问表单更容易，并通过改进 setupTest 的蓝图使测试定制更容易。
在 Ember 4.5 中，我们使得可以使用普通的 JavaScript 函数作为助手：不再需要用 helper () 包裹它们！
我们还发布了一个新的测试原语，renderSettled</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CommonJS是不会消失的]]></title>
        <id>https://bun.sh/blog/commonjs-is-not-going-away</id>
        <link href="https://bun.sh/blog/commonjs-is-not-going-away"/>
        <updated>2023-07-06T02:48:37.350Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bun.sh/blog/commonjs-is-not-going-away">CommonJS is not going away</a></p><p><strong>概要：</strong></p><p>文章讨论了 JavaScript 的未来，特别是关于 CommonJS 和 ES 模块（ESM）的使用。尽管 ESM 被视为 JavaScript 的未来，但 CommonJS 仍然有其存在的价值。数据显示，ESM 在 npm 上的使用率为 9%，而 CJS（CommonJS）的使用率为 73.6%。CommonJS 在 2009 年开发并由 Node.js 推广，它允许文件将属性分配给名为 exports 的特殊变量，然后其他文件可以通过特殊的 require 函数引用 exports 对象的属性。相比之下，ESM 在 2015 年作为 ES6 的一部分引入，它使用 export 关键字声明其导出，并使用 import 关键字从其他文件导入。与 CommonJS 不同，ESM 设计用于在浏览器中工作，预期文件会通过网络加载，这就是 ES 模块被称为异步的原因。文章还指出，CommonJS 启动速度更快，允许动态模块加载，并且已经在 npm 发布了数百万个模块。最后，Bun v0.6.5 开始原生实现 CommonJS，而且 Bun 也增加了对__esModule 注解的支持，这是 CommonJS 模块表明 exports.default 应被解释为默认导出的事实标准方式。总的来说，CommonJS 已经在这里并将继续存在，Bun 将其视为一等公民。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Remotion 4.0 | Remotion | 在React中以编程方式制作视频]]></title>
        <id>https://www.remotion.dev/blog/4-0</id>
        <link href="https://www.remotion.dev/blog/4-0"/>
        <updated>2023-07-06T02:47:30.098Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.remotion.dev/blog/4-0">Remotion 4.0 | Remotion | Make videos programmatically in React</a></p><p><strong>概要：</strong></p><p>Remotion 4.0 发布了最大的更新，为每个工作流程带来了重大改进。这次更新引入了 Remotion Studio，并增加了一些方便的功能。现在，用户可以通过图形界面直接编辑数字、字符串、数组、对象、枚举和日期等属性，甚至可以可视化和编辑嵌套的数据结构。此外，该版本还增加了渲染按钮，用户只需按下按钮就可以渲染资产。新版本还使用 Rust 二进制文件加速了当前和未来的功能，并内置了 FFmpeg。此外，Remotion 4.0 还提供了对 WebP 和 PDF 生成的支持，简化了数据驱动视频的制作，并升级了所有模板以使用新特性。此外，该版本还增加了许多新功能，包括 @remotion/rive 包、@remotion/shapes 包、@remotion/tailwind 包、音频编解码器的调整、Lambda 的改进、新的 PHP 和 Go SDKs、播放器的改进、ES 模块支持、字体选择器、新的核心 API 等。</p>]]></content>
    </entry>
</feed>