<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-06-27T03:06:44.948Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[用键盘锁API实现更好的全屏模式 - Chrome开发人员]]></title>
        <id>https://developer.chrome.com/blog/better-full-screen-mode/</id>
        <link href="https://developer.chrome.com/blog/better-full-screen-mode/"/>
        <updated>2023-06-27T03:01:02.572Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/blog/better-full-screen-mode/">Better full screen mode with the Keyboard Lock API - Chrome Developers</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了如何使用键盘锁 API 来在全屏模式下捕获 Escape 键。作者指出，当用户在全屏游戏中打开一个对话框，本能地用 Escape 键取消时，可能会被强制退出全屏模式，这是由于对话框和全屏模式对 Escape 键的 “争夺”。默认情况下，全屏模式总是胜出。但通过使用键盘锁 API，可以让对话框成为 Escape 键的 “赢家”。该 API 可以在 navigator.keyboard 上使用，lock () 方法可以在启用后捕获物理键盘上所有键的按键。此方法只能捕获操作系统授权访问的键，幸运的是 Escape 键就是其中之一。如果你的应用有全屏模式，可以在请求全屏时捕获 Escape 键，以此作为渐进增强的手段。当用户离开全屏模式时，通过 Keyboard 接口的 unlock () 方法解锁（即不再捕获）键盘。这样，在全屏模式下，按下 Escape 键将默认取消对话框。如果用户长按 Escape 键，仍然可以退出全屏模式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在VSCode中提高生产力的6个快速技巧]]></title>
        <id>https://techhub.iodigital.com/articles/6-vscode-tips</id>
        <link href="https://techhub.iodigital.com/articles/6-vscode-tips"/>
        <updated>2023-06-27T03:00:42.843Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://techhub.iodigital.com/articles/6-vscode-tips">6 Quick Tips to Boost Your Productivity in VSCode</a></p><p><strong>概要：</strong></p><p>这篇文章分享了六个 VSCode 的使用技巧，帮助开发者优化工作流程。1. 通过快捷键 cmd + option + o（Windows 上为 Shift + Alt + o）可以方便地删除无用的引入，使代码库更整洁。2. 在 VSCode 中，可以通过 F2 键轻松重命名变量，系统会自动更新代码中所有该变量的实例，节省时间并保证一致性。3. 对于频繁使用的命令或扩展，可以设置快捷键，提高工作效率。在 “代码> 首选项 > 键盘快捷方式” 中搜索需要的操作，双击快捷方式列并设定你喜欢的快捷键。4. 可以设置一个快速修复 ESLint 问题的自定义快捷键。将以下代码复制到 keybindings.json 文件中，并分配一个未被 VSCode 使用的键组合，即可立即触发 ESLint 的自动修复功能。5. VSCode 内置的 “快速修复” 功能能够显示当前上下文所有可用的快速修复方案，例如添加缺失的引入、修复 linting 问题或向单行箭头函数添加花括号。6. 可以创建一个 “快速修复：添加所有缺失的引入” 的快捷键，比如设定为 cmd + '，当遇到未解决的引入时，只需使用这个快捷键就能自动添加必要的引入，无需手动搜索、输入和导入。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bright - 语法高亮的React服务器组件]]></title>
        <id>https://bright.codehike.org/</id>
        <link href="https://bright.codehike.org/"/>
        <updated>2023-06-26T10:56:40.259Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bright.codehike.org/">Bright - Syntax Highlighting React Server Component</a></p><p><strong>概要：</strong></p><p>这篇文章主要讲述了 React 服务器组件用于语法高亮的内容。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023年的React Ecosystem。]]></title>
        <id>https://dev.to/ihteshamulhaq510/react-ecosystem-in-2023-5aj4</id>
        <link href="https://dev.to/ihteshamulhaq510/react-ecosystem-in-2023-5aj4"/>
        <updated>2023-06-26T01:58:53.568Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/ihteshamulhaq510/react-ecosystem-in-2023-5aj4">React Ecosystem in 2023.</a></p><p><strong>概要：</strong></p><p>这篇文章主要介绍了 2023 年的 React 生态系统，包括一些可供学习和成为 React 开发者的库。最近，推出了一款名为 million.js 的工具，它使 React 的速度提高了 70%。对于初学者来说，选择正确的库可能相当具有挑战性。

文章列举了一些 React 库，包括构建工具（如 vite、nextjs、Webpack）、路由（如 react router、tanstack router）、客户端状态管理（如 redux toolkit、zustand）、服务器状态管理（如 tanstack query、redux-toolkit query、Apollo Client、jotai）、表单处理（如 Formik、React Hook Form）、测试（如 Vitest、React Testing library、Play-write）、样式（如 Tailwindcss、Styled-components、Emotion、Bootstrap）、UI 组件库（如 Material UI、Man time UI、Ant Design、Chakra UI、Headless UI (tailwindcss)、DaisyUI (Tailwindcss)、shadcn UI (Tailwindcss)、React Bootstrap）、动画（如 React Spring、Framer motion）、数据可视化（如 Victory charts、React Charts js、Recharts）、表格（如 Tanstack table）、国际化（如 react-i18next、formatjs）以及开发工具（如 react developer tools、Redux dev tool、testing playground、react hook form dev tools、AxeDev Tool (Accessibility)、Tanstack query dev tools）。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第四部分：编写简洁高效的React代码--最佳实践和优化技术]]></title>
        <id>https://dev.to/sathishskdev/part-4-writing-clean-and-efficient-react-code-best-practices-and-optimization-techniques-423d</id>
        <link href="https://dev.to/sathishskdev/part-4-writing-clean-and-efficient-react-code-best-practices-and-optimization-techniques-423d"/>
        <updated>2023-06-26T01:58:29.603Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/sathishskdev/part-4-writing-clean-and-efficient-react-code-best-practices-and-optimization-techniques-423d">Part 4: Writing Clean and Efficient React Code- Best Practices and Optimization Techniques</a></p><p><strong>概要：</strong></p><p>本文是 "2023 年 React 最佳实践" 系列的第四部分，探讨了如何编写清晰、高效的 React 应用程序代码。以下是一些最佳实践：

1. 实现错误边界来优雅地处理组件错误。
2. 对于功能组件，使用 React.memo 以避免不必要的重渲染。
3. 使用 Linting 工具（如 ESLint）来提高代码质量和一致性。
4. 避免默认导出，因为它可能使理解哪些组件被导入和在其他文件中使用变得困难。
5. 使用对象解构，这是一种更简洁、优雅的方式来提取对象属性。
6. 使用片段来避免在渲染多个元素时产生不必要的包装 div。
7. 优先传递对象而不是多个 props。
8. 使用箭头函数，它提供了更简洁的语法和词法范围。
9. 使用枚举代替数字或字符串。
10. 对布尔 props 使用简写。
11. 避免使用索引作为 key props。
12. 在小函数中使用隐式返回。
13. 使用 PropTypes 进行类型检查。
14. 优先使用模板文字。
15. 避免使用庞大的组件。

以上最佳实践可以提高代码的可维护性、性能和可读性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[跟大家聊聊当下卖课的现状]]></title>
        <id>https://blog.meathill.com/share/lets-talk-about-be-a-tutorial-video-creator.html</id>
        <link href="https://blog.meathill.com/share/lets-talk-about-be-a-tutorial-video-creator.html"/>
        <updated>2023-06-25T13:52:19.567Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.meathill.com/share/lets-talk-about-be-a-tutorial-video-creator.html">跟大家聊聊当下卖课的现状</a></p><p><strong>概要：</strong></p><p>文章作者分享了他在制作在线课程方面的经验。首先，他提到了平台分成问题，大部分平台会收取 50% 的服务费，再加上苹果设备用户需要支付 30% 的税，最终讲师能拿到的收入并不多。其次，课程内容的选择也是一个问题，新人讲师往往无法接到热门选题，而自己感兴趣的选题可能平台不愿意接受。此外，如果想自行销售课程，除非有大量的粉丝基础，否则难以获得成功。最后，由于网络技术更新快速，课程的生命周期较短，因此很难实现稳定的收入。总的来说，作者建议想做在线课程的人在开始前应该仔细考虑各种因素，找出更适合自己的方向。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React中的远程传输：定位、堆叠上下文和传送门]]></title>
        <id>https://www.developerway.com/posts/positioning-and-portals-in-react</id>
        <link href="https://www.developerway.com/posts/positioning-and-portals-in-react"/>
        <updated>2023-06-25T13:45:53.262Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developerway.com/posts/positioning-and-portals-in-react">Teleportation in React: Positioning, Stacking Context, and Portals</a></p><p><strong>概要：</strong></p><p>这篇文章详细讨论了 CSS 定位的工作原理，堆叠上下文（Stacking Context）是什么，如何使用 CSS 逃离 overflow:hidden，为什么我们不能用 CSS 做所有事情而需要 Portals，以及 Portals 是如何工作的。文章首先解释了 CSS 的绝对定位，并指出绝对并不完全是绝对的，它实际上是相对于设置了任何值的最近元素的位置。然后，文章介绍了堆叠上下文，这是一个三维的视角来看待 HTML 元素。接着，文章讨论了如何使用 CSS 逃离内容剪裁，为什么我们不能用 CSS 做所有事情而需要 Portals，以及 Portals 是如何实际工作的。文章还深入探讨了 React Portal 如何解决这个问题，以及 React 生命周期，重渲染，Context 和 Portals 之间的关系。最后，文章总结了在使用 Portals 时的规则：在 React 中发生的事情保持在 React 层次结构中，在 React 之外的事情遵循 DOM 结构规则。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - a16z-infra/ai-getting-started：一个用于周末项目的Javascript AI入门栈，包括图像/文本模型、矢量存储、授权和部署配置。]]></title>
        <id>https://github.com/a16z-infra/ai-getting-started</id>
        <link href="https://github.com/a16z-infra/ai-getting-started"/>
        <updated>2023-06-25T13:45:22.332Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/a16z-infra/ai-getting-started">GitHub - a16z-infra/ai-getting-started: A Javascript AI getting started stack for weekend projects, including image/text models, vector stores, auth, and deployment configs</a></p><p><strong>概要：</strong></p><p>这篇文章是关于如何开始使用 AI 的指南，包括了一些主要技术栈和操作步骤。技术栈包括 Auth：Clerk、应用逻辑：Next.js、VectorDB：Pinecone / Supabase pgvector、LLM Orchestration：Langchain.js、图像模型：Replicate、文本模型：OpenAI、文本流：ai sdk、部署：Fly 等。

文章详细介绍了如何在本地测试这个技术栈，并理解每个组件的工作方式。首先需要从 Github 账户复制并克隆仓库，然后安装依赖项。接着填写 Clerk Secrets、OpenAI API key、Replicate API key、Pinecone API key 和 Supabase API key。注意，默认情况下，此模板使用 Pinecone 作为向量存储，但你可以轻松开启 Supabase pgvector。

之后，生成嵌入并将其存储在向量数据库中以供未来查询。然后在本地运行应用程序进行测试。最后，将应用程序部署到 fly.io。

此外，文章还介绍了如何为该仓库做出贡献，包括代码贡献工作流程和其他贡献方式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是CDN？内容交付网络的无偏见指南]]></title>
        <id>https://calibreapp.com/blog/content-delivery-networks-guide</id>
        <link href="https://calibreapp.com/blog/content-delivery-networks-guide"/>
        <updated>2023-06-25T13:43:12.424Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://calibreapp.com/blog/content-delivery-networks-guide">What is a CDN? An Unbiased Guide to Content Delivery Networks</a></p><p><strong>概要：</strong></p><p>内容分发网络（CDN）是提高网站性能和可靠性的最佳方式之一。它可以帮助提高页面速度，抵御拒绝服务攻击，并优化内容以实现更快的传输。选择合适的 CDN 对于网站来说是一个重要的决定，因此你需要进行研究。然而，大部分关于 CDN 的搜索结果都来自销售 CDN 的公司，这让人很难相信由销售人员写的博客文章。好消息是我们不销售 CDN，但作为网络性能专家，我们对此有深入了解。我们编写了这篇指南，帮助你在选择 CDN 时做出明智的决定。

CDN 是全球分布的服务器网络，可以托管你的内容并快速将其传送给访问者。CDN 通过减少延迟、提高可靠性，甚至优化内容以实现更快的传输，来支持你的主机服务器。CDN 就像是遍布全球的小型本地仓库。当访问者请求内容时，这些本地仓库从你的中央仓库（主机服务器）接收内容并存储起来。这样，我们可以快速可靠地传输内容，因为 CDN 服务器的位置遍布全球，如果一个服务器出现故障，其他服务器可以接替其工作。

CDN 的工作原理是在全球各地的战略位置拥有服务器，从而更快地为你传送内容。CDN 通过在全球范围内提前存储你的内容来解决这些问题。因此，当有请求时，CDN 会将数据存储在悉尼的服务器上，以便更快地传送到新西兰。

CDN 的好</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布Svelte 4]]></title>
        <id>https://svelte.dev/blog/svelte-4</id>
        <link href="https://svelte.dev/blog/svelte-4"/>
        <updated>2023-06-25T13:40:29.417Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://svelte.dev/blog/svelte-4">Announcing Svelte 4</a></p><p><strong>概要：</strong></p><p>Svelte 4 稳定版已经发布，它主要是一个维护版本，提升了性能，改进了开发者体验，并对网站进行了更新。Svelte 4 的包大小减少了近 75%，从 10.6MB 降到 2.8MB，这意味着在执行 npm install 时等待时间更短。此外，Svelte 的依赖项数量也从 61 个大幅度减少到 16 个，这不仅可以加快用户的下载速度，还可以降低供应链攻击的风险。对于 Web 组件的使用者来说，最大的变化是改变了使用 Svelte 来创建自定义元素的方式。此外，Svelte 4 还改进了 IDE 编写体验，更新了官方网站、文档和教程，并为即将发布的 Svelte 5 做好了准备。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 5.2的新关键词："using"。]]></title>
        <id>https://www.totaltypescript.com/typescript-5-2-new-keyword-using</id>
        <link href="https://www.totaltypescript.com/typescript-5-2-new-keyword-using"/>
        <updated>2023-06-25T13:23:00.586Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.totaltypescript.com/typescript-5-2-new-keyword-using">TypeScript 5.2's New Keyword: 'using'</a></p><p><strong>概要：</strong></p><p>TypeScript 5.2 将引入一个新的关键字 - 'using'，你可以用它在离开作用域时处理任何带有 Symbol.dispose 函数的东西。

这基于 TC39 提案，该提案最近达到了第 3 阶段，表明它将被引入 JavaScript。'using' 对于管理诸如文件句柄、数据库连接等资源将非常有用。

Symbol.dispose 是 JavaScript 中的一个新的全局符号。任何赋予 Symbol.dispose 函数的东西都会被视为一个 “资源” - “具有特定生命周期的对象”，并可以与 using 关键字一起使用。

你还可以使用 Symbol.asyncDispose 和 await using 来处理需要异步处理的资源。

这将在继续之前等待 Symbol.asyncDispose 函数。这对于数据库连接等资源非常有用，你希望确保程序继续之前连接已经关闭。

使用案例：

文件句柄：通过节点中的文件处理器访问文件系统可能会因为 using 变得更容易。

数据库连接：管理数据库连接是 C# 中使用 using 的一个常见用例。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[99.9成功率！Mac运行赛博朋克2077，使用Game Porting Toolkit]]></title>
        <id>https://www.bilibili.com/read/cv24310042</id>
        <link href="https://www.bilibili.com/read/cv24310042"/>
        <updated>2023-06-25T13:03:57.380Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.bilibili.com/read/cv24310042">99.9成功率！Mac运行赛博朋克2077，使用Game Porting Toolkit</a></p><p><strong>概要：</strong></p><p>这篇文章主要介绍了如何在苹果 M 芯片 Mac 上运行赛博朋克 2077 游戏。首先，需要通过 Game Porting Toolkit 工具将 Direct3D 指令转译成 Metal 指令，使得 Windows 游戏能够在 Apple Silicon Mac 上运行。然后，作者详细介绍了准备所需资源、安装 macOS14 Beta、安装 Game Porting Toolkit、配置 Wine Prefix 环境和安装 Steam 等步骤。最后，通过 Wine 直接启动赛博朋克 2077 游戏。全程操作较为复杂，需要耐心且对计算机有一定的了解。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[具有稳定扩散性的风格化二维码]]></title>
        <id>https://antfu.me/posts/ai-qrcode</id>
        <link href="https://antfu.me/posts/ai-qrcode"/>
        <updated>2023-06-25T12:42:53.686Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/ai-qrcode">Stylistic QR Code with Stable Diffusion</a></p><p><strong>概要：</strong></p><p>这篇文章是作者分享如何使用 Stable Diffusion 和 ControlNet 创建一个既可以扫描的 QR 码又是一幅艺术插图的过程。首先，作者介绍了他对 AI 技术的兴趣，并提到了一些重要的工具和模型。然后，他详细描述了创建 QR 码图像的步骤，包括设置环境、生成 QR 码、将文本转化为图像、调整细节和放大图像等。最后，他展示了最终结果并总结了自己的学习经历。作者希望这篇文章能够给读者提供一些基础概念或启发他们开始自己的创作之旅。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工人们的KV在新的架构下比以前更快]]></title>
        <id>https://blog.cloudflare.com/faster-workers-kv-architecture/</id>
        <link href="https://blog.cloudflare.com/faster-workers-kv-architecture/"/>
        <updated>2023-06-21T15:28:20.529Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.cloudflare.com/faster-workers-kv-architecture/">Workers KV is faster than ever with a new architecture</a></p><p><strong>概要：</strong></p><p>Cloudflare 宣布了对 Workers KV 的重大性能改进，这一改进主要集中在显著提高冷读性能和降低延迟，甚至对于长尾访问模式也是如此。开发人员使用 KV 时，热读取性能很好，但他们会问为什么他们的 95% 分位延迟 —— 通常是在一个关键（或一组关键）上，这个关键最近没有被访问过或者在该地区没有被访问过 —— 比预期的要高。因此，Cloudflare 已经在幕后为 KV 开发了一个新的缓存层，使客户能够实现更频繁的热读取，减少最差情况下的延迟时间，更好地控制缓存 TTL，并且比以前的版本快得多。最好的部分是，使用 KV 的开发人员不需要改变任何东西就可以从这种增强的性能中受益。

Workers KV 是 Cloudflare 网络支持的针对读取密集型用例和应用程序设计的键值存储。KV 专注于读取密集型用例，使其能够在毫秒内提供热（缓存）读取，这使其成为存储每个应用程序或客户配置数据、路由配置、多变量（A/B 测试）配置，甚至需要快速提供的小资产数据的理想选择。你可以将任何可以序列化并且需要快速获取的东西存储在 KV 中，每个单独的键可以存储高达 25 MiB 的数据，总数据存储没有上限。

Cloudflare 已经重新设计了 Workers KV，由新的分层缓存实现驱动。这个实现是作为 Worker 服务编写的。我们重用了为平</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么快速工作比它看起来更重要 " jsomers.net博客]]></title>
        <id>http://jsomers.net/blog/speed-matters</id>
        <link href="http://jsomers.net/blog/speed-matters"/>
        <updated>2023-06-21T02:03:05.204Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="http://jsomers.net/blog/speed-matters">Why working quickly is more important than it seems « the jsomers.net blog</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了工作效率的重要性。作者指出，快速工作不仅可以在单位时间内完成更多的工作，而且会使新任务在你的心中看起来成本更低，因此你会倾向于做更多的事情。相反，如果你做事慢，那么你可能会继续保持这种状态，因为提高速度的唯一方法就是多做。

作者还发现，如果他能快速回复人们的邮件，他们就会给他发送更多的邮件。这是因为发件人期望得到回复，这种期待促使他们写信。换句话说，速度本身就能吸引他们发邮件，因为他们知道自己的努力会有回报。

同样，网站响应速度慢会导致用户流失。谷歌以其搜索速度著名，他们意识到如果搜索速度快，你就更可能去搜索。原因是它鼓励你尝试，得到反馈，然后再次尝试。当你想到一个问题时，你知道谷歌已经在那里了。没有思考和行动之间的延迟，没有失去寻找答案的冲动。谷歌搜索的预计成本几乎为零，它感觉就像你思维的延伸。

此外，如果你想做某件事并且变得擅长 —— 比如写作或修复错误 —— 你应该试着更快地去做。这并不意味着草率行事，但确实意味着，你需要推动自己比你认为健康的速度更快。因为这样，任务在你的心中的成本会</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杀人社区]]></title>
        <id>https://www.marginalia.nu/log/82_killing_community/</id>
        <link href="https://www.marginalia.nu/log/82_killing_community/"/>
        <updated>2023-06-21T02:02:07.939Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.marginalia.nu/log/82_killing_community/">Killing Community</a></p><p><strong>概要：</strong></p><p>这篇文章主要探讨了社交媒体平台的发展模式，以及这种模式对在线社区的影响。作者将在线社区比作一个村庄，其中有熟悉的面孔、集体经验和共享价值观等。然而，当这些 “村庄” 不能承受持续大量的陌生人涌入时，它们就会变得不再像村庄，更像是火车站，人们来来去去，没有真正的归属感。在这样的环境中，人们总是保持警惕，因为他们总是在与陌生人打交道。这种环境是压抑的，使人感到孤立无援，无力改变。作者认为，如果你想彻底摧毁一个关于建立社区和结识新朋友的网站，那么就让这个网站和所有的社区尽可能地增长。这样，你会得到一个每个人都是陌生人的地方，粗鲁成为常态，没有归属感。最后，作者提出，对 Reddit 这类社区型网站来说，停止增长甚至稍微缩小规模可能是最好的选择，这将使社区能够稳定下来，重新变得像村庄一样，从社区的角度看，网站将因此变得更好。但从商业角度看，这是一个真正的困境，因为唯一赚钱的方式就是增长，而唯一增长的方式就是破坏社区。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TIL: 无效的CSS循环依赖和有效的空回退值，使用裸逗号| pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/til-invalid-css-cyclic-dependencies-and-a-valid-empty-fallback-value-using-a-bare-comma/</id>
        <link href="https://pawelgrzybek.com/til-invalid-css-cyclic-dependencies-and-a-valid-empty-fallback-value-using-a-bare-comma/"/>
        <updated>2023-06-21T01:29:20.588Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/til-invalid-css-cyclic-dependencies-and-a-valid-empty-fallback-value-using-a-bare-comma/">TIL: invalid CSS cyclic dependencies and a valid empty fallback value using a bare comma | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>今天我阅读了 Roman Komarov 的一篇名为 “Cyclic Dependency Space Toggles” 的文章，这是我近期阅读过的最令人费解的 CSS 文章之一。它让我思考了我们在过去几年中探索的所有使用 CSS 自定义属性的模式，以及我们还有多少需要发现的。我从这篇文章中学到了两个令人兴奋的概念，让我与你们分享一下。

无效的循环依赖
当自定义属性相互引用时，循环中的所有自定义属性都是无效的。规范中的一个引述：这可能会产生循环依赖性，其中一个自定义属性使用 var () 引用自身，或者两个或更多的自定义属性试图相互引用。[…] 如果依赖关系图中存在循环，那么循环中的所有自定义属性在计算值时都是无效的。

有效的空回退值使用裸逗号
如果传递给 var () 函数的初始值缺失或无效，但其后跟着一个裸逗号，则计算值为有效的空回退值。规范中的解释是：[…] 一个裸逗号，后面没有任何东西，必须被视为在 var () 中有效，表示一个空的回退值。

这两个概念如何有用？
如果你想知道这些对你有何帮助，我建议你阅读 Roman 的文章，该文提出了一个强大的值切换用例。当然，这不是利用自定义属性的有效 / 无效评估的唯一方式。看看这个简化的例子。

--color 自定义属性的值决定了 --is-default, --is-red 和 --is-green 的有效性。然后，应用相应的背景颜色回退值（灰色，</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[万维网联盟宣布在线支付的新网络标准]]></title>
        <id>https://www.applemust.com/w3c-announces-new-web-standard-for-online-payments/</id>
        <link href="https://www.applemust.com/w3c-announces-new-web-standard-for-online-payments/"/>
        <updated>2023-06-21T01:28:09.161Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.applemust.com/w3c-announces-new-web-standard-for-online-payments/">W3C announces new Web standard for online payments</a></p><p><strong>概要：</strong></p><p>世界广域网联盟（W3C）宣布了一种新的网络标准，这是一种新的浏览器能力，有助于简化用户认证并在网页结账时提高支付安全性。该标准名为 “安全支付确认”（SPC），可以帮助商家、银行、支付服务提供商、卡网络等降低强大客户认证的摩擦，并产生用户同意的密码证据，这两者都是欧洲支付服务指令（PSD2）等监管要求的重要方面。目前，该标准已经作为候选建议可用，这意味着功能集是稳定的，并且已经得到了广泛的审查。

W3C 表示，该标准的创建是为了应对基于网络的电子商务的增加以及随之而来的支付欺诈的增加。自 2019 年以来，W3C 一直在开发安全支付确认，以帮助实现强大的客户认证要求，同时降低结账摩擦。Stripe 进行了一个早期实施 SPC 的试点，并在 2020 年 3 月报告称，与一次性密码（OTP）相比，SPC 认证使转化率增加了 8%，同时结账速度提高了 3 倍。

安全支付确认不仅适用于卡支付。网络支付工作组定期讨论如何将 SPC 整合到其他支付生态系统中，如开放银行、巴西的 PIX 以及专有支付流程中。目前，SPC 在 MacOS、Windows 和 Android 上的 Chrome 和 Edge 中可用。在候选推荐期间，网络支付工作组将寻求在其他浏览器和环境中实施 —— 考虑到苹果在 W3C 和 FIDO 的参与，S</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简介]]></title>
        <id>https://vinejs.dev/docs/introduction</id>
        <link href="https://vinejs.dev/docs/introduction"/>
        <updated>2023-06-21T01:27:27.486Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vinejs.dev/docs/introduction">Introduction</a></p><p><strong>概要：</strong></p><p>VineJS 是一个用于 Node.js 的表单数据验证库，可用于验证后端应用中的 HTTP 请求体。它是 Node.js 生态系统中最快的验证库之一，并提供运行时和静态类型安全性。VineJS 专为验证表单数据和 JSON 负载而构建，支持自定义错误消息和格式化错误，并附带 50 多个验证规则和 12 种模式类型。你可以向 VineJS 添加自定义规则和模式类型，我们还让测试自定义验证规则变得非常简单。

在与 Yup、Zod 和 VineJS 验证一个简单对象的性能比较中，VineJS 是最快的。在验证 HTTP 请求体的情况下，VineJS 的性能比 Zod 好 5 倍到 10 倍，处理了许多 HTML 表单序列化的怪癖（Zod 没有），并为定义自定义错误消息和格式化错误提供了更好的工作流程。

然而，VineJS 不是一个通用的验证库，因此你不能用它来验证 JavaScript 数据类型，如函数、映射或集合。VineJS 是在 Node.js 运行时环境中使用的后端环境，因此你不能在浏览器内运行它。

VineJS 是由 Harminder Virk 最初创建的独立开源项目，由 AdonisJS 核心团队维护。VineJS 是现有的 AdonisJS 验证器代码库的改进版本，作为一个独立的库发布，以便与任何 Node.js 项目一起工作。该项目通过 Github 赞助商资助，如果你或你的企业从 VineJS 中获益，请考虑赞助我们以支持项目的开发。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SvelteKit的新功能：轻松优化你的应用程序 - Vercel]]></title>
        <id>https://vercel.com/blog/feature-complete-sveltekit</id>
        <link href="https://vercel.com/blog/feature-complete-sveltekit"/>
        <updated>2023-06-21T01:24:36.768Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/feature-complete-sveltekit">New features for SvelteKit: Optimize your application with ease – Vercel</a></p><p><strong>概要：</strong></p><p>Svelte 已经在 Web 开发框架的世界中崭露头角，这要归功于其将组件转化为优化的 JavaScript 模块的独特方法。这种创新的渲染应用程序的方式消除了传统框架中存在的开销，从而提高了应用程序的性能和效率。随着 SvelteKit 1.0 的发布，开发者可以充分利用全栈 Svelte 的强大功能，而不必担心会产生破坏性的改变。此外，SvelteKit 还在不断发展，提供了一套强大的功能，并与各种部署环境（包括 Vercel）无缝集成。Vercel 采用了基于框架定义的基础设施（FDI），并已经接纳了 SvelteKit，最近添加了对每个路由的无服务器和边缘函数配置、增量静态再生（ISR）以及与一系列 Vercel 产品更容易兼容的支持。在本文中，我们将探讨如何使您的应用程序更具性能，可扩展性和用户友好性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布v0.18.5 - evanw/esbuild]]></title>
        <id>https://github.com/evanw/esbuild/releases/tag/v0.18.5</id>
        <link href="https://github.com/evanw/esbuild/releases/tag/v0.18.5"/>
        <updated>2023-06-21T01:12:29.081Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/evanw/esbuild/releases/tag/v0.18.5">Release v0.18.5 · evanw/esbuild</a></p><p><strong>概要：</strong></p><p>这个版本实现了即将出现的 JavaScript 装饰器提案中的新的自动访问器语法。这种语法尚未成为 JavaScript 的一部分，但已在 TypeScript 4.9 版本中加入。如果目标设置为除 esnext 之外的其他内容，将会对自动访问器进行转换。现在也可以在 esbuild 的 TypeScript 实验性装饰器转换中使用自动访问器，行为应与装饰底层 getter/setter 对相同。

此版本还使 esbuild 现在从即将出现的 JavaScript 装饰器提案中解析装饰器，并将它们原样传递到输出（只要语言目标设置为 esnext）。还没有实现将 JavaScript 装饰器转换为不支持它们的环境。目前 esbuild 实现的唯一装饰器变换仍然是 TypeScript 实验性装饰器变换，这只在.ts 文件中工作，并且需要在你的 tsconfig.json 文件中设置 "experimentalDecorators": true。

此外，如果可能，现在使用静态块来使用具有赋值语义的静态字段。以前，这是通过从类体中移除字段并在类声明后添加赋值语句来完成的。但是，这也导致任何私有字段也必须降低（以防字段初始化器使用私有符号，直接或间接）。此版本将此转换更改为使用内联静态块（如果支持的话），这避免了在此场景中需要降低私有字段。

最后，修复了 TypeScript 实验性装饰器与 --mangle-props 设置结合使用时可能导致的崩溃问题。现在可以安全地将这两个功能结合在一起使用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍一下HTTP/3的优先次序]]></title>
        <id>https://blog.cloudflare.com/better-http-3-prioritization-for-a-faster-web/</id>
        <link href="https://blog.cloudflare.com/better-http-3-prioritization-for-a-faster-web/"/>
        <updated>2023-06-21T01:11:42.840Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.cloudflare.com/better-http-3-prioritization-for-a-faster-web/">Introducing HTTP/3 Prioritization</a></p><p><strong>概要：</strong></p><p>今天，Cloudflare 宣布全面支持 HTTP/3 可扩展优先级，这是一种新的标准，可以将网页的加载速度提高高达 37%。Cloudflare 与标准构建者紧密合作，帮助形成 HTTP/3 优先级的规范，并很高兴能推动网络前进。HTTP/3 可扩展优先级适用于 Cloudflare 的所有计划。对于付费用户，有一个增强版本可进一步提高性能。网页由许多必须在处理和呈现给用户之前下载的对象组成。并非所有对象对网页性能的重要性都相等。HTTP 优先级的作用是在最适当的时机加载正确的字节，以实现最佳结果。在多个对象都在竞争同一受限资源时，优先级最为重要。在 HTTP/3 中，这个资源就是 QUIC 连接。在大多数情况下，从服务器到客户端的带宽是瓶颈。选择将带宽分配给哪些对象，或在哪些对象之间共享带宽，是网页性能的关键基础。如果出现错误，我们在其上构建的其他优化可能会受到影响。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NestJS v10现已上市 - Trilon Consulting]]></title>
        <id>https://trilon.io/blog/nestjs-10-is-now-available</id>
        <link href="https://trilon.io/blog/nestjs-10-is-now-available"/>
        <updated>2023-06-21T01:11:00.769Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://trilon.io/blog/nestjs-10-is-now-available">NestJS v10 is now available - Trilon Consulting</a></p><p><strong>概要：</strong></p><p>NestJS 10 正式发布，带来了许多错误修复、改进和新功能。其中最令人兴奋的新特性包括对 SWC（Speedy Web Compiler）的支持，这是一个可用于编译和打包的基于 Rust 的可扩展平台，使用 SWC 与 Nest CLI 可以显著加快开发过程；测试中模块的覆盖功能，这在需要模拟整个模块而不是单独模拟每个提供者时非常有用；对 Redis 通配符订阅的支持，该功能允许你订阅所有匹配给定模式的消息；CacheModule 已从 @nestjs/common 包中移除，并作为独立包 @nestjs/cache-manager 提供；此外，NestJS 10 不再支持 Node.js v12，而需要 Node.js v16 或更高版本。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - dtinth/superwhite: 在支持HDR的显示器上显示非常明亮的白色]]></title>
        <id>https://github.com/dtinth/superwhite</id>
        <link href="https://github.com/dtinth/superwhite"/>
        <updated>2023-06-21T01:10:35.940Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/dtinth/superwhite">GitHub - dtinth/superwhite: display a very bright white color on HDR-enabled displays</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了如何在支持 HDR 的显示器上展示非常亮的白色。通过使用 Final Cut Pro 创建一个带有宽色域 HDR 颜色处理设置的库，然后创建一个项目，添加一个纯白色的颜色生成器，并将其设置为亮白色，同时将图形 HDR 级别调整到 100。接着添加 HDR 工具视频效果，将模式设置为 SDR 到 HDR (PQ)，并将峰值亮度调整到 5000 尼特。最后用 HEVC 10 位作为编解码器导出视频。若在支持 HDR 的 Mac 显示器或者最新的 iPhone 或 iPad（低电量模式关闭）上查看此页面，你应该能看到一个比 #ffffff 更亮的白色。在不支持的显示器上，你会看到正常的白色。作者还提醒读者不要滥用这个技术。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你不能相信谷歌]]></title>
        <id>https://world.hey.com/dhh/you-can-t-trust-google-f7d64064</id>
        <link href="https://world.hey.com/dhh/you-can-t-trust-google-f7d64064"/>
        <updated>2023-06-20T04:16:49.440Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://world.hey.com/dhh/you-can-t-trust-google-f7d64064">You can't trust Google</a></p><p><strong>概要：</strong></p><p>文章作者 David Heinemeier Hansson 警告，如果 Google 无法通过广告直接实现数十亿规模的盈利，那么它最终会关闭你关心的每一项服务。他认为，Google 在产品或服务业务中的能力有限，因为这些都不是 Google 的主要收入来源，广告才是。他以客户服务为例，指出 Google 的客户服务一直很差，因为帮助解决 Workspaces 或 Google Cloud Platform 上的问题永远不会像帮助广告商获取注意力那样有利可图。他提到了 Google 刚刚关闭其域名注册商 Google Domains 的事情，尽管这个业务每年可以带来 1.8 亿美元的收入，并服务了 1000 万个域名。此外，他还提到了 Google Home / Nest 的失败案例。他建议，无论是协作、电子邮件还是家庭安全系统，用户最好都有备份计划，因为任何标有 "由 Google 制造" 的产品或服务都可能随时被 Google 放弃。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - kaleidawave/ezno：一个用Rust编写的JavaScript编译器和TypeScript检查器，专注于静态分析和运行时性能。]]></title>
        <id>https://github.com/kaleidawave/ezno</id>
        <link href="https://github.com/kaleidawave/ezno"/>
        <updated>2023-06-17T04:50:19.451Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/kaleidawave/ezno">GitHub - kaleidawave/ezno: A JavaScript compiler and TypeScript checker written in Rust with a focus on static analysis and runtime performance</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了 Ezno，一个用 Rust 编写的 JavaScript 编译器和 TypeScript 检查器，重点关注静态分析和运行时性能。Ezno 是一个 JavaScript 类型检查器，可以作为库使用，也可以与可选的编译器基础设施（解析器、CLI、LSP 等）一起使用。它提供完全类型化的程序，保证类型安全，并旨在通过更好的静态分析实现类型的准确性和追踪。此外，Ezno 还具有命令式类型系统，事件追踪和评估函数副作用。

然而，Ezno 并不是一个二进制可执行文件生成器，它将 JavaScript（或 TS/Ezno 超集）编译为 JavaScript。此过程更像是编译而不是转译。尽管你可以使用其事件 IR 生成一个较低级别的格式，但 Ezno 目前还不能使用，离实用还有很长的路要走。

此外，该项目还包含了一些箱子，如 checker 和 parser 等。同时，作者也邀请读者参与贡献，查看问题并参与讨论。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GPT-4的本地JSON输出]]></title>
        <id>https://yonom.substack.com/p/native-json-output-from-gpt-4</id>
        <link href="https://yonom.substack.com/p/native-json-output-from-gpt-4"/>
        <updated>2023-06-16T05:57:17.063Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://yonom.substack.com/p/native-json-output-from-gpt-4">Native JSON Output From GPT-4</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了 OpenAI 在 2023 年 6 月 13 日发布的新功能 —— 函数调用，该功能使得在产品中集成大型语言模型（LLMs）时生成结构化数据（如 JSON）变得更简单。文章通过一个名为 “食谱创建器” 的演示应用来说明这个新功能的使用方法和优点。

新 API 引入了两个新参数：functions（一个包含可供 GPT 使用的函数数组，每个函数都有名称、描述和参数的 JSON Schema）和 function_call（可选地指定无或 { "name": "<function_name>" }，可以强制 GPT 使用特定函数，或明确禁止调用任何函数）。通过设置 function_call 参数，你可以从 GPT 调用中可靠地获取 JSON 响应，而不再是字符串。

此外，新 API 还改变了我们与 OpenAI LLMs 交互的方式，除了明显的插件使用案例外，还可以生成 JSON 输出。以前需要通过提示工程来完成这一步骤，但这种方法对于简单的情况效果良好，但容易出错。现在，通过对大型语言模型的低级访问，你可以做得更好。例如，通过降低令牌使用，可以使 API 调用更快、更便宜。

最后，作者认为新 API 的另一个优点是减少了生成正确输出所需的提示工程，使得 LLMs 更容易作为无代码后端使用。并且，OpenAI 的 API 似乎支持 JSON Schema 的特性，如 #ref（递归）和 oneOf（多选），意味着你应该能够在单个 API 请求中通过 JSON schema 实现更复杂的代理和递归思考过程。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布Tauri 1.4.0 | Tauri Apps]]></title>
        <id>https://tauri.app/blog/2023/06/14/tauri-1-4/</id>
        <link href="https://tauri.app/blog/2023/06/14/tauri-1-4/"/>
        <updated>2023-06-16T04:46:06.846Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tauri.app/blog/2023/06/14/tauri-1-4/">Announcing Tauri 1.4.0 | Tauri Apps</a></p><p><strong>概要：</strong></p><p>Tauri 团队宣布推出 1.4 版本。这个版本包括了一些新功能和重要的错误修复，比如 CLI 补全、单元测试能力和 Windows 安装程序的改进。确保更新 NPM 和 Cargo 依赖到 1.4.0 版本。Tauri CLI 现在可以为 Bash、Zsh、PowerShell 和 Fish 生成 shell 补全。窗口的最大化、最小化和关闭按钮现在可以通过配置或 API 调用来禁用。1.4.0 版本包括了几项 NSIS 捆绑增强：自定义语言文件、自定义安装模板（.nsi 文件）、支持荷兰语、日语、韩语、波斯语、瑞典语和土耳其语等。如果你的应用程序是通过 WiX 安装的，安装程序会提示用户卸载它。Tauri 1.4 仍然支持 Rust 1.60 版本，但由于一些依赖性不兼容问题，我们不再固定 time, ignore, 和 winnow crate 的补丁版本。tauri crate 现在在 test Cargo feature 下暴露了 test 模块。这个模块还不稳定，但允许你通过创建一个可以在不生成窗口的情况下执行的 tauri::App 实例来对你的应用程序进行单元测试。从 v1.4.0 开始，我们的更新日志格式已经得到了改进。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fresh 1.2 - 欢迎全职维护者，在岛屿之间共享状态，有限的npm支持，以及更多]]></title>
        <id>https://deno.com/blog/fresh-1.2</id>
        <link href="https://deno.com/blog/fresh-1.2"/>
        <updated>2023-06-16T04:45:27.494Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/fresh-1.2">Fresh 1.2 – welcoming a full-time maintainer, sharing state between islands, limited npm support, and more</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了 Fresh 1.0，一种现代化、以 Deno 为首的全栈 Web 框架。自去年推出以来，Fresh 在 GitHub 上获得了大量的关注，并取得了显著的增长。然而，对于 Deno 团队是否会持续维护 Fresh，人们一直有疑问。尽管团队一直表示会坚定不移地维护，但现实情况更为复杂。由于主要维护者没有足够的时间专注于 Fresh，因此很多问题得不到及时解决。

为了改变这种情况，团队找到了新的主要维护者 Marvin Hagemeister，他是 Preact 的维护者和 Preact DevTools 的构建者。他将全职领导 Fresh 项目的开发。预计在未来几个月内，Fresh 在易用性、功能、性能和项目维护等方面都将有显著的提升。

最后，文章介绍了 Fresh 1.2 的一些亮点特性，包括传递信号、Uint8Arrays 和循环数据到岛屿属性，支持自定义 HEAD 处理器，HandlerContext.render 的状态和头部覆盖，./islands 文件夹中的子目录，异步插件渲染，简化 Fresh 项目的测试等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js中的调试介绍]]></title>
        <id>https://blog.openreplay.com/an-introduction-to-debugging-in-nodejs/</id>
        <link href="https://blog.openreplay.com/an-introduction-to-debugging-in-nodejs/"/>
        <updated>2023-06-16T04:44:13.520Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.openreplay.com/an-introduction-to-debugging-in-nodejs/">An introduction to debugging in Node.js</a></p><p><strong>概要：</strong></p><p>本文主要讲解了 Node.js 的调试技巧。Node.js 是一种使用 Google Chrome 浏览器的 V8 引擎的流行 JavaScript 运行时，可用于创建服务器端 Web 应用、构建工具、命令行应用等。然而，当代码出现问题时，情况就不那么明朗了。调试是修复软件缺陷的艺术，找到错误原因可能需要花费大量时间。

为避免错误，作者提出了以下建议：使用带有行号、颜色编码、linting、自动完成、括号匹配、参数提示等功能的好的代码编辑器；使用像 Git 这样的源代码控制系统来管理代码修订；采用像 Jira、FogBugz 或 Bugzilla 这样的 bug 跟踪系统；使用测试驱动开发（TDD）；尝试代码解释或配对编程等技术与其他开发人员合作。

此外，文章还介绍了如何通过环境变量、命令行选项、控制台日志、Node.js V8 检查器以及 VS Code 等方式进行 Node.js 调试。最后，文章还提供了一份关于调试的术语表，以帮助读者更好地理解调试过程中可能遇到的各种专业术语。</p>]]></content>
    </entry>
</feed>