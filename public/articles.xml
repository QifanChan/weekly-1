<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-05-22T02:14:51.284Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[健康学习到150岁 - 人体系统调优不完全指南]]></title>
        <id>https://github.com/zijie0/HumanSystemOptimization</id>
        <link href="https://github.com/zijie0/HumanSystemOptimization"/>
        <updated>2023-05-22T02:14:38.416Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/zijie0/HumanSystemOptimization">健康学习到150岁 - 人体系统调优不完全指南</a></p><p><strong>概要：</strong></p><p>本文介绍了神经科学教授 Andrew Huberman 的一些关于提升日常工作、学习表现的方法和工具。其中睡眠是最重要的前提，生物钟对睡眠的控制机理是光照和体温。因此，控制接收光照的时间点、类型和时长以及保持适当的体温可以提升睡眠质量。其他实践包括锻炼、饮食、呼吸和注意力训练等方面。这些方法都基于高质量、peer reviewed 的科学研究成果，可以像调优软件程序那样来 “调优” 我们自身的人体系统。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React服务器组件、Next.js应用程序路由器和实例]]></title>
        <id>https://addyosmani.com/blog/react-server-components-app-router/</id>
        <link href="https://addyosmani.com/blog/react-server-components-app-router/"/>
        <updated>2023-05-22T01:58:11.076Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/react-server-components-app-router/">React Server Components, Next.js App Router and examples</a></p><p><strong>概要：</strong></p><p>本文介绍了 React 社区最近关于 Server Components、Next.js App Router 和工具与渲染方法未来的讨论，以及对这些概念的简要总结。文章解释了什么是 React Server Components，它们与 Next.js App Router 的关系，以及为什么选择生产框架（如 Next.js 或 Remix）而不是 Create React App。文章还提到了 RSC 实现的可用性和 “混合” 渲染的趋势，即将构建时间、服务器和客户端渲染相结合，创造更灵活的 Web 开发方法。最后，文章推荐了一些 RSC + Next App Router 的示例。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[把Python当作Rust来写]]></title>
        <id>https://kobzol.github.io/rust/python/2023/05/20/writing-python-like-its-rust.html</id>
        <link href="https://kobzol.github.io/rust/python/2023/05/20/writing-python-like-its-rust.html"/>
        <updated>2023-05-22T01:57:30.687Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://kobzol.github.io/rust/python/2023/05/20/writing-python-like-its-rust.html">Writing Python like it's Rust</a></p><p><strong>概要：</strong></p><p>本文介绍了作者在使用 Rust 后如何将其中的一些概念应用到 Python 编程中，以提高程序的严谨性和可读性。具体来说，作者建议在函数签名和类属性中尽可能使用类型提示，使用 dataclass 代替元组或字典，使用 union type 模拟 Rust 中的 algebraic data types，使用 newtype 提高代码的可读性，使用构造函数代替 __init__ 方法，并使用类型系统来编码不变量。通过这些方法，作者认为可以减少代码中的错误和 bug，提高代码的可维护性和可扩展性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[来自其他语言和框架的模式来增强你的前端项目]]></title>
        <id>https://hackernoon.com/patterns-from-other-languages-and-frameworks-to-enhance-your-frontend-projects</id>
        <link href="https://hackernoon.com/patterns-from-other-languages-and-frameworks-to-enhance-your-frontend-projects"/>
        <updated>2023-05-22T01:55:36.453Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://hackernoon.com/patterns-from-other-languages-and-frameworks-to-enhance-your-frontend-projects">Patterns from Other Languages and Frameworks to Enhance Your Frontend Projects</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了作者在编程过程中学到的一些规则、工具和模式，以及如何将它们应用到前端项目中。作者分享了他对这些规则的理解和使用方法，并提供了一些实用的技巧和建议。通过这篇文章，读者可以学习到如何提高前端项目的质量和效率。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[了解React并发性]]></title>
        <id>https://www.bbss.dev/posts/react-concurrency/</id>
        <link href="https://www.bbss.dev/posts/react-concurrency/"/>
        <updated>2023-05-22T01:52:46.884Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.bbss.dev/posts/react-concurrency/">Understanding React Concurrency</a></p><p><strong>概要：</strong></p><p>React v18.0 引入了一项期待已久的功能：并发模式！尽管有大量资源解释如何使用它，但对其工作原理的解释很少。基本上，React 并发模式是重新设计渲染过程，使得在渲染下一个视图时，当前视图保持响应性。由于这是一项低级特性，理解 React 的并发模式的想法并不关键，但也无妨。React 团队最初计划通过并发模式来提高应用程序性能，但由于向后兼容性原因，该计划未能实现，转而推出了一组新 API，即并发特性，以选择性地启用并发渲染。目前，React 已经引入了两个新钩子来选择并发渲染：useTransition 和 useDeferredValue。这篇文章介绍了这两个钩子的用法和注意事项，并提到了它们在 Suspense 组件中的作用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工人浏览器渲染API进入公开测试阶段]]></title>
        <id>https://blog.cloudflare.com/browser-rendering-open-beta/</id>
        <link href="https://blog.cloudflare.com/browser-rendering-open-beta/"/>
        <updated>2023-05-22T01:44:09.461Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.cloudflare.com/browser-rendering-open-beta/">Workers Browser Rendering API enters open beta</a></p><p><strong>概要：</strong></p><p>Cloudflare 宣布开放其 Workers Browser Rendering API 的公测，该 API 允许开发者编程控制和交互无头浏览器实例，并为应用程序和产品创建自动化流程。通过 Wrangler 命令行工具配置、构建和部署应用程序，开发者可以使用 Browser Rendering API 绑定与 Cloudflare 开发平台上的资源进行交互。此外，Cloudflare 还推出了 Puppeteer，这是一个流行的库，它抽象了低级别的 DevTools 协议，提供了高级 API，使开发者能够轻松地操纵 Chrome/Chromium 并自动化浏览会话。在未来，Cloudflare 将更新 Puppeteer 以匹配其基础设施中运行的 Chromium 实例版本。该公司表示，他们已经广泛使用 Browser Rendering API 进行屏幕截图、测试 Web 应用程序等任务，而且还计划将其用于 URL 扫描器等项目。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你可能不需要React Query]]></title>
        <id>https://tkdodo.eu/blog/you-might-not-need-react-query</id>
        <link href="https://tkdodo.eu/blog/you-might-not-need-react-query"/>
        <updated>2023-05-21T07:32:00.451Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tkdodo.eu/blog/you-might-not-need-react-query">You Might Not Need React Query</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了 React Server Components 是否会取代 React Query。作者认为，每个工具都应该帮助我们解决我们遇到的问题。传统上，React 在数据获取方面并不强调如何处理，这就是 React Query 和 swr 等库产生的原因。随着服务端渲染的出现，React Query 也扮演了重要的角色。但是，随着 React Server Components 的出现，如果您的数据获取仅发生在服务器上，那么您可能不需要 React Query。作者认为，在新的 Server Components 世界中，React Query 仍然可以很好地与应用程序集成。最后，作者提醒读者，不要盲目追随新技术，一切都有权衡。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nuxt 3.5 - Nuxt]]></title>
        <id>https://nuxt.com/blog/v3-5</id>
        <link href="https://nuxt.com/blog/v3-5"/>
        <updated>2023-05-19T01:04:44.665Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nuxt.com/blog/v3-5">Nuxt 3.5 · Nuxt</a></p><p><strong>概要：</strong></p><p>Nuxt 3.5.0 发布了，带来了许多令人兴奋的功能，特别是在类型支持方面。此外还有 Nitropack v2.4 和丰富的 JSON 负载等更新。Nuxt 3.5.0 还支持交互式服务器组件、环境配置、完全类型化页面和 “捆绑器” 模块解析等功能。除此之外，该版本还修复了一些错误和问题。建议升级到最新版本，并阅读完整的发行说明和变更日志。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 TypeScript 5.1 RC - TypeScript]]></title>
        <id>https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-rc/</id>
        <link href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-rc/"/>
        <updated>2023-05-19T00:31:59.629Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-rc/">Announcing TypeScript 5.1 RC - TypeScript</a></p><p><strong>概要：</strong></p><p>TypeScript 5.1 has been released as a Release Candidate, with no further changes expected before the stable release apart from critical bug fixes. The new version includes easier implicit returns for undefined-returning functions, unrelated types for getters and setters, decoupled type-checking between JSX elements and JSX tag types, namespaced JSX attributes, and more. TypeScript 5.1 also supports linked cursors for JSX tags, snippet completions for @param JSDoc tags, and optimizations such as avoiding unnecessary type instantiation and negative case checks for union literals. However, there are also breaking changes, such as ES2020 and Node.js 14.17 being minimum runtime requirements, and explicit typeRoots disabling upward walks for node_modules/@types. The TypeScript team is already working on TypeScript 5.2, with a public iteration plan available.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在科技会议上从参会者到演讲者的9个技巧 | GitHub博客]]></title>
        <id>https://github.blog/2023-05-18-9-tips-to-go-from-attendee-to-speaker-at-a-tech-conference/</id>
        <link href="https://github.blog/2023-05-18-9-tips-to-go-from-attendee-to-speaker-at-a-tech-conference/"/>
        <updated>2023-05-19T00:30:35.220Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/2023-05-18-9-tips-to-go-from-attendee-to-speaker-at-a-tech-conference/">9 tips to go from attendee to speaker at a tech conference | The GitHub Blog</a></p><p><strong>概要：</strong></p><p>GitHub Universe 是一年一度的全球开发者和客户活动，今年将于 11 月 8 日至 9 日在线上和线下举行。文章提供了一些撰写成功演讲提案的技巧，例如标题要吸引人、具体说明内容的收获、突出会议性质等。此外，还提供了演讲者个人介绍的公式和其他有用资源，如往年活动的回顾、联系前任演讲者、关注行业热点等。最后，文章呼吁有兴趣参加演讲的人提交他们的想法，并列出了被选中的好处。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - DukeLuo/eslint-plugin-check-file：ESLint规则的一致的文件名和文件夹。允许你为文件名和文件夹强制执行一致的命名模式。]]></title>
        <id>https://github.com/DukeLuo/eslint-plugin-check-file</id>
        <link href="https://github.com/DukeLuo/eslint-plugin-check-file"/>
        <updated>2023-05-19T00:27:28.162Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/DukeLuo/eslint-plugin-check-file">GitHub - DukeLuo/eslint-plugin-check-file: ESLint rules for consistent filename and folder. Allows you to enforce a consistent naming pattern for the filename and folder.</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 eslint-plugin-check-file 的 ESLint 插件，该插件可以帮助开发者强制规范化文件和文件夹的命名方式。插件支持多种规则，例如强制指定文件夹名称、文件名命名规范等。开发者只需要在.eslintrc 配置文件中添加相应的规则即可使用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么我们选择Astro而不是Nuxt]]></title>
        <id>https://www.blackspike.com/blog/why-we-chose-astro-over-nuxt/</id>
        <link href="https://www.blackspike.com/blog/why-we-chose-astro-over-nuxt/"/>
        <updated>2023-05-19T00:26:56.550Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.blackspike.com/blog/why-we-chose-astro-over-nuxt/">Why we chose Astro over Nuxt</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个网站建设过程中的问题：由于使用了 Three.js 等大量 JavaScript 库，导致页面加载缓慢和卡顿。为了解决这个问题，作者尝试了 Astro 框架，它可以将 JavaScript 编译成 HTML 和 CSS，从而减少页面的 JavaScript 代码量。作者发现，对于博客和静态营销网站等项目，Astro 是一个很好的选择。但对于有交互部分的网站，如头条 Shopify 网站或单页应用程序，则更适合使用 Nuxt 框架。文章最后总结了两种框架的优缺点。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[揭开魔法的面纱：探索各种框架的反应性]]></title>
        <id>https://www.builder.io/blog/reactivity-across-frameworks</id>
        <link href="https://www.builder.io/blog/reactivity-across-frameworks"/>
        <updated>2023-05-19T00:26:15.754Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/reactivity-across-frameworks">Unveiling the Magic: Exploring Reactivity Across Various Frameworks</a></p><p><strong>概要：</strong></p><p>本文深入探讨了各种前端框架中的响应性（reactivity）机制，着重比较了粗粒度和细粒度响应性之间的差异。React 和 Angular 属于粗粒度系统，需要重新执行组件树来检测更改并更新 DOM；Svelte、Vue、Qwik 和 Solid 属于细粒度系统，可以更加高效地检测和更新 DOM。Qwik 是唯一一个不需要预热的框架，它通过 SSR/SSG 将状态与 DOM 相关联，并在客户端恢复这些信息，从而避免了下载大量应用代码的问题。作者认为，虽然粗粒度系统 “随便用” 会更方便，但是使用细粒度系统可能会更高效，因为后者已经进行了优化。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍一下Legend-State 1.0：更快地构建更快的应用程序]]></title>
        <id>https://legendapp.com/open-source/legend-state-v1/</id>
        <link href="https://legendapp.com/open-source/legend-state-v1/"/>
        <updated>2023-05-19T00:25:43.116Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://legendapp.com/open-source/legend-state-v1/">Introducing Legend-State 1.0: Build faster apps faster</a></p><p><strong>概要：</strong></p><p>文章介绍了一个名为 Legend-State 的 React 状态库，它具有极快的速度、易用性、自然的细粒度反应和内置持久性等四个主要优点。该库基于可观察对象实现，使用 Proxy 跟踪对象中的路径，从而在速度和内存使用方面超越其他 React 状态库。使用该库不需要繁琐的模板代码和上下文、动作、规约、分派器等，只需调用 get () 获取原始数据并使用 set () 更改数据即可。此外，该库还支持细粒度反应，使得组件能够在特定值更改时更新，从而减少重新渲染的次数。最后，该库还内置了持久化功能，可以保存和同步应用程序状态。未来，该库将添加更多的持久化插件和辅助可观察对象和钩子函数。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[管理GitHub通知 - GitHub维护者峰会2023]]></title>
        <id>https://antfu.me/posts/manage-github-notifcations-2023</id>
        <link href="https://antfu.me/posts/manage-github-notifcations-2023"/>
        <updated>2023-05-17T15:43:54.393Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/manage-github-notifcations-2023">Manage GitHub Notifications - GitHub Maintainer Summit 2023</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一种名为 “Notification-driven Developement” 的方法来管理 GitHub 上的项目。该作者通过使用 GitHub 的通知系统来管理他所维护的各种规模的项目，以保持项目的活跃度和稳定性。他提出了 “Inbox-Zero” 概念，即每天处理完所有收到的通知，以便快速响应社区成员并控制维护工作量。文章还分享了一些减少通知数量和组织通知的技巧，并介绍了一个用户脚本来自动化通知处理。最后，作者强调了享受工作和保持良好的工作与生活平衡的重要性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[馒头捆绑器]]></title>
        <id>https://bun.sh/blog/bun-bundler</id>
        <link href="https://bun.sh/blog/bun-bundler"/>
        <updated>2023-05-17T04:41:23.198Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bun.sh/blog/bun-bundler">The Bun Bundler</a></p><p><strong>概要：</strong></p><p>Bun bundler 是一个快速的本地打包工具，现在已经进入了 beta 测试阶段。它可以通过 bun build CLI 命令或新的 Bun.build () JavaScript API 来使用。该工具可以用于构建前端应用程序，并提供了内置的 Bun.build () 函数和 bun build CLI 命令。文章指出，JavaScript 生态系统的复杂性不断增加，如何运行 TypeScript 文件、如何为生产环境构建 / 打包代码等问题使得开发变得越来越复杂。Bun bundler 的目标是将打包引入 JavaScript 运行时，从而使前端和全栈代码的发布更简单、更快速。该工具的优点包括：插件执行快速、生成预转换文件以提高运行性能、统一的插件 API、构建输出数组、支持 ESM 模块系统、支持 tree-shaking、支持源码映射、支持 JS 压缩器等。未来，Bun bundler 还将与 Bun 的 HTTP 服务器 API（Bun.serve）集成，从而实现用简单的声明式 API 代替</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[充满惊喜的JavaScript生态圈]]></title>
        <id>https://fly.io/blog/js-ecosystem-delightfully-wierd/</id>
        <link href="https://fly.io/blog/js-ecosystem-delightfully-wierd/"/>
        <updated>2023-05-16T01:46:08.086Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://fly.io/blog/js-ecosystem-delightfully-wierd/">The JavaScript Ecosystem is Delightfully Weird</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了 JavaScript 生态系统的奇怪之处。作者认为，JavaScript 在不到 10 年前非常糟糕，缺乏许多现代语言特性，而且主要运行在浏览器的 DOM 中，很难处理。然而，随着时间的推移，JavaScript 的发展迅速改善，出现了许多编译器和转换工具，如 CoffeeScript、Babel 和 esbuild，使得开发人员可以使用更加现代化的语言特性来编写 JavaScript 代码。同时，JavaScript 生态系统也变得越来越庞大，涵盖了许多框架和库，但是这些框架和库并没有完全遵循 ECMAScript 标准，而是进行了一些自己的扩展和修改，例如 TypeScript 和 JSX。最近，React Server Components (RSC) 出现了，它通过与打包工具的合作，实现了将 React 组件编译成 HTML 或 JSON 流的功能，从而引发了人们对于 JavaScript 语言本身的重新思考。总</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用Qt和Rust构建一个桌面应用程序 - LogRocket博客]]></title>
        <id>https://blog.logrocket.com/build-desktop-app-qt-rust/</id>
        <link href="https://blog.logrocket.com/build-desktop-app-qt-rust/"/>
        <updated>2023-05-15T07:17:16.737Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.logrocket.com/build-desktop-app-qt-rust/">Build a desktop app with Qt and Rust - LogRocket Blog</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 Rust 和 Qt 框架构建桌面应用程序。作者首先讨论了桌面应用程序的优点，然后介绍了 Rust 在桌面应用程序开发中的流行程度和可靠性。接着，作者演示了如何使用 Qt 和 Rust 构建一个简单的 “Hello World” 应用程序，并逐步添加了加密和解密功能。最后，作者还介绍了如何使用 GitHub CI 工作流程来确保代码正确性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[将Next.js App Router用于生产的5条经验之谈]]></title>
        <id>https://www.inngest.com/blog/5-lessons-learned-from-taking-next-js-app-router-to-production</id>
        <link href="https://www.inngest.com/blog/5-lessons-learned-from-taking-next-js-app-router-to-production"/>
        <updated>2023-05-15T04:52:42.154Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.inngest.com/blog/5-lessons-learned-from-taking-next-js-app-router-to-production">5 Lessons Learned From Taking Next.js App Router to Production</a></p><p><strong>概要：</strong></p><p>Next.js 13 的新功能 App Router 引入了 Nested Layouts、Server Components 和 Streaming 等多项新特性，是第一个开源实现 React 18 原语的工具。从 Next.js 13.4 开始，App Router 已被认为是生产就绪状态。使用 App Router 可以更轻松地在路由之间共享 UI、更好地利用服务器组件、更快地展示页面部分内容以及准备未来。但是，在应用 App Router 时需要注意两个缓存、URL 搜索参数在布局服务器组件中的问题、文件结构的优点以及学习新技术和资源有限的挑战。建议先仔细阅读官方文档，如果遇到问题可以查看 GitHub 和 Twitter 上的讨论，并且分享经验和解决方案有助于建立更加实质性的知识库。总体而言，采用 App Router 可以提高用户和开发者的体验，但需要耐心和深入挖掘。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解useRef和useState用于跟踪React中的组件渲染次数]]></title>
        <id>https://peterkellner.net//2023/05/05/Understanding-useRef-and-useState-for-Tracking-Component-Render-Count-in-React/</id>
        <link href="https://peterkellner.net//2023/05/05/Understanding-useRef-and-useState-for-Tracking-Component-Render-Count-in-React/"/>
        <updated>2023-05-15T04:52:16.782Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://peterkellner.net//2023/05/05/Understanding-useRef-and-useState-for-Tracking-Component-Render-Count-in-React/">Understanding useRef and useState for Tracking Component Render Count in React</a></p><p><strong>概要：</strong></p><p>本文介绍了在 React 中使用 useRef 和 useState 来追踪组件渲染次数的实际例子。通过自定义一个名为 useComponentRenderCount 的 hook，使用 useRef 来存储渲染次数，并使用 useState 来管理组件内的不同状态值。通过将状态值分开控制，可以提高代码可读性并更轻松地管理每个值的状态更新。理解何时使用 useRef 以及如何与 useState 一起使用对于管理复杂的组件行为至关重要。在开发 React 应用程序时，需要平衡性能和功能，才能创建高质量的应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反应全局状态为局部状态]]></title>
        <id>https://webup.org/blog/react-global-state-as-local-state/</id>
        <link href="https://webup.org/blog/react-global-state-as-local-state/"/>
        <updated>2023-05-15T04:51:55.382Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://webup.org/blog/react-global-state-as-local-state/">React Global State as Local State</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一种基于 React 的全局状态管理方案，使用 useGlobalState 钩子来读取全局存储对象，并在其更新时强制所有已订阅的组件重新渲染。相比于 Redux 和 Context，这种方案更加简单且没有繁琐的代码。该方案不需要依赖库，支持测试和 TypeScript。文章详细介绍了如何实现这个钩子，包括 JavaScript 和 TypeScript 的实现以及测试用例。作者表示这种方案虽然简单，但也具有可扩展性，可以在其上构建中间件、错误处理和动作等功能。作者在几个项目中尝试了 createGlobalState，目前已成为他的默认选择。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[罗马 v12.1.0]]></title>
        <id>https://rome.tools/blog/2023/05/10/rome12_1/</id>
        <link href="https://rome.tools/blog/2023/05/10/rome12_1/"/>
        <updated>2023-05-15T02:08:46.595Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://rome.tools/blog/2023/05/10/rome12_1/">Rome v12.1.0</a></p><p><strong>概要：</strong></p><p>Rome v12.1.0 发布了，支持新的 Stage 3 装饰器、VCS 集成和新的 lint 规则。现在，Rome 可以解析和格式化大多数框架中的装饰器，并且支持 git VCS 集成。此外，还添加了许多新的 lint 规则，并提供了一个新的命令来更新配置文件。还有一个新的 CLI 帮助提示库，可以从源代码生成输出。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[掌握 TypeScript 中的 infer - JavaScript in Plain English]]></title>
        <id>https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86</id>
        <link href="https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86"/>
        <updated>2023-05-14T16:28:12.103Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86">Mastering infer in TypeScript - JavaScript in Plain English</a></p><p><strong>概要：</strong></p><p>本文介绍了 TypeScript 中 infer 关键字的用法，它可以从现有的代码中提取和推断类型。使用 infer 关键字可以增加代码的类型安全性、效率和组织性。infer 关键字可以在泛型类型、函数参数和返回值、映射类型中使用，但只能在条件类型中使用。同时，文章还提供了一些实际的例子来展示 infer 关键字的使用方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Dart 3 - Dart - Medium]]></title>
        <id>https://medium.com/dartlang/announcing-dart-3-53f065a10635</id>
        <link href="https://medium.com/dartlang/announcing-dart-3-53f065a10635"/>
        <updated>2023-05-14T16:11:21.730Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://medium.com/dartlang/announcing-dart-3-53f065a10635">Announcing Dart 3 - Dart - Medium</a></p><p><strong>概要：</strong></p><p>Google 在 I/O 2023 上宣布了 Dart 3 的发布，这是迄今为止最大的 Dart 版本，包括三个主要进展：100％的声音空安全、记录、模式和类修饰符的重大新语言特性以及通过 Wasm 编译实现对 Web 的本地代码支持。其中，100％空安全意味着 Dart 具有可靠的类型系统，可以避免某些编码错误，如空指针异常，并允许编译器和运行时优化代码。此外，Dart 3 还引入了记录、模式和类修饰符等新功能，使 Dart 更加表达和精简，同时提供了一种详细控制大型 API 表面的方法。最后，Dart 3 还提供了未来的预览，即通过 Wasm 编译实现对 Web 的本地代码支持。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Fresh、OpenAI 和 Supabase 构建您自己的 ChatGPT 风格文档搜索。]]></title>
        <id>https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh</id>
        <link href="https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh"/>
        <updated>2023-05-13T07:30:37.930Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh">Build your own ChatGPT-style doc search with Fresh, OpenAI, and Supabase</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 OpenAI Text Completion API 创建自定义的 ChatGPT 风格文档搜索，以及如何在 Supabase 的免费托管 PostgresDB 中存储嵌入和执行向量相似性搜索。文章详细介绍了构建自定义 ChatGPT 的四个步骤，包括预处理知识库、存储嵌入、运行时执行向量相似性搜索和将内容注入到 OpenAI GPT-3 文本完成提示中并将响应流式传输给客户端。此外，文章还提供了一些有关使用 OpenAI 和 ChatGPT 构建的其他资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Deno 在 Rust 中运行 JavaScript]]></title>
        <id>https://austinpoor.com/blog/js-in-rs</id>
        <link href="https://austinpoor.com/blog/js-in-rs"/>
        <updated>2023-05-13T07:28:48.597Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://austinpoor.com/blog/js-in-rs">Running JavaScript in Rust with Deno</a></p><p><strong>概要：</strong></p><p>本文介绍了作者创建的一个名为 “js-in-rs” 的基于 Rust 的 CLI 工具，用于使用 JavaScript 表达式过滤文件。与 grep 工具使用正则表达式不同，js-in-rs 使用 JavaScript 表达式进行过滤。文章详细介绍了 js-in-rs 的工作原理和代码实现，并探讨了在 Rust 应用程序中运行 JavaScript 代码的潜在应用，例如 Web 服务器、数据管道和数据库用户定义函数等。此外，作者还提到 Deno 运行时具有有趣的权限管理方法，允许用户开启或关闭运行时功能，以防止恶意代码访问资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery 3.7.0 发布：保持顺序]]></title>
        <id>https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/</id>
        <link href="https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/"/>
        <updated>2023-05-13T07:28:14.090Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/">jQuery 3.7.0 Released: Staying in Order</a></p><p><strong>概要：</strong></p><p>jQuery 3.7.0 发布了，包含了 bug 修复、新方法和性能提升等内容。此次更新中，jQuery 删除了其长期使用的选择器引擎 Sizzle，并将其代码直接放入了 jQuery 核心中，以便为未来版本的选择做准备。同时，jQuery 增加了一个可链接的.uniqueSort () 方法，解决了某些情况下.prevAll () 方法返回元素顺序相反的问题。jQuery 还添加了对更多 CSS 属性的支持，避免自动添加 “px” 单位。此外，该版本还优化了.manipulation () 方法的性能，修复了在 IE 中焦点事件异步触发的问题。该版本与之前的版本兼容，可以从 jQuery CDN 或 npm 获取。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Vue 3.3 | Vue 点击]]></title>
        <id>https://blog.vuejs.org/posts/vue-3-3</id>
        <link href="https://blog.vuejs.org/posts/vue-3-3"/>
        <updated>2023-05-13T07:13:47.996Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.vuejs.org/posts/vue-3-3">Announcing Vue 3.3 | The Vue Point</a></p><p><strong>概要：</strong></p><p>Vue 3.3 "Rurouni Kenshin" has been released, with a focus on improving developer experience when using Vue with TypeScript. The update includes improvements to SFC <script setup> usage with TypeScript, imported and complex types support in macros, generic components, more ergonomic defineEmits, typed slots with defineSlots, and experimental features such as reactive props destructure and defineModel. Other notable features include defineOptions, better getter support with toRef and toValue, and JSX import source support. Maintenance infrastructure improvements have also been made, allowing for faster builds, tests, and types generation. The Vue team plans to make smaller and more frequent feature releases starting in 2023.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 协调：它是如何工作的，为什么我们应该关心]]></title>
        <id>https://www.developerway.com/posts/reconciliation-in-react</id>
        <link href="https://www.developerway.com/posts/reconciliation-in-react"/>
        <updated>2023-05-13T07:12:20.250Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developerway.com/posts/reconciliation-in-react">React reconciliation: how it works and why should we care</a></p><p><strong>概要：</strong></p><p>本文详细介绍了 React 的协调算法，以及它如何影响我们的日常代码。文章探讨了条件渲染、"key" 属性和为什么不应该在其他组件内声明组件等问题，并提供了解决方法。作者通过分析 React 的虚拟 DOM 和状态更新过程，解释了为什么在条件渲染中声明组件会重新挂载，以及为什么需要使用 "key" 属性来避免组件重复挂载或保证元素的唯一性。最后，作者提供了多个示例来说明这些概念。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Deopt Explorer - TypeScript]]></title>
        <id>https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/</id>
        <link href="https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/"/>
        <updated>2023-05-13T01:41:30.924Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/">Introducing Deopt Explorer - TypeScript</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用内联缓存（inline caching）优化 JavaScript 代码的性能，并讲解了在 TypeScript 编译器中如何使用 Deopt Explorer 工具来分析性能问题和减少多态现象。文章详细介绍了内联缓存的概念、不同类型的缓存以及多态现象的产生原因。通过实例分析，作者展示了如何使用 Deopt Explorer 工具来分析 V8 引擎生成的 ICs 和对象类型，并通过优化 Symbol 类型的属性访问，将编译时间平均缩短了 8-10%。最后，作者介绍了 Deopt Explorer 工具的使用方法和开源地址。</p>]]></content>
    </entry>
</feed>