<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-06-28T14:35:34.595Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[Bun v0.6.10]]></title>
        <id>https://bun.sh/blog/bun-v0.6.10</id>
        <link href="https://bun.sh/blog/bun-v0.6.10"/>
        <updated>2023-06-28T14:24:16.954Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bun.sh/blog/bun-v0.6.10">Bun v0.6.10</a></p><p><strong>概要：</strong></p><p>我们正在招聘 C/C++ 和 Zig 工程师来构建 JavaScript 的未来！加入我们的团队→最近，我们对 Bun 进行了许多更改，以下是一些重要更新：

v0.6.0 - 引入 bun build，Bun 的新 JavaScript 打包器。
v0.6.2 - 性能提升：JSON.parse 速度提高 20%，Proxy 和 arguments 速度提高 2 倍。
v0.6.3 - 实现 node:vm，对 node:http 和 node:tls 进行了大量修复。
v0.6.4 - 实现 require.cache，process.env.TZ，并使 bun test 速度提高 80%。
v0.6.5 - 对 CommonJS 模块的原生支持（之前，Bun 将 CJS 转换为 ESM）。
v0.6.6 - bun test 的改进，包括 Github Actions 支持，test.only ()，test.if ()，describe.skip () 以及 15 + 个 expect () 匹配器；还有使用 fetch () 进行文件上传。
v0.6.7 - Node.js 兼容性改进，以解决 Discord.js、Prisma 和 Puppeteer 的问题。
v0.6.8 - 引入 Bun.password，bun test 中的 mocking 和 toMatchObject ()。
v0.6.9 - 内存使用减少，支持非 ascii 文件名。

此外，我们对 CommonJS 的支持也有所改善，使得在 Bun 中加载 npm 包更加可靠。我们修复了与加载 CommonJS 模块相关的许多崩溃，并改进了我们的 CommonJS 模块加载器，使其更兼容 Node.js。

我们还修复了 Bun 客户端 WebSocket 实现中的一个编码错误，这可能会导致 latin1 编码的文本帧被截断。感谢这些更改，puppeteer 在 Bun 中的支持已经得到改善。

另外，我们对 bun:test 进行了改进，现在支持更多的匹配</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布v6.0.0 - styled-components/styled-components]]></title>
        <id>https://github.com/styled-components/styled-components/releases/tag/v6.0.0</id>
        <link href="https://github.com/styled-components/styled-components/releases/tag/v6.0.0"/>
        <updated>2023-06-28T14:22:35.169Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/styled-components/styled-components/releases/tag/v6.0.0">Release v6.0.0 · styled-components/styled-components</a></p><p><strong>概要：</strong></p><p>这篇文章是关于一个版本更新的说明，主要包含以下改动：

在此版本中进行了一些修复和改进，例如防止样式属性上的 prop 渗漏，通过 "CSS" 命名空间来传输 csstype，提升 stylis 至 4.3 版本，并减少了一些不必要的分支逻辑。

在 v6 版本中有一些重大变化，包括现在使用 stylis v4（如果使用 stylis-plugin-rtl，你需要升级到新版本），styled-components 现在提供自己的类型；如果你过去安装过 @types/styled-components，你会想要移除它。此外，还删除了 $as 和 $forwardedAs props（使用 as 或 forwardedAs 替代），以及自动 prop 过滤；对于你不希望传递给子组件 / HTML 的内容，使用瞬态 props（$ 前缀）。

StyleSheetManager 也做出了一些更改，比如用 enableVendorPrefixes prop 替换了 disableVendorPrefixes，取消了自动供应商前缀；如果你需要支持旧的浏览器，可以使用上述 prop 轻松重新启用。

此外，还删除了已弃用的 withComponent API（87f511a）；现在需要使用 "as" prop。并且需要 node >= 14。

完整的更改日志可以查看：v5.3.7...v6.0.0。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对Svelte(Kit)的看法，一年后30亿次的请求]]></title>
        <id>https://claudioholanda.ch/en/blog/svelte-kit-after-3-billion-requests/</id>
        <link href="https://claudioholanda.ch/en/blog/svelte-kit-after-3-billion-requests/"/>
        <updated>2023-06-28T02:20:57.195Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://claudioholanda.ch/en/blog/svelte-kit-after-3-billion-requests/">Thoughts on Svelte(Kit), one year and 3 billion requests later</a></p><p><strong>概要：</strong></p><p>去年，我的公司接到了建设一个新闻网站的任务。自从项目上线以来，它经历了显著的观众增长，每天处理数十万的访客。在过去的 12 个月中，每个访客都在页面及其组件上进行导航和交互，大约产生了 30 亿次请求。

我选择 Svelte 作为这个项目的开发框架，并分享了我认为使用 Svelte 和 SvelteKit 工作的好坏两面。

我们的客户给我们带来了一个多年前制作的网站，该网站采用了旧技术，难以添加新功能，性能差，且垂直基础设施昂贵。经过几次会议，我们得出的结论是，最好的方法是暂停旧网站的开发，使用最佳技术和实践从头开始构建一个新的。考虑到这个项目的可塑性和可扩展性需求，还需要从零开始构建一个新的 CMS。

SvelteKit 具有强大的 SSR 解决方案，因此我选择了它。尽管 React 是一个拥有庞大社区和繁荣生态系统的优秀反应式库，但一旦你离开这条路径，你可能会在某个时候遇到麻烦。而有些项目你不想（或不能）因为你选择的 UI 开发工具而冒险遇到麻烦。所以我们选择了 Svelte/SvelteKit 而不是 React/Next.js。

然而，Svelte 也存在一些问题，比如缺乏 “Svelte” 组件，很多项目都是一个人的军队，缺乏已经建立的模式和优秀的教程等。但总的来说，Svelte 对于我们的团队</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - mrjooz/password-generator: 密码生成工具]]></title>
        <id>https://github.com/mrjooz/password-generator</id>
        <link href="https://github.com/mrjooz/password-generator"/>
        <updated>2023-06-28T02:16:42.518Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/mrjooz/password-generator">GitHub - mrjooz/password-generator: 密码生成工具</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了在使用 Git 时，如果已经存在与提供的分支名相同的标签，可能会导致一些问题。因为很多 Git 命令同时接受标签和分支名，所以创建这个分支可能会引发意外的行为。作者询问读者是否确定要创建这个分支。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过使用Node.js的AsyncLocalStorage来避免参数钻取| pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/avoid-parameter-drilling-by-using-the-node-js-asynclocalstorage/</id>
        <link href="https://pawelgrzybek.com/avoid-parameter-drilling-by-using-the-node-js-asynclocalstorage/"/>
        <updated>2023-06-28T02:12:40.147Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/avoid-parameter-drilling-by-using-the-node-js-asynclocalstorage/">Avoid parameter drilling by using the Node.js AsyncLocalStorage | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>虽然全局变量被认为是一种不好的做法，但它可能是共享上下文的最简单形式。在这个例子中，我定义了全局变量 context，并用它在主函数和 logger 函数之间共享 uuid 值。这种方法对于同步代码来说工作得很好，但是当我们引入异步操作时，问题就出现了。让我通过添加一个 http 服务器来说明这个问题：每个后续的请求都会更新全局上下文，logger 函数总是记录 uuid 的最后一个值，而不一定是与请求相关的那个值。将 uuid 作为参数传递给 logger（参数钻取）或将其粘贴到 req 对象是解决此问题的常见解决方案。尽管如此，它们都可能很快变得繁琐。

自 Node.js 13.10 以来，AsyncLocalStorage 类提供了一种在 web 请求或任何其他异步操作的生命周期内存储特定上下文数据的方法。它类似于不同编程语言中使用的线程本地存储（TLS）概念。让我们利用这个 API 并重写我们的示例：现在，所有连续的请求都将记录正确的 uuid 值，而无需担心相互干扰。关联 ID 只是 AsyncLocalStorage API 的许多用例之一。它可以用于存储当前用户、事务 ID、报告数据等。

Node.js AsyncLocalStorage API 的广泛用例激发了社区成员提出 JavaScript 的异步上下文。我希望这个提案能够迅速成为 ECMAScript 标准的一部分。

感谢 Syntax.fm 的一集启发了我去探索这个主题并写下这篇文章。感谢 Wes 和 Scott 创造的优秀内容！</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在焦点上刷新React服务器组件]]></title>
        <id>https://buildui.com/recipes/refresh-react-server-component-on-focus</id>
        <link href="https://buildui.com/recipes/refresh-react-server-component-on-focus"/>
        <updated>2023-06-28T02:08:39.348Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://buildui.com/recipes/refresh-react-server-component-on-focus">Refresh React Server Component on Focus</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 <RefreshOnFocus /> 的组件，它可以被插入到 Next.js 应用中的任何 React 服务器组件中，使其在浏览器窗口被聚焦时刷新。页面上的卡片使用与它们的动态数据相关的键来运行 CSS 动画，每当它们的数据发生变化时都会触发动画。文章还提供了代码和使用方法，以及使用的库 ——Next.js 13 App Directory。同时，文章也邀请读者加入 Build UI Newsletter，以便在发布新的配方时接收通知。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布v1.18.0 - remix-run/remix]]></title>
        <id>https://github.com/remix-run/remix/releases/tag/remix%401.18.0</id>
        <link href="https://github.com/remix-run/remix/releases/tag/remix%401.18.0"/>
        <updated>2023-06-28T02:06:28.873Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/remix-run/remix/releases/tag/remix%401.18.0">Release v1.18.0 · remix-run/remix</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了 Remix 1.18.0 的新特性和改进。包括：

1. 稳定的 V2 开发服务器：这个新版本正式稳定化了 "New Dev Server"，并带有 HMR/HDR。

2. JSON/Text 提交：如果你不是 FormData 的粉丝，Remix 1.18.0 更新了对 react-router-dom@6.14.0 的支持，它带来了在 useSubmit/fetcher.submit 中选择 application/json 或 text/plain 编码的支持，并添加了相应的 navigation.json/navigation.text 和 fetcher.json/fetcher.text 字段。

3. 视口驱动的预获取：Link 组件现在可以通过新的 <Link prefetch="viewport"> 属性值自动预获取路由数据和 JS 模块。

4. 更新的 ESLint 配置：我们已经更新了 @remix-run/eslint-config，以继承来自 @typescript-eslint/recommended 的推荐规则集，而不是手动维护我们自己的 TS 相关规则。

5. 性能改进：我们过去几周大量投入到性能提升上，你可能会看到一些改善（大约快 10%），但我们也亲眼看到在一些极端情况下构建和重建时间大幅缩短。

此外，还修复了一些问题，包括使用 React 17 时的类型问题、pathless 布局路由下的嵌套路径段的错误等，并更新了 React Router 依赖项至最新版本。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用键盘锁API实现更好的全屏模式 - Chrome开发人员]]></title>
        <id>https://developer.chrome.com/blog/better-full-screen-mode/</id>
        <link href="https://developer.chrome.com/blog/better-full-screen-mode/"/>
        <updated>2023-06-27T03:01:02.572Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/blog/better-full-screen-mode/">Better full screen mode with the Keyboard Lock API - Chrome Developers</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了如何使用键盘锁 API 来在全屏模式下捕获 Escape 键。作者指出，当用户在全屏游戏中打开一个对话框，本能地用 Escape 键取消时，可能会被强制退出全屏模式，这是由于对话框和全屏模式对 Escape 键的 “争夺”。默认情况下，全屏模式总是胜出。但通过使用键盘锁 API，可以让对话框成为 Escape 键的 “赢家”。该 API 可以在 navigator.keyboard 上使用，lock () 方法可以在启用后捕获物理键盘上所有键的按键。此方法只能捕获操作系统授权访问的键，幸运的是 Escape 键就是其中之一。如果你的应用有全屏模式，可以在请求全屏时捕获 Escape 键，以此作为渐进增强的手段。当用户离开全屏模式时，通过 Keyboard 接口的 unlock () 方法解锁（即不再捕获）键盘。这样，在全屏模式下，按下 Escape 键将默认取消对话框。如果用户长按 Escape 键，仍然可以退出全屏模式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在VSCode中提高生产力的6个快速技巧]]></title>
        <id>https://techhub.iodigital.com/articles/6-vscode-tips</id>
        <link href="https://techhub.iodigital.com/articles/6-vscode-tips"/>
        <updated>2023-06-27T03:00:42.843Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://techhub.iodigital.com/articles/6-vscode-tips">6 Quick Tips to Boost Your Productivity in VSCode</a></p><p><strong>概要：</strong></p><p>这篇文章分享了六个 VSCode 的使用技巧，帮助开发者优化工作流程。1. 通过快捷键 cmd + option + o（Windows 上为 Shift + Alt + o）可以方便地删除无用的引入，使代码库更整洁。2. 在 VSCode 中，可以通过 F2 键轻松重命名变量，系统会自动更新代码中所有该变量的实例，节省时间并保证一致性。3. 对于频繁使用的命令或扩展，可以设置快捷键，提高工作效率。在 “代码> 首选项 > 键盘快捷方式” 中搜索需要的操作，双击快捷方式列并设定你喜欢的快捷键。4. 可以设置一个快速修复 ESLint 问题的自定义快捷键。将以下代码复制到 keybindings.json 文件中，并分配一个未被 VSCode 使用的键组合，即可立即触发 ESLint 的自动修复功能。5. VSCode 内置的 “快速修复” 功能能够显示当前上下文所有可用的快速修复方案，例如添加缺失的引入、修复 linting 问题或向单行箭头函数添加花括号。6. 可以创建一个 “快速修复：添加所有缺失的引入” 的快捷键，比如设定为 cmd + '，当遇到未解决的引入时，只需使用这个快捷键就能自动添加必要的引入，无需手动搜索、输入和导入。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bright - 语法高亮的React服务器组件]]></title>
        <id>https://bright.codehike.org/</id>
        <link href="https://bright.codehike.org/"/>
        <updated>2023-06-26T10:56:40.259Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bright.codehike.org/">Bright - Syntax Highlighting React Server Component</a></p><p><strong>概要：</strong></p><p>这篇文章主要讲述了 React 服务器组件用于语法高亮的内容。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023年的React Ecosystem。]]></title>
        <id>https://dev.to/ihteshamulhaq510/react-ecosystem-in-2023-5aj4</id>
        <link href="https://dev.to/ihteshamulhaq510/react-ecosystem-in-2023-5aj4"/>
        <updated>2023-06-26T01:58:53.568Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/ihteshamulhaq510/react-ecosystem-in-2023-5aj4">React Ecosystem in 2023.</a></p><p><strong>概要：</strong></p><p>这篇文章主要介绍了 2023 年的 React 生态系统，包括一些可供学习和成为 React 开发者的库。最近，推出了一款名为 million.js 的工具，它使 React 的速度提高了 70%。对于初学者来说，选择正确的库可能相当具有挑战性。

文章列举了一些 React 库，包括构建工具（如 vite、nextjs、Webpack）、路由（如 react router、tanstack router）、客户端状态管理（如 redux toolkit、zustand）、服务器状态管理（如 tanstack query、redux-toolkit query、Apollo Client、jotai）、表单处理（如 Formik、React Hook Form）、测试（如 Vitest、React Testing library、Play-write）、样式（如 Tailwindcss、Styled-components、Emotion、Bootstrap）、UI 组件库（如 Material UI、Man time UI、Ant Design、Chakra UI、Headless UI (tailwindcss)、DaisyUI (Tailwindcss)、shadcn UI (Tailwindcss)、React Bootstrap）、动画（如 React Spring、Framer motion）、数据可视化（如 Victory charts、React Charts js、Recharts）、表格（如 Tanstack table）、国际化（如 react-i18next、formatjs）以及开发工具（如 react developer tools、Redux dev tool、testing playground、react hook form dev tools、AxeDev Tool (Accessibility)、Tanstack query dev tools）。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第四部分：编写简洁高效的React代码--最佳实践和优化技术]]></title>
        <id>https://dev.to/sathishskdev/part-4-writing-clean-and-efficient-react-code-best-practices-and-optimization-techniques-423d</id>
        <link href="https://dev.to/sathishskdev/part-4-writing-clean-and-efficient-react-code-best-practices-and-optimization-techniques-423d"/>
        <updated>2023-06-26T01:58:29.603Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/sathishskdev/part-4-writing-clean-and-efficient-react-code-best-practices-and-optimization-techniques-423d">Part 4: Writing Clean and Efficient React Code- Best Practices and Optimization Techniques</a></p><p><strong>概要：</strong></p><p>本文是 "2023 年 React 最佳实践" 系列的第四部分，探讨了如何编写清晰、高效的 React 应用程序代码。以下是一些最佳实践：

1. 实现错误边界来优雅地处理组件错误。
2. 对于功能组件，使用 React.memo 以避免不必要的重渲染。
3. 使用 Linting 工具（如 ESLint）来提高代码质量和一致性。
4. 避免默认导出，因为它可能使理解哪些组件被导入和在其他文件中使用变得困难。
5. 使用对象解构，这是一种更简洁、优雅的方式来提取对象属性。
6. 使用片段来避免在渲染多个元素时产生不必要的包装 div。
7. 优先传递对象而不是多个 props。
8. 使用箭头函数，它提供了更简洁的语法和词法范围。
9. 使用枚举代替数字或字符串。
10. 对布尔 props 使用简写。
11. 避免使用索引作为 key props。
12. 在小函数中使用隐式返回。
13. 使用 PropTypes 进行类型检查。
14. 优先使用模板文字。
15. 避免使用庞大的组件。

以上最佳实践可以提高代码的可维护性、性能和可读性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[跟大家聊聊当下卖课的现状]]></title>
        <id>https://blog.meathill.com/share/lets-talk-about-be-a-tutorial-video-creator.html</id>
        <link href="https://blog.meathill.com/share/lets-talk-about-be-a-tutorial-video-creator.html"/>
        <updated>2023-06-25T13:52:19.567Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.meathill.com/share/lets-talk-about-be-a-tutorial-video-creator.html">跟大家聊聊当下卖课的现状</a></p><p><strong>概要：</strong></p><p>文章作者分享了他在制作在线课程方面的经验。首先，他提到了平台分成问题，大部分平台会收取 50% 的服务费，再加上苹果设备用户需要支付 30% 的税，最终讲师能拿到的收入并不多。其次，课程内容的选择也是一个问题，新人讲师往往无法接到热门选题，而自己感兴趣的选题可能平台不愿意接受。此外，如果想自行销售课程，除非有大量的粉丝基础，否则难以获得成功。最后，由于网络技术更新快速，课程的生命周期较短，因此很难实现稳定的收入。总的来说，作者建议想做在线课程的人在开始前应该仔细考虑各种因素，找出更适合自己的方向。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React中的远程传输：定位、堆叠上下文和传送门]]></title>
        <id>https://www.developerway.com/posts/positioning-and-portals-in-react</id>
        <link href="https://www.developerway.com/posts/positioning-and-portals-in-react"/>
        <updated>2023-06-25T13:45:53.262Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developerway.com/posts/positioning-and-portals-in-react">Teleportation in React: Positioning, Stacking Context, and Portals</a></p><p><strong>概要：</strong></p><p>这篇文章详细讨论了 CSS 定位的工作原理，堆叠上下文（Stacking Context）是什么，如何使用 CSS 逃离 overflow:hidden，为什么我们不能用 CSS 做所有事情而需要 Portals，以及 Portals 是如何工作的。文章首先解释了 CSS 的绝对定位，并指出绝对并不完全是绝对的，它实际上是相对于设置了任何值的最近元素的位置。然后，文章介绍了堆叠上下文，这是一个三维的视角来看待 HTML 元素。接着，文章讨论了如何使用 CSS 逃离内容剪裁，为什么我们不能用 CSS 做所有事情而需要 Portals，以及 Portals 是如何实际工作的。文章还深入探讨了 React Portal 如何解决这个问题，以及 React 生命周期，重渲染，Context 和 Portals 之间的关系。最后，文章总结了在使用 Portals 时的规则：在 React 中发生的事情保持在 React 层次结构中，在 React 之外的事情遵循 DOM 结构规则。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - a16z-infra/ai-getting-started：一个用于周末项目的Javascript AI入门栈，包括图像/文本模型、矢量存储、授权和部署配置。]]></title>
        <id>https://github.com/a16z-infra/ai-getting-started</id>
        <link href="https://github.com/a16z-infra/ai-getting-started"/>
        <updated>2023-06-25T13:45:22.332Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/a16z-infra/ai-getting-started">GitHub - a16z-infra/ai-getting-started: A Javascript AI getting started stack for weekend projects, including image/text models, vector stores, auth, and deployment configs</a></p><p><strong>概要：</strong></p><p>这篇文章是关于如何开始使用 AI 的指南，包括了一些主要技术栈和操作步骤。技术栈包括 Auth：Clerk、应用逻辑：Next.js、VectorDB：Pinecone / Supabase pgvector、LLM Orchestration：Langchain.js、图像模型：Replicate、文本模型：OpenAI、文本流：ai sdk、部署：Fly 等。

文章详细介绍了如何在本地测试这个技术栈，并理解每个组件的工作方式。首先需要从 Github 账户复制并克隆仓库，然后安装依赖项。接着填写 Clerk Secrets、OpenAI API key、Replicate API key、Pinecone API key 和 Supabase API key。注意，默认情况下，此模板使用 Pinecone 作为向量存储，但你可以轻松开启 Supabase pgvector。

之后，生成嵌入并将其存储在向量数据库中以供未来查询。然后在本地运行应用程序进行测试。最后，将应用程序部署到 fly.io。

此外，文章还介绍了如何为该仓库做出贡献，包括代码贡献工作流程和其他贡献方式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是CDN？内容交付网络的无偏见指南]]></title>
        <id>https://calibreapp.com/blog/content-delivery-networks-guide</id>
        <link href="https://calibreapp.com/blog/content-delivery-networks-guide"/>
        <updated>2023-06-25T13:43:12.424Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://calibreapp.com/blog/content-delivery-networks-guide">What is a CDN? An Unbiased Guide to Content Delivery Networks</a></p><p><strong>概要：</strong></p><p>内容分发网络（CDN）是提高网站性能和可靠性的最佳方式之一。它可以帮助提高页面速度，抵御拒绝服务攻击，并优化内容以实现更快的传输。选择合适的 CDN 对于网站来说是一个重要的决定，因此你需要进行研究。然而，大部分关于 CDN 的搜索结果都来自销售 CDN 的公司，这让人很难相信由销售人员写的博客文章。好消息是我们不销售 CDN，但作为网络性能专家，我们对此有深入了解。我们编写了这篇指南，帮助你在选择 CDN 时做出明智的决定。

CDN 是全球分布的服务器网络，可以托管你的内容并快速将其传送给访问者。CDN 通过减少延迟、提高可靠性，甚至优化内容以实现更快的传输，来支持你的主机服务器。CDN 就像是遍布全球的小型本地仓库。当访问者请求内容时，这些本地仓库从你的中央仓库（主机服务器）接收内容并存储起来。这样，我们可以快速可靠地传输内容，因为 CDN 服务器的位置遍布全球，如果一个服务器出现故障，其他服务器可以接替其工作。

CDN 的工作原理是在全球各地的战略位置拥有服务器，从而更快地为你传送内容。CDN 通过在全球范围内提前存储你的内容来解决这些问题。因此，当有请求时，CDN 会将数据存储在悉尼的服务器上，以便更快地传送到新西兰。

CDN 的好</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布Svelte 4]]></title>
        <id>https://svelte.dev/blog/svelte-4</id>
        <link href="https://svelte.dev/blog/svelte-4"/>
        <updated>2023-06-25T13:40:29.417Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://svelte.dev/blog/svelte-4">Announcing Svelte 4</a></p><p><strong>概要：</strong></p><p>Svelte 4 稳定版已经发布，它主要是一个维护版本，提升了性能，改进了开发者体验，并对网站进行了更新。Svelte 4 的包大小减少了近 75%，从 10.6MB 降到 2.8MB，这意味着在执行 npm install 时等待时间更短。此外，Svelte 的依赖项数量也从 61 个大幅度减少到 16 个，这不仅可以加快用户的下载速度，还可以降低供应链攻击的风险。对于 Web 组件的使用者来说，最大的变化是改变了使用 Svelte 来创建自定义元素的方式。此外，Svelte 4 还改进了 IDE 编写体验，更新了官方网站、文档和教程，并为即将发布的 Svelte 5 做好了准备。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 5.2的新关键词："using"。]]></title>
        <id>https://www.totaltypescript.com/typescript-5-2-new-keyword-using</id>
        <link href="https://www.totaltypescript.com/typescript-5-2-new-keyword-using"/>
        <updated>2023-06-25T13:23:00.586Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.totaltypescript.com/typescript-5-2-new-keyword-using">TypeScript 5.2's New Keyword: 'using'</a></p><p><strong>概要：</strong></p><p>TypeScript 5.2 将引入一个新的关键字 - 'using'，你可以用它在离开作用域时处理任何带有 Symbol.dispose 函数的东西。

这基于 TC39 提案，该提案最近达到了第 3 阶段，表明它将被引入 JavaScript。'using' 对于管理诸如文件句柄、数据库连接等资源将非常有用。

Symbol.dispose 是 JavaScript 中的一个新的全局符号。任何赋予 Symbol.dispose 函数的东西都会被视为一个 “资源” - “具有特定生命周期的对象”，并可以与 using 关键字一起使用。

你还可以使用 Symbol.asyncDispose 和 await using 来处理需要异步处理的资源。

这将在继续之前等待 Symbol.asyncDispose 函数。这对于数据库连接等资源非常有用，你希望确保程序继续之前连接已经关闭。

使用案例：

文件句柄：通过节点中的文件处理器访问文件系统可能会因为 using 变得更容易。

数据库连接：管理数据库连接是 C# 中使用 using 的一个常见用例。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[99.9成功率！Mac运行赛博朋克2077，使用Game Porting Toolkit]]></title>
        <id>https://www.bilibili.com/read/cv24310042</id>
        <link href="https://www.bilibili.com/read/cv24310042"/>
        <updated>2023-06-25T13:03:57.380Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.bilibili.com/read/cv24310042">99.9成功率！Mac运行赛博朋克2077，使用Game Porting Toolkit</a></p><p><strong>概要：</strong></p><p>这篇文章主要介绍了如何在苹果 M 芯片 Mac 上运行赛博朋克 2077 游戏。首先，需要通过 Game Porting Toolkit 工具将 Direct3D 指令转译成 Metal 指令，使得 Windows 游戏能够在 Apple Silicon Mac 上运行。然后，作者详细介绍了准备所需资源、安装 macOS14 Beta、安装 Game Porting Toolkit、配置 Wine Prefix 环境和安装 Steam 等步骤。最后，通过 Wine 直接启动赛博朋克 2077 游戏。全程操作较为复杂，需要耐心且对计算机有一定的了解。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[具有稳定扩散性的风格化二维码]]></title>
        <id>https://antfu.me/posts/ai-qrcode</id>
        <link href="https://antfu.me/posts/ai-qrcode"/>
        <updated>2023-06-25T12:42:53.686Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/ai-qrcode">Stylistic QR Code with Stable Diffusion</a></p><p><strong>概要：</strong></p><p>这篇文章是作者分享如何使用 Stable Diffusion 和 ControlNet 创建一个既可以扫描的 QR 码又是一幅艺术插图的过程。首先，作者介绍了他对 AI 技术的兴趣，并提到了一些重要的工具和模型。然后，他详细描述了创建 QR 码图像的步骤，包括设置环境、生成 QR 码、将文本转化为图像、调整细节和放大图像等。最后，他展示了最终结果并总结了自己的学习经历。作者希望这篇文章能够给读者提供一些基础概念或启发他们开始自己的创作之旅。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工人们的KV在新的架构下比以前更快]]></title>
        <id>https://blog.cloudflare.com/faster-workers-kv-architecture/</id>
        <link href="https://blog.cloudflare.com/faster-workers-kv-architecture/"/>
        <updated>2023-06-21T15:28:20.529Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.cloudflare.com/faster-workers-kv-architecture/">Workers KV is faster than ever with a new architecture</a></p><p><strong>概要：</strong></p><p>Cloudflare 宣布了对 Workers KV 的重大性能改进，这一改进主要集中在显著提高冷读性能和降低延迟，甚至对于长尾访问模式也是如此。开发人员使用 KV 时，热读取性能很好，但他们会问为什么他们的 95% 分位延迟 —— 通常是在一个关键（或一组关键）上，这个关键最近没有被访问过或者在该地区没有被访问过 —— 比预期的要高。因此，Cloudflare 已经在幕后为 KV 开发了一个新的缓存层，使客户能够实现更频繁的热读取，减少最差情况下的延迟时间，更好地控制缓存 TTL，并且比以前的版本快得多。最好的部分是，使用 KV 的开发人员不需要改变任何东西就可以从这种增强的性能中受益。

Workers KV 是 Cloudflare 网络支持的针对读取密集型用例和应用程序设计的键值存储。KV 专注于读取密集型用例，使其能够在毫秒内提供热（缓存）读取，这使其成为存储每个应用程序或客户配置数据、路由配置、多变量（A/B 测试）配置，甚至需要快速提供的小资产数据的理想选择。你可以将任何可以序列化并且需要快速获取的东西存储在 KV 中，每个单独的键可以存储高达 25 MiB 的数据，总数据存储没有上限。

Cloudflare 已经重新设计了 Workers KV，由新的分层缓存实现驱动。这个实现是作为 Worker 服务编写的。我们重用了为平</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么快速工作比它看起来更重要 " jsomers.net博客]]></title>
        <id>http://jsomers.net/blog/speed-matters</id>
        <link href="http://jsomers.net/blog/speed-matters"/>
        <updated>2023-06-21T02:03:05.204Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="http://jsomers.net/blog/speed-matters">Why working quickly is more important than it seems « the jsomers.net blog</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了工作效率的重要性。作者指出，快速工作不仅可以在单位时间内完成更多的工作，而且会使新任务在你的心中看起来成本更低，因此你会倾向于做更多的事情。相反，如果你做事慢，那么你可能会继续保持这种状态，因为提高速度的唯一方法就是多做。

作者还发现，如果他能快速回复人们的邮件，他们就会给他发送更多的邮件。这是因为发件人期望得到回复，这种期待促使他们写信。换句话说，速度本身就能吸引他们发邮件，因为他们知道自己的努力会有回报。

同样，网站响应速度慢会导致用户流失。谷歌以其搜索速度著名，他们意识到如果搜索速度快，你就更可能去搜索。原因是它鼓励你尝试，得到反馈，然后再次尝试。当你想到一个问题时，你知道谷歌已经在那里了。没有思考和行动之间的延迟，没有失去寻找答案的冲动。谷歌搜索的预计成本几乎为零，它感觉就像你思维的延伸。

此外，如果你想做某件事并且变得擅长 —— 比如写作或修复错误 —— 你应该试着更快地去做。这并不意味着草率行事，但确实意味着，你需要推动自己比你认为健康的速度更快。因为这样，任务在你的心中的成本会</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杀人社区]]></title>
        <id>https://www.marginalia.nu/log/82_killing_community/</id>
        <link href="https://www.marginalia.nu/log/82_killing_community/"/>
        <updated>2023-06-21T02:02:07.939Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.marginalia.nu/log/82_killing_community/">Killing Community</a></p><p><strong>概要：</strong></p><p>这篇文章主要探讨了社交媒体平台的发展模式，以及这种模式对在线社区的影响。作者将在线社区比作一个村庄，其中有熟悉的面孔、集体经验和共享价值观等。然而，当这些 “村庄” 不能承受持续大量的陌生人涌入时，它们就会变得不再像村庄，更像是火车站，人们来来去去，没有真正的归属感。在这样的环境中，人们总是保持警惕，因为他们总是在与陌生人打交道。这种环境是压抑的，使人感到孤立无援，无力改变。作者认为，如果你想彻底摧毁一个关于建立社区和结识新朋友的网站，那么就让这个网站和所有的社区尽可能地增长。这样，你会得到一个每个人都是陌生人的地方，粗鲁成为常态，没有归属感。最后，作者提出，对 Reddit 这类社区型网站来说，停止增长甚至稍微缩小规模可能是最好的选择，这将使社区能够稳定下来，重新变得像村庄一样，从社区的角度看，网站将因此变得更好。但从商业角度看，这是一个真正的困境，因为唯一赚钱的方式就是增长，而唯一增长的方式就是破坏社区。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TIL: 无效的CSS循环依赖和有效的空回退值，使用裸逗号| pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/til-invalid-css-cyclic-dependencies-and-a-valid-empty-fallback-value-using-a-bare-comma/</id>
        <link href="https://pawelgrzybek.com/til-invalid-css-cyclic-dependencies-and-a-valid-empty-fallback-value-using-a-bare-comma/"/>
        <updated>2023-06-21T01:29:20.588Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/til-invalid-css-cyclic-dependencies-and-a-valid-empty-fallback-value-using-a-bare-comma/">TIL: invalid CSS cyclic dependencies and a valid empty fallback value using a bare comma | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>今天我阅读了 Roman Komarov 的一篇名为 “Cyclic Dependency Space Toggles” 的文章，这是我近期阅读过的最令人费解的 CSS 文章之一。它让我思考了我们在过去几年中探索的所有使用 CSS 自定义属性的模式，以及我们还有多少需要发现的。我从这篇文章中学到了两个令人兴奋的概念，让我与你们分享一下。

无效的循环依赖
当自定义属性相互引用时，循环中的所有自定义属性都是无效的。规范中的一个引述：这可能会产生循环依赖性，其中一个自定义属性使用 var () 引用自身，或者两个或更多的自定义属性试图相互引用。[…] 如果依赖关系图中存在循环，那么循环中的所有自定义属性在计算值时都是无效的。

有效的空回退值使用裸逗号
如果传递给 var () 函数的初始值缺失或无效，但其后跟着一个裸逗号，则计算值为有效的空回退值。规范中的解释是：[…] 一个裸逗号，后面没有任何东西，必须被视为在 var () 中有效，表示一个空的回退值。

这两个概念如何有用？
如果你想知道这些对你有何帮助，我建议你阅读 Roman 的文章，该文提出了一个强大的值切换用例。当然，这不是利用自定义属性的有效 / 无效评估的唯一方式。看看这个简化的例子。

--color 自定义属性的值决定了 --is-default, --is-red 和 --is-green 的有效性。然后，应用相应的背景颜色回退值（灰色，</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[万维网联盟宣布在线支付的新网络标准]]></title>
        <id>https://www.applemust.com/w3c-announces-new-web-standard-for-online-payments/</id>
        <link href="https://www.applemust.com/w3c-announces-new-web-standard-for-online-payments/"/>
        <updated>2023-06-21T01:28:09.161Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.applemust.com/w3c-announces-new-web-standard-for-online-payments/">W3C announces new Web standard for online payments</a></p><p><strong>概要：</strong></p><p>世界广域网联盟（W3C）宣布了一种新的网络标准，这是一种新的浏览器能力，有助于简化用户认证并在网页结账时提高支付安全性。该标准名为 “安全支付确认”（SPC），可以帮助商家、银行、支付服务提供商、卡网络等降低强大客户认证的摩擦，并产生用户同意的密码证据，这两者都是欧洲支付服务指令（PSD2）等监管要求的重要方面。目前，该标准已经作为候选建议可用，这意味着功能集是稳定的，并且已经得到了广泛的审查。

W3C 表示，该标准的创建是为了应对基于网络的电子商务的增加以及随之而来的支付欺诈的增加。自 2019 年以来，W3C 一直在开发安全支付确认，以帮助实现强大的客户认证要求，同时降低结账摩擦。Stripe 进行了一个早期实施 SPC 的试点，并在 2020 年 3 月报告称，与一次性密码（OTP）相比，SPC 认证使转化率增加了 8%，同时结账速度提高了 3 倍。

安全支付确认不仅适用于卡支付。网络支付工作组定期讨论如何将 SPC 整合到其他支付生态系统中，如开放银行、巴西的 PIX 以及专有支付流程中。目前，SPC 在 MacOS、Windows 和 Android 上的 Chrome 和 Edge 中可用。在候选推荐期间，网络支付工作组将寻求在其他浏览器和环境中实施 —— 考虑到苹果在 W3C 和 FIDO 的参与，S</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简介]]></title>
        <id>https://vinejs.dev/docs/introduction</id>
        <link href="https://vinejs.dev/docs/introduction"/>
        <updated>2023-06-21T01:27:27.486Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vinejs.dev/docs/introduction">Introduction</a></p><p><strong>概要：</strong></p><p>VineJS 是一个用于 Node.js 的表单数据验证库，可用于验证后端应用中的 HTTP 请求体。它是 Node.js 生态系统中最快的验证库之一，并提供运行时和静态类型安全性。VineJS 专为验证表单数据和 JSON 负载而构建，支持自定义错误消息和格式化错误，并附带 50 多个验证规则和 12 种模式类型。你可以向 VineJS 添加自定义规则和模式类型，我们还让测试自定义验证规则变得非常简单。

在与 Yup、Zod 和 VineJS 验证一个简单对象的性能比较中，VineJS 是最快的。在验证 HTTP 请求体的情况下，VineJS 的性能比 Zod 好 5 倍到 10 倍，处理了许多 HTML 表单序列化的怪癖（Zod 没有），并为定义自定义错误消息和格式化错误提供了更好的工作流程。

然而，VineJS 不是一个通用的验证库，因此你不能用它来验证 JavaScript 数据类型，如函数、映射或集合。VineJS 是在 Node.js 运行时环境中使用的后端环境，因此你不能在浏览器内运行它。

VineJS 是由 Harminder Virk 最初创建的独立开源项目，由 AdonisJS 核心团队维护。VineJS 是现有的 AdonisJS 验证器代码库的改进版本，作为一个独立的库发布，以便与任何 Node.js 项目一起工作。该项目通过 Github 赞助商资助，如果你或你的企业从 VineJS 中获益，请考虑赞助我们以支持项目的开发。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SvelteKit的新功能：轻松优化你的应用程序 - Vercel]]></title>
        <id>https://vercel.com/blog/feature-complete-sveltekit</id>
        <link href="https://vercel.com/blog/feature-complete-sveltekit"/>
        <updated>2023-06-21T01:24:36.768Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/feature-complete-sveltekit">New features for SvelteKit: Optimize your application with ease – Vercel</a></p><p><strong>概要：</strong></p><p>Svelte 已经在 Web 开发框架的世界中崭露头角，这要归功于其将组件转化为优化的 JavaScript 模块的独特方法。这种创新的渲染应用程序的方式消除了传统框架中存在的开销，从而提高了应用程序的性能和效率。随着 SvelteKit 1.0 的发布，开发者可以充分利用全栈 Svelte 的强大功能，而不必担心会产生破坏性的改变。此外，SvelteKit 还在不断发展，提供了一套强大的功能，并与各种部署环境（包括 Vercel）无缝集成。Vercel 采用了基于框架定义的基础设施（FDI），并已经接纳了 SvelteKit，最近添加了对每个路由的无服务器和边缘函数配置、增量静态再生（ISR）以及与一系列 Vercel 产品更容易兼容的支持。在本文中，我们将探讨如何使您的应用程序更具性能，可扩展性和用户友好性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布v0.18.5 - evanw/esbuild]]></title>
        <id>https://github.com/evanw/esbuild/releases/tag/v0.18.5</id>
        <link href="https://github.com/evanw/esbuild/releases/tag/v0.18.5"/>
        <updated>2023-06-21T01:12:29.081Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/evanw/esbuild/releases/tag/v0.18.5">Release v0.18.5 · evanw/esbuild</a></p><p><strong>概要：</strong></p><p>这个版本实现了即将出现的 JavaScript 装饰器提案中的新的自动访问器语法。这种语法尚未成为 JavaScript 的一部分，但已在 TypeScript 4.9 版本中加入。如果目标设置为除 esnext 之外的其他内容，将会对自动访问器进行转换。现在也可以在 esbuild 的 TypeScript 实验性装饰器转换中使用自动访问器，行为应与装饰底层 getter/setter 对相同。

此版本还使 esbuild 现在从即将出现的 JavaScript 装饰器提案中解析装饰器，并将它们原样传递到输出（只要语言目标设置为 esnext）。还没有实现将 JavaScript 装饰器转换为不支持它们的环境。目前 esbuild 实现的唯一装饰器变换仍然是 TypeScript 实验性装饰器变换，这只在.ts 文件中工作，并且需要在你的 tsconfig.json 文件中设置 "experimentalDecorators": true。

此外，如果可能，现在使用静态块来使用具有赋值语义的静态字段。以前，这是通过从类体中移除字段并在类声明后添加赋值语句来完成的。但是，这也导致任何私有字段也必须降低（以防字段初始化器使用私有符号，直接或间接）。此版本将此转换更改为使用内联静态块（如果支持的话），这避免了在此场景中需要降低私有字段。

最后，修复了 TypeScript 实验性装饰器与 --mangle-props 设置结合使用时可能导致的崩溃问题。现在可以安全地将这两个功能结合在一起使用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍一下HTTP/3的优先次序]]></title>
        <id>https://blog.cloudflare.com/better-http-3-prioritization-for-a-faster-web/</id>
        <link href="https://blog.cloudflare.com/better-http-3-prioritization-for-a-faster-web/"/>
        <updated>2023-06-21T01:11:42.840Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.cloudflare.com/better-http-3-prioritization-for-a-faster-web/">Introducing HTTP/3 Prioritization</a></p><p><strong>概要：</strong></p><p>今天，Cloudflare 宣布全面支持 HTTP/3 可扩展优先级，这是一种新的标准，可以将网页的加载速度提高高达 37%。Cloudflare 与标准构建者紧密合作，帮助形成 HTTP/3 优先级的规范，并很高兴能推动网络前进。HTTP/3 可扩展优先级适用于 Cloudflare 的所有计划。对于付费用户，有一个增强版本可进一步提高性能。网页由许多必须在处理和呈现给用户之前下载的对象组成。并非所有对象对网页性能的重要性都相等。HTTP 优先级的作用是在最适当的时机加载正确的字节，以实现最佳结果。在多个对象都在竞争同一受限资源时，优先级最为重要。在 HTTP/3 中，这个资源就是 QUIC 连接。在大多数情况下，从服务器到客户端的带宽是瓶颈。选择将带宽分配给哪些对象，或在哪些对象之间共享带宽，是网页性能的关键基础。如果出现错误，我们在其上构建的其他优化可能会受到影响。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NestJS v10现已上市 - Trilon Consulting]]></title>
        <id>https://trilon.io/blog/nestjs-10-is-now-available</id>
        <link href="https://trilon.io/blog/nestjs-10-is-now-available"/>
        <updated>2023-06-21T01:11:00.769Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://trilon.io/blog/nestjs-10-is-now-available">NestJS v10 is now available - Trilon Consulting</a></p><p><strong>概要：</strong></p><p>NestJS 10 正式发布，带来了许多错误修复、改进和新功能。其中最令人兴奋的新特性包括对 SWC（Speedy Web Compiler）的支持，这是一个可用于编译和打包的基于 Rust 的可扩展平台，使用 SWC 与 Nest CLI 可以显著加快开发过程；测试中模块的覆盖功能，这在需要模拟整个模块而不是单独模拟每个提供者时非常有用；对 Redis 通配符订阅的支持，该功能允许你订阅所有匹配给定模式的消息；CacheModule 已从 @nestjs/common 包中移除，并作为独立包 @nestjs/cache-manager 提供；此外，NestJS 10 不再支持 Node.js v12，而需要 Node.js v16 或更高版本。</p>]]></content>
    </entry>
</feed>