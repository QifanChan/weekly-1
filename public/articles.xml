<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-07-13T06:09:24.504Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[克劳德 2]]></title>
        <id>https://www.anthropic.com/index/claude-2</id>
        <link href="https://www.anthropic.com/index/claude-2"/>
        <updated>2023-07-13T06:09:09.973Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.anthropic.com/index/claude-2">Claude 2</a></p><p><strong>概要：</strong></p><p>我们很高兴地宣布推出新模型 Claude 2。Claude 2 的性能得到了提升，响应更长，可以通过 API 以及新的公开测试网站 claude.ai 进行访问。用户反馈称，Claude 易于交谈，清晰解释其思考过程，不太可能产生有害输出，并且记忆力更强。我们在编码、数学和推理方面对上一代模型进行了改进。例如，我们的最新模型在律师资格考试的多项选择题部分得分为 76.5%，比 Claude 1.3 的 73.0% 有所提高。Claude 2 在 GRE 阅读和写作考试中的得分超过了 90% 的申请研究生的成绩，而在定量推理方面的得分与中位数申请人相似。Claude 2 的输入和输出长度都得到了增加，用户可以在每个提示中输入多达 100K 的标记，这意味着 Claude 可以处理数百页的技术文档甚至一本书。Claude 现在也可以一次性写出更长的文件 —— 从备忘录到信件到故事，所有这些都可以一次性完成。此外，我们的最新模型在编码技能方面有了显著的提高。Claude 2 在 Codex HumanEval 的 Python 编码测试中得分为 71.2%，高于 56.0%。在 GSM8k（一套大型小学数学问题集）中，Claude 2 的得分为 88.0%，高于 85.2%。我们已经为 Claude 2 规划了一系列令人兴奋的功能改进计划，并将在未来几个月中逐步部署。Claude 2 目前在美国和英国普遍可用，我们正在</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[您可能不需要Jest - Node.js原生测试运行器非常棒 | pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/you-might-not-need-jest-the-node-js-native-test-runner-is-great/</id>
        <link href="https://pawelgrzybek.com/you-might-not-need-jest-the-node-js-native-test-runner-is-great/"/>
        <updated>2023-07-12T14:59:06.342Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/you-might-not-need-jest-the-node-js-native-test-runner-is-great/">You might not need Jest — the Node.js native test runner is great | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>文章主要介绍了 Node.js 原生测试运行器的一些特性和使用方法。现代的 JavaScript 运行时环境，如 Deno 和 Bun，以及像 Go 和 Rust 这样的现代编程语言都具备测试功能，Node.js 也在逐步跟上。Node.js 的测试运行器模块在 18 版本中首次实验性引入，并在 20 版本中稳定下来。此模块在出现错误时返回进程退出代码 1，否则返回 0。此外，文章还介绍了如何使用 node:assert 模块简化断言，以及如何执行所有匹配文件的测试。Node.js 在添加测试设施时功能有限，但几次迭代后，我们现在可以使用许多更常用的测试特性，如分组、模拟、挂钩等。此外，Node.js 在 18.11 版本中添加了观察模式，稍后在 19.2 版本中为测试运行器添加了观察模式。默认的人类可读测试报告（spec）可以替换为紧凑（dot）格式，如果这些选项都不符合你的需求，可以使用 npm 安装自定义报告，或者创建一个遵循 TAP（Test Anything Protocol）规范的自定义报告。最后，作者表示，使用 jest 也是可以的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用耳语转录播客]]></title>
        <id>https://www.swyx.io/whisper-for-podcasts</id>
        <link href="https://www.swyx.io/whisper-for-podcasts"/>
        <updated>2023-07-12T04:33:06.092Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.swyx.io/whisper-for-podcasts">Using Whisper to Transcribe Podcasts</a></p><p><strong>概要：</strong></p><p>该文章是作者在邀请读者订阅他们的时事通讯，包括 AI 新闻和 DevRel/DevTools 新闻。目前已有超过 10,000 的订阅者，并会不定期更新新的帖子和项目。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - privatenumber/minification-benchmarks: 🏃‍♂️🏃‍♀️🏃 JS minification benchmarks: babel-minify, esbuild, terser, uglify-js, swc, google closure compiler, tdewolff/minify]]></title>
        <id>https://github.com/privatenumber/minification-benchmarks</id>
        <link href="https://github.com/privatenumber/minification-benchmarks"/>
        <updated>2023-07-12T04:29:20.988Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/privatenumber/minification-benchmarks">GitHub - privatenumber/minification-benchmarks: 🏃‍♂️🏃‍♀️🏃 JS minification benchmarks: babel-minify, esbuild, terser, uglify-js, swc, google closure compiler, tdewolff/minify</a></p><p><strong>概要：</strong></p><p>这篇文章是一个关于 JavaScript 压缩器性能对比的报告，涵盖了 babel-minify、esbuild、google-closure-compiler、minify-js、swc、tdewolff/minify、terser 和 uglify-js 等多种压缩器。每个压缩器都在自己的进程中执行，设定了 20 秒的超时时间，并在压缩前后进行了完整性测试。压缩器的排名依据是压缩后文件的大小。测试结果显示，在多数情况下，uglify-js 和 swc 的表现最佳，它们不仅能有效地减小文件大小，还能在较短的时间内完成压缩任务。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sass：浏览器中的Sass]]></title>
        <id>https://sass-lang.com/blog/sass-in-the-browser/</id>
        <link href="https://sass-lang.com/blog/sass-in-the-browser/"/>
        <updated>2023-07-12T01:33:34.590Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://sass-lang.com/blog/sass-in-the-browser/">Sass: Sass in the Browser</a></p><p><strong>概要：</strong></p><p>Natalie Weizenbaum 在 2023 年 7 月 7 日发布的文章中提到，Sass 现在可以直接在浏览器中运行。这得益于 Dart Sass 1.63 版本的发布，它正式支持 sass npm 包在浏览器中直接运行，不再需要通过服务器来编译 Sass。此外，Sass 还可以通过多种方式加载，包括 CommonJS require () 和 ES6 import，也可以通过打包工具（如 esbuild、Rollup、Vite 和 webpack）或者直接在浏览器中无需打包就可以加载。唯一的注意事项是，如果你在没有任何打包的情况下使用它，你需要设置一个导入地图以找到它所依赖的 Immutable 库。此外，Sass 网站上新增了一个长期期待的功能：Sass Playground，用户可以在浏览器中直接测试 Sass，并且始终使用最新版本的所有最新功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[循环依赖空间切换]]></title>
        <id>https://kizu.dev/cyclic-toggles/</id>
        <link href="https://kizu.dev/cyclic-toggles/"/>
        <updated>2023-07-11T09:35:32.067Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://kizu.dev/cyclic-toggles/">Cyclic Dependency Space Toggles</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一种新的 CSS 技术，即通过切换单个自定义属性从列表中选择值。作者首先展示了代码，然后解释了这种被称为 “循环切换” 的技术。这种技术利用了 CSS 变量的循环依赖性，使得当我们跨引用自定义属性时，所有变量都会变成 “保证无效值”。作者还探讨了这种技术的限制，包括继承、动画和命名等问题。此外，作者也提到了这种技术的使用案例，如主题选择、组件 API 等。最后，作者强调了分享和请求特定功能的重要性，因为这有助于推动 CSS 的发展。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[亲身体验Node.js测试运行器]]></title>
        <id>https://www.sonarsource.com/blog/node-js-test-runner/</id>
        <link href="https://www.sonarsource.com/blog/node-js-test-runner/"/>
        <updated>2023-07-11T09:32:39.333Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.sonarsource.com/blog/node-js-test-runner/">Hands on with the Node.js test runner</a></p><p><strong>概要：</strong></p><p>Node.js 在 18 版本中发布了一个实验性的测试运行器，并在 20 版本中将其稳定化。这意味着我们作为 JavaScript 开发者可以使用内置的测试运行器，而无需依赖第三方包，如 Mocha、Jasmine 或 Jest。这减少了维护成本和配置复杂性。此外，该测试运行器还提供了一套基础原语，供测试框架标准化使用。文章还介绍了如何使用 Node.js 测试运行器编写测试，包括创建测试文件、执行测试命令、使用断言模块、跳过测试等操作。最后，文章表示，尽管 Node.js 测试运行器还提供了内置的模拟功能、实验性的观察模式和测试覆盖率收集，但对于小型项目，测试运行器和断言模块已经足够用来编写测试套件。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 MDN Playground：让您的代码栩栩如生！| MDN 博客]]></title>
        <id>https://developer.mozilla.org/en-US/blog/introducing-the-mdn-playground/</id>
        <link href="https://developer.mozilla.org/en-US/blog/introducing-the-mdn-playground/"/>
        <updated>2023-07-11T09:31:00.549Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.mozilla.org/en-US/blog/introducing-the-mdn-playground/">Introducing the MDN Playground: Bring your code to life! | MDN Blog</a></p><p><strong>概要：</strong></p><p>Mozilla 宣布推出 MDN Playground，这是一个可以预览 HTML、CSS 和 JavaScript 的简单方式。MDN Playground 提供了快速原型设计和测试想法的无障碍方式，用户只需将代码粘贴到 playground 中，就可以立即在预览区域看到结果。此外，它还支持实时交互，使用户能够实时与代码进行交互，进行更改并立即观察其效果。MDN Playground 还扩展了代码示例，解决了在文档中阅读代码示例而无法立即试验的问题。当用户在 MDN 上遇到代码示例时，现在会找到一个方便的 “播放” 按钮，点击它将在 MDN Playground 中打开示例，准备供用户探索和修改。此外，MDN Playground 还支持协作，使得与同事合作或寻求社区帮助变得比以往任何时候都更容易。用户可以与他人分享代码 playground，让他们查看和重新混合代码。要开始使用 MDN Playground，只需访问 developer.mozilla.org/en-US/play 并深入交互式 Web 开发的世界。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[svelte.dev：全面改版]]></title>
        <id>https://svelte.dev/blog/svelte-dev-overhaul</id>
        <link href="https://svelte.dev/blog/svelte-dev-overhaul"/>
        <updated>2023-07-11T09:30:19.823Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://svelte.dev/blog/svelte-dev-overhaul">svelte.dev: A complete overhaul</a></p><p><strong>概要：</strong></p><p>Svelte 的新网站发布了，采用全新设计，并增加了多项新功能和底部导航栏。新网站对旧版进行了全面改革，文档已经分为多个页面，所有页面在右侧边栏列出各自的章节。新网站还配备了搜索栏，可以通过它在文档和 API 表面进行搜索。此外，新网站还提供 JavaScript / TypeScript 切换功能，使用户可以以自己喜欢的方式查看文档。新网站还添加了深色模式开关，并与操作系统的深色模式设置同步。此外，REPL 也被重新编写，完全类型安全，并带有深色模式等功能。新网站的首页也得到了更新，与 kit.svelte.dev 保持一致，并展示了由 @vedam 制作的美丽的 Svelte Machine。最后，新网站还实现了网站的统一，现在 svelte.dev、kit.svelte.dev 和 learn.svelte.dev 都使用相同的设计系统，彼此之间更加一致，这使得在网站之间导航变得更加容易，也使维护工作变得更加容易。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布regex 1.9 | Rust博客]]></title>
        <id>https://blog.rust-lang.org/2023/07/05/regex-1.9.html</id>
        <link href="https://blog.rust-lang.org/2023/07/05/regex-1.9.html"/>
        <updated>2023-07-07T10:00:52.513Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.rust-lang.org/2023/07/05/regex-1.9.html">Announcing regex 1.9 | Rust Blog</a></p><p><strong>概要：</strong></p><p>正则表达式小组宣布发布了 regex 1.9 版本。regex 库由 Rust 项目维护，是在 Rust 中使用正则表达式的推荐方式。其定义特性是保证最坏情况下线性时间搜索，相对于被搜索字符串的大小。虽然 regex 库的发布通常不会在此博客上公告，但由于在 1.9 版本中，其内部的大部分已经被重写，因此这个公告旨在鼓励额外的审查。如果你遇到任何问题或性能回归，请在问题跟踪器上报告或在讨论论坛上提问。新版本进行了一些 API 添加，值得一提的是 Captures::extract 方法，这将使在某些情况下获取捕获组更加方便。否则，人们应该看到的主要变化是搜索时间更快。你可以在 CHANGELOG 和更深入的关于 regex 库内部作为库的博客文章中阅读更多信息。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript Gom Jabbar]]></title>
        <id>https://frantic.im/javascript-gom-jabbar/</id>
        <link href="https://frantic.im/javascript-gom-jabbar/"/>
        <updated>2023-07-07T09:42:16.725Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://frantic.im/javascript-gom-jabbar/">JavaScript Gom Jabbar</a></p><p><strong>概要：</strong></p><p>这篇文章描述了一个拥有 10 年 JavaScript 经验的开发者面对一项任务：打开并阅读一个充满挑战的 package.json 文件。作者表达出对各种编程问题和困扰的痛苦，包括版本管理、包命名冲突、模块迁移、复杂的脚本、依赖管理等。他提到了许多具体的库和工具，如 Isomorphic JavaScript, watchman, gulp, left-pad, moment.js, eslint, postcss, jest 等，以及它们带来的问题。同时，他也表达了对维护过时依赖包、处理编译错误、配置测试运行器等任务的恐惧和压力。尽管如此，他仍然坚持下去，因为他知道这是程序员的日常工作。最后，他鼓励读者订阅他的博客以获取更多编程、软件设计和项目相关的信息。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lenz Weber-Tronic (phryneas) - 我对当前React与服务器组件争议的看法]]></title>
        <id>https://phryneas.de/react-server-components-controversy</id>
        <link href="https://phryneas.de/react-server-components-controversy"/>
        <updated>2023-07-07T09:41:07.910Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://phryneas.de/react-server-components-controversy">Lenz Weber-Tronic (phryneas) - My take on the current React & Server Components controversy</a></p><p><strong>概要：</strong></p><p>这篇文章是一位技术人员对 React Server Components（RSC）和 React 团队的沟通方式表达了自己的挫败感。他认为，虽然每个人都有自己的立场，但我们大多数人都以最不生产的方式进行交流。

文章作者身为 Apollo Client、Redux Toolkit 和 RTK Query 等库的维护者，他发现帮助用户变得更加困难。因为人们遇到了一些奇怪的问题，他无法为他们解决所有问题。比如，StackOverflow 上的用户面临着他们无法理解的错误信息。他们在 React 主页上创建了一个新的 React 项目，然后只是应用了默认设置。他们不知道什么是 Server Component，但他们现在正在编写 Server Components。而这三个库在 Server Components 中的工作方式与之前完全不同。

作者还提出了一些建议，包括在 Canaries 中隐藏实验性功能，试图使客户端和服务器用户体验保持一致，以及提供一些缺失的 API 等。他希望通过这篇文章引起人们的关注，并愿意就这些想法进行交谈并提供帮助。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在2023年与SVG-in-JS决裂]]></title>
        <id>https://kurtextrem.de/posts/svg-in-js</id>
        <link href="https://kurtextrem.de/posts/svg-in-js"/>
        <updated>2023-07-07T09:40:25.177Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://kurtextrem.de/posts/svg-in-js">Breaking Up with SVG-in-JS in 2023</a></p><p><strong>概要：</strong></p><p>去年 12 月，一篇题为 “为什么我们要和 CSS-in-JS 分手” 的文章引起了轰动，解释了为什么你不再希望在 JS 包中包含 CSS。然而，现在 JS 包中不仅有 CSS，还有 SVG，正如 Preact 的作者 Jason Miller 所展示的那样：“请不要将 SVG 作为 JSX 导入，这是最昂贵的形式，比其他技术至少贵 3 倍，而且会影响运行时（渲染）性能和内存使用。” 他还指出，一个流行网站的包中，几乎 50% 都是 SVG 图标（250kb），大部分都没有用到。因此，我们需要把 SVG 从 JS 包中移出，重新回归到 HTML 中。本文将探讨在保持 JS 包小巧和高效的同时，更好地使用 SVG 的技术。这些技术包括：使用 < img > 标签加载 SVG、使用 < use > 创建 SVG 精灵、通过 CSS 和 currentcolor 移除更多的 JS、使用 React 的服务器组件等。另外，如果遇到 CORS 问题，可以使用 CSS 进行救援。此外，我们还需要权衡性能和加载时间，决定是否内联 SVG。最后，我们可以使用一些工具和代码片段来实现这些操作。总的来说，通过使用这些技巧，你可以使你的 JavaScript 包变得更小、更高效，这对于旧设备和慢速设备非常有帮助，也使互联网变得更加包容。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js应用程序路由器更新]]></title>
        <id>https://nextjs.org/blog/june-2023-update</id>
        <link href="https://nextjs.org/blog/june-2023-update"/>
        <updated>2023-07-06T03:02:01.177Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nextjs.org/blog/june-2023-update">Next.js App Router Update</a></p><p><strong>概要：</strong></p><p>Next.js 团队正在专注于改进性能、稳定性和开发者教育。他们已经设计了一种新的基础设施 ——App Router，以满足更大规模应用的需求。这个新工具允许开发者逐步迁移到新的 API，而不需要对整个应用进行重写。目前，团队正在探索更多使增量采用变得更容易的机会。在性能方面，他们正在专注于提高本地迭代速度、生产构建时间和无服务器性能。他们还在努力优化现有的 webpack 架构的性能，并计划用 Turbopack 替换 webpack。为了改善稳定性，他们正在修复 App Router 中的 bug，并感谢社区的反馈。最后，他们正在重新编写 Next.js 的文档，并计划发布更多的教育资源，以帮助开发者理解新的特性和概念。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[npm生态系统核心的巨大错误]]></title>
        <id>https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem</id>
        <link href="https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem"/>
        <updated>2023-07-06T03:01:33.182Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem">The massive bug at the heart of the npm ecosystem</a></p><p><strong>概要：</strong></p><p>文章是由前 npm CLI 团队的工程经理撰写，主要讨论了 npm 包的 "manifest confusion" 问题。npm 包的清单与其 tarball 独立发布，且从未完全验证过它们的内容是否一致。这导致任何使用公共注册表的工具或洞察可能易受攻击或不准确，恶意行为者可以在直接或转移依赖项中隐藏恶意软件和脚本而不被检测到。作者认为，应该进一步调查以确定受影响的注册表条目的范围，并尽快记录 npm 公共注册表 API 及其各自的请求 / 响应对象。同时，建议开发者联系任何已知依赖于 npm 注册表的 manifest 数据的工具作者 / 维护者，并确保他们在适当时开始使用包的内容作为元数据。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高级macOS命令 - saurabhs.org]]></title>
        <id>https://saurabhs.org/advanced-macos-commands</id>
        <link href="https://saurabhs.org/advanced-macos-commands"/>
        <updated>2023-07-06T03:00:40.075Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://saurabhs.org/advanced-macos-commands">Advanced macOS Commands - saurabhs.org</a></p><p><strong>概要：</strong></p><p>文章介绍了 macOS 系统中的一些高级命令行工具，包括 Unix 标准工具和 macOS 特有的功能。这些工具包括：caffeinate 用于设置 Mac 的睡眠行为；pbcopy 和 pbpaste 用于与系统剪贴板交互；networkQuality 用于测量互联网速度；sips 用于图像操作；open 用于打开文件和应用程序；textutil 是文档文件转换器；mdfind 和 mdls 用于使用 Spotlight 进行搜索；screencapture 用于截屏；taskpolicy 用于控制进程的调度；say 是文本转语音引擎；pmset 用于配置电源管理；networksetup 用于配置网络设置；softwareupdate 用于管理操作系统更新；system_profiler 用于查看系统信息。每个工具都有详细的使用说明和例子，可以通过运行 man <command> 查看完整的文档。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[现代JavaScript中的安全数据获取]]></title>
        <id>https://www.builder.io/blog/safe-data-fetching</id>
        <link href="https://www.builder.io/blog/safe-data-fetching"/>
        <updated>2023-07-06T02:59:43.875Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/safe-data-fetching">Safe Data Fetching in Modern JavaScript</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了 JavaScript 中 Fetch 函数的使用方法和常见问题，作者指出直接使用 Fetch 可能会遇到错误处理不当和信息丢失等问题。为了解决这些问题，作者提出了创建自定义错误类和封装 Fetch 函数的方法，使得错误处理更加智能和方便。但是，这种方法仍然需要开发者每次都写一定量的样板代码。因此，作者推荐使用 Axios、Redaxios 和 Wretch 等开源解决方案，它们可以自动处理上述问题，同时还有更多的文档、测试和社区支持。无论选择哪种方式，作者强调要正确地获取数据，以保证用户体验和团队效率。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[现代Javascript：过去10年中你错过的一切]]></title>
        <id>https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years</id>
        <link href="https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years"/>
        <updated>2023-07-06T02:59:21.311Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years">Modern Javascript: Everything you missed over the last 10 years</a></p><p><strong>概要：</strong></p><p>这篇文章是一份 JavaScript 的速查表，作者总结了近年来在现代浏览器中广泛支持的 JavaScript 新语法和功能。包括内置数组函数、const/let 关键字、空值合并和可选链运算符、Async/Await 关键字、箭头函数、for...of 循环、异步迭代、类、get/set 函数、函数默认参数、命名参数、剩余参数、Object.assign 和展开运算符、解构、简写函数、Promise.all、模板字面量、代理以及模块导入 / 导出等。每个主题都附有示例代码和进一步文档的链接。此外，作者还提供了其他参考资源，如 Map、Set、生成器、严格模式、数组方法、对象静态方法、反射、URL 等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ember 5.0发布]]></title>
        <id>https://blog.emberjs.com/ember-5-0-released/</id>
        <link href="https://blog.emberjs.com/ember-5-0-released/"/>
        <updated>2023-07-06T02:53:30.631Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.emberjs.com/ember-5-0-released/">Ember 5.0 Released</a></p><p><strong>概要：</strong></p><p>EmberJS 5.0 代表了开发者对 Ember 生态系统稳定性和可靠性的承诺。Ember 团队努力去除所有弃用的部分，并向 Polaris 迈进。这篇文章介绍了我们的发布策略，如何升级，预期结果，以及被移除的过时 API。
这是根据 RFC 830 提出的新发布策略和目标下的第一个主要版本。总结来说，每 12 个小版本，Ember 将发布一个新的主要版本，移除任何针对该主要版本的过时代码。
在引入新功能时，Ember 通常旨在在小版本中发布新功能，同时为现有代码提供向后兼容性，同时让开发者有机会尝试新功能。这种方法减少了团队面临的主要升级挑战，相比于制作带有大量新功能的大型、突破性、引人注目的主要版本。
在 Ember 4.x 的小版本中，我们添加了一些特性（当然还有各种错误修复）：
在 Ember 4.1 中，我们发布了一系列改善生活质量的改进：
缓存昂贵 getter 的 @cached 装饰器
@service 装饰器，所以你不再需要导入 {inject as service}
Ember 路由器上的刷新方法，使整个当前路由树的数据刷新更容易
在 Ember 4.4 中，我们发布了一个 {{unique-id}} 助手，使编写可访问表单更容易，并通过改进 setupTest 的蓝图使测试定制更容易。
在 Ember 4.5 中，我们使得可以使用普通的 JavaScript 函数作为助手：不再需要用 helper () 包裹它们！
我们还发布了一个新的测试原语，renderSettled</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CommonJS是不会消失的]]></title>
        <id>https://bun.sh/blog/commonjs-is-not-going-away</id>
        <link href="https://bun.sh/blog/commonjs-is-not-going-away"/>
        <updated>2023-07-06T02:48:37.350Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bun.sh/blog/commonjs-is-not-going-away">CommonJS is not going away</a></p><p><strong>概要：</strong></p><p>文章讨论了 JavaScript 的未来，特别是关于 CommonJS 和 ES 模块（ESM）的使用。尽管 ESM 被视为 JavaScript 的未来，但 CommonJS 仍然有其存在的价值。数据显示，ESM 在 npm 上的使用率为 9%，而 CJS（CommonJS）的使用率为 73.6%。CommonJS 在 2009 年开发并由 Node.js 推广，它允许文件将属性分配给名为 exports 的特殊变量，然后其他文件可以通过特殊的 require 函数引用 exports 对象的属性。相比之下，ESM 在 2015 年作为 ES6 的一部分引入，它使用 export 关键字声明其导出，并使用 import 关键字从其他文件导入。与 CommonJS 不同，ESM 设计用于在浏览器中工作，预期文件会通过网络加载，这就是 ES 模块被称为异步的原因。文章还指出，CommonJS 启动速度更快，允许动态模块加载，并且已经在 npm 发布了数百万个模块。最后，Bun v0.6.5 开始原生实现 CommonJS，而且 Bun 也增加了对__esModule 注解的支持，这是 CommonJS 模块表明 exports.default 应被解释为默认导出的事实标准方式。总的来说，CommonJS 已经在这里并将继续存在，Bun 将其视为一等公民。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Remotion 4.0 | Remotion | 在React中以编程方式制作视频]]></title>
        <id>https://www.remotion.dev/blog/4-0</id>
        <link href="https://www.remotion.dev/blog/4-0"/>
        <updated>2023-07-06T02:47:30.098Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.remotion.dev/blog/4-0">Remotion 4.0 | Remotion | Make videos programmatically in React</a></p><p><strong>概要：</strong></p><p>Remotion 4.0 发布了最大的更新，为每个工作流程带来了重大改进。这次更新引入了 Remotion Studio，并增加了一些方便的功能。现在，用户可以通过图形界面直接编辑数字、字符串、数组、对象、枚举和日期等属性，甚至可以可视化和编辑嵌套的数据结构。此外，该版本还增加了渲染按钮，用户只需按下按钮就可以渲染资产。新版本还使用 Rust 二进制文件加速了当前和未来的功能，并内置了 FFmpeg。此外，Remotion 4.0 还提供了对 WebP 和 PDF 生成的支持，简化了数据驱动视频的制作，并升级了所有模板以使用新特性。此外，该版本还增加了许多新功能，包括 @remotion/rive 包、@remotion/shapes 包、@remotion/tailwind 包、音频编解码器的调整、Lambda 的改进、新的 PHP 和 Go SDKs、播放器的改进、ES 模块支持、字体选择器、新的核心 API 等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用Rust写一个Node库]]></title>
        <id>https://blog.metlo.com/writing-a-node-library-in-rust/</id>
        <link href="https://blog.metlo.com/writing-a-node-library-in-rust/"/>
        <updated>2023-07-06T02:34:14.724Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.metlo.com/writing-a-node-library-in-rust/">Writing a Node Library in Rust</a></p><p><strong>概要：</strong></p><p>Metlo 是一个开源 API 安全工具，可以在 15 分钟内设置完成，对你的端点进行清单，检测恶意行为者并实时阻止恶意流量。通过使用 Rust 编程语言，Metlo 能够创建一个 C 兼容库，这样就可以用各种 FFI 库或低延迟通信系统（如 GRPC 或管道）来使用它。文章中以 Node.js 为例，介绍了如何利用基于 Rust 的库 Neon 来实现，并探讨了 Rust 在处理不同任务时的性能提升。Neon 可以让我们在 Node.js 代码中运行 Rust 代码。Metlo 使用这些绑定来支持多个框架，几乎无需配置即可使用。在 Metlo，他们能够支持所有三种 node 框架，因为他们的核心逻辑现在都是用 rust 编写的。此外，他们的 rust 代理是内存安全的，非阻塞的，并且最多只会增加几百微秒的延迟。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bun v0.6.10]]></title>
        <id>https://bun.sh/blog/bun-v0.6.10</id>
        <link href="https://bun.sh/blog/bun-v0.6.10"/>
        <updated>2023-06-28T14:24:16.954Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bun.sh/blog/bun-v0.6.10">Bun v0.6.10</a></p><p><strong>概要：</strong></p><p>我们正在招聘 C/C++ 和 Zig 工程师来构建 JavaScript 的未来！加入我们的团队→最近，我们对 Bun 进行了许多更改，以下是一些重要更新：

v0.6.0 - 引入 bun build，Bun 的新 JavaScript 打包器。
v0.6.2 - 性能提升：JSON.parse 速度提高 20%，Proxy 和 arguments 速度提高 2 倍。
v0.6.3 - 实现 node:vm，对 node:http 和 node:tls 进行了大量修复。
v0.6.4 - 实现 require.cache，process.env.TZ，并使 bun test 速度提高 80%。
v0.6.5 - 对 CommonJS 模块的原生支持（之前，Bun 将 CJS 转换为 ESM）。
v0.6.6 - bun test 的改进，包括 Github Actions 支持，test.only ()，test.if ()，describe.skip () 以及 15 + 个 expect () 匹配器；还有使用 fetch () 进行文件上传。
v0.6.7 - Node.js 兼容性改进，以解决 Discord.js、Prisma 和 Puppeteer 的问题。
v0.6.8 - 引入 Bun.password，bun test 中的 mocking 和 toMatchObject ()。
v0.6.9 - 内存使用减少，支持非 ascii 文件名。

此外，我们对 CommonJS 的支持也有所改善，使得在 Bun 中加载 npm 包更加可靠。我们修复了与加载 CommonJS 模块相关的许多崩溃，并改进了我们的 CommonJS 模块加载器，使其更兼容 Node.js。

我们还修复了 Bun 客户端 WebSocket 实现中的一个编码错误，这可能会导致 latin1 编码的文本帧被截断。感谢这些更改，puppeteer 在 Bun 中的支持已经得到改善。

另外，我们对 bun:test 进行了改进，现在支持更多的匹配</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布v6.0.0 - styled-components/styled-components]]></title>
        <id>https://github.com/styled-components/styled-components/releases/tag/v6.0.0</id>
        <link href="https://github.com/styled-components/styled-components/releases/tag/v6.0.0"/>
        <updated>2023-06-28T14:22:35.169Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/styled-components/styled-components/releases/tag/v6.0.0">Release v6.0.0 · styled-components/styled-components</a></p><p><strong>概要：</strong></p><p>这篇文章是关于一个版本更新的说明，主要包含以下改动：

在此版本中进行了一些修复和改进，例如防止样式属性上的 prop 渗漏，通过 "CSS" 命名空间来传输 csstype，提升 stylis 至 4.3 版本，并减少了一些不必要的分支逻辑。

在 v6 版本中有一些重大变化，包括现在使用 stylis v4（如果使用 stylis-plugin-rtl，你需要升级到新版本），styled-components 现在提供自己的类型；如果你过去安装过 @types/styled-components，你会想要移除它。此外，还删除了 $as 和 $forwardedAs props（使用 as 或 forwardedAs 替代），以及自动 prop 过滤；对于你不希望传递给子组件 / HTML 的内容，使用瞬态 props（$ 前缀）。

StyleSheetManager 也做出了一些更改，比如用 enableVendorPrefixes prop 替换了 disableVendorPrefixes，取消了自动供应商前缀；如果你需要支持旧的浏览器，可以使用上述 prop 轻松重新启用。

此外，还删除了已弃用的 withComponent API（87f511a）；现在需要使用 "as" prop。并且需要 node >= 14。

完整的更改日志可以查看：v5.3.7...v6.0.0。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对Svelte(Kit)的看法，一年后30亿次的请求]]></title>
        <id>https://claudioholanda.ch/en/blog/svelte-kit-after-3-billion-requests/</id>
        <link href="https://claudioholanda.ch/en/blog/svelte-kit-after-3-billion-requests/"/>
        <updated>2023-06-28T02:20:57.195Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://claudioholanda.ch/en/blog/svelte-kit-after-3-billion-requests/">Thoughts on Svelte(Kit), one year and 3 billion requests later</a></p><p><strong>概要：</strong></p><p>去年，我的公司接到了建设一个新闻网站的任务。自从项目上线以来，它经历了显著的观众增长，每天处理数十万的访客。在过去的 12 个月中，每个访客都在页面及其组件上进行导航和交互，大约产生了 30 亿次请求。

我选择 Svelte 作为这个项目的开发框架，并分享了我认为使用 Svelte 和 SvelteKit 工作的好坏两面。

我们的客户给我们带来了一个多年前制作的网站，该网站采用了旧技术，难以添加新功能，性能差，且垂直基础设施昂贵。经过几次会议，我们得出的结论是，最好的方法是暂停旧网站的开发，使用最佳技术和实践从头开始构建一个新的。考虑到这个项目的可塑性和可扩展性需求，还需要从零开始构建一个新的 CMS。

SvelteKit 具有强大的 SSR 解决方案，因此我选择了它。尽管 React 是一个拥有庞大社区和繁荣生态系统的优秀反应式库，但一旦你离开这条路径，你可能会在某个时候遇到麻烦。而有些项目你不想（或不能）因为你选择的 UI 开发工具而冒险遇到麻烦。所以我们选择了 Svelte/SvelteKit 而不是 React/Next.js。

然而，Svelte 也存在一些问题，比如缺乏 “Svelte” 组件，很多项目都是一个人的军队，缺乏已经建立的模式和优秀的教程等。但总的来说，Svelte 对于我们的团队</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - mrjooz/password-generator: 密码生成工具]]></title>
        <id>https://github.com/mrjooz/password-generator</id>
        <link href="https://github.com/mrjooz/password-generator"/>
        <updated>2023-06-28T02:16:42.518Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/mrjooz/password-generator">GitHub - mrjooz/password-generator: 密码生成工具</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了在使用 Git 时，如果已经存在与提供的分支名相同的标签，可能会导致一些问题。因为很多 Git 命令同时接受标签和分支名，所以创建这个分支可能会引发意外的行为。作者询问读者是否确定要创建这个分支。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过使用Node.js的AsyncLocalStorage来避免参数钻取| pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/avoid-parameter-drilling-by-using-the-node-js-asynclocalstorage/</id>
        <link href="https://pawelgrzybek.com/avoid-parameter-drilling-by-using-the-node-js-asynclocalstorage/"/>
        <updated>2023-06-28T02:12:40.147Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/avoid-parameter-drilling-by-using-the-node-js-asynclocalstorage/">Avoid parameter drilling by using the Node.js AsyncLocalStorage | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>虽然全局变量被认为是一种不好的做法，但它可能是共享上下文的最简单形式。在这个例子中，我定义了全局变量 context，并用它在主函数和 logger 函数之间共享 uuid 值。这种方法对于同步代码来说工作得很好，但是当我们引入异步操作时，问题就出现了。让我通过添加一个 http 服务器来说明这个问题：每个后续的请求都会更新全局上下文，logger 函数总是记录 uuid 的最后一个值，而不一定是与请求相关的那个值。将 uuid 作为参数传递给 logger（参数钻取）或将其粘贴到 req 对象是解决此问题的常见解决方案。尽管如此，它们都可能很快变得繁琐。

自 Node.js 13.10 以来，AsyncLocalStorage 类提供了一种在 web 请求或任何其他异步操作的生命周期内存储特定上下文数据的方法。它类似于不同编程语言中使用的线程本地存储（TLS）概念。让我们利用这个 API 并重写我们的示例：现在，所有连续的请求都将记录正确的 uuid 值，而无需担心相互干扰。关联 ID 只是 AsyncLocalStorage API 的许多用例之一。它可以用于存储当前用户、事务 ID、报告数据等。

Node.js AsyncLocalStorage API 的广泛用例激发了社区成员提出 JavaScript 的异步上下文。我希望这个提案能够迅速成为 ECMAScript 标准的一部分。

感谢 Syntax.fm 的一集启发了我去探索这个主题并写下这篇文章。感谢 Wes 和 Scott 创造的优秀内容！</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在焦点上刷新React服务器组件]]></title>
        <id>https://buildui.com/recipes/refresh-react-server-component-on-focus</id>
        <link href="https://buildui.com/recipes/refresh-react-server-component-on-focus"/>
        <updated>2023-06-28T02:08:39.348Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://buildui.com/recipes/refresh-react-server-component-on-focus">Refresh React Server Component on Focus</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 <RefreshOnFocus /> 的组件，它可以被插入到 Next.js 应用中的任何 React 服务器组件中，使其在浏览器窗口被聚焦时刷新。页面上的卡片使用与它们的动态数据相关的键来运行 CSS 动画，每当它们的数据发生变化时都会触发动画。文章还提供了代码和使用方法，以及使用的库 ——Next.js 13 App Directory。同时，文章也邀请读者加入 Build UI Newsletter，以便在发布新的配方时接收通知。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布v1.18.0 - remix-run/remix]]></title>
        <id>https://github.com/remix-run/remix/releases/tag/remix%401.18.0</id>
        <link href="https://github.com/remix-run/remix/releases/tag/remix%401.18.0"/>
        <updated>2023-06-28T02:06:28.873Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/remix-run/remix/releases/tag/remix%401.18.0">Release v1.18.0 · remix-run/remix</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了 Remix 1.18.0 的新特性和改进。包括：

1. 稳定的 V2 开发服务器：这个新版本正式稳定化了 "New Dev Server"，并带有 HMR/HDR。

2. JSON/Text 提交：如果你不是 FormData 的粉丝，Remix 1.18.0 更新了对 react-router-dom@6.14.0 的支持，它带来了在 useSubmit/fetcher.submit 中选择 application/json 或 text/plain 编码的支持，并添加了相应的 navigation.json/navigation.text 和 fetcher.json/fetcher.text 字段。

3. 视口驱动的预获取：Link 组件现在可以通过新的 <Link prefetch="viewport"> 属性值自动预获取路由数据和 JS 模块。

4. 更新的 ESLint 配置：我们已经更新了 @remix-run/eslint-config，以继承来自 @typescript-eslint/recommended 的推荐规则集，而不是手动维护我们自己的 TS 相关规则。

5. 性能改进：我们过去几周大量投入到性能提升上，你可能会看到一些改善（大约快 10%），但我们也亲眼看到在一些极端情况下构建和重建时间大幅缩短。

此外，还修复了一些问题，包括使用 React 17 时的类型问题、pathless 布局路由下的嵌套路径段的错误等，并更新了 React Router 依赖项至最新版本。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用键盘锁API实现更好的全屏模式 - Chrome开发人员]]></title>
        <id>https://developer.chrome.com/blog/better-full-screen-mode/</id>
        <link href="https://developer.chrome.com/blog/better-full-screen-mode/"/>
        <updated>2023-06-27T03:01:02.572Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/blog/better-full-screen-mode/">Better full screen mode with the Keyboard Lock API - Chrome Developers</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了如何使用键盘锁 API 来在全屏模式下捕获 Escape 键。作者指出，当用户在全屏游戏中打开一个对话框，本能地用 Escape 键取消时，可能会被强制退出全屏模式，这是由于对话框和全屏模式对 Escape 键的 “争夺”。默认情况下，全屏模式总是胜出。但通过使用键盘锁 API，可以让对话框成为 Escape 键的 “赢家”。该 API 可以在 navigator.keyboard 上使用，lock () 方法可以在启用后捕获物理键盘上所有键的按键。此方法只能捕获操作系统授权访问的键，幸运的是 Escape 键就是其中之一。如果你的应用有全屏模式，可以在请求全屏时捕获 Escape 键，以此作为渐进增强的手段。当用户离开全屏模式时，通过 Keyboard 接口的 unlock () 方法解锁（即不再捕获）键盘。这样，在全屏模式下，按下 Escape 键将默认取消对话框。如果用户长按 Escape 键，仍然可以退出全屏模式。</p>]]></content>
    </entry>
</feed>