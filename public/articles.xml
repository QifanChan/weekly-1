<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-05-17T05:34:45.831Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[馒头捆绑器]]></title>
        <id>https://bun.sh/blog/bun-bundler</id>
        <link href="https://bun.sh/blog/bun-bundler"/>
        <updated>2023-05-17T04:41:23.198Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://bun.sh/blog/bun-bundler">The Bun Bundler</a></p><p><strong>概要：</strong></p><p>Bun bundler 是一个快速的本地打包工具，现在已经进入了 beta 测试阶段。它可以通过 bun build CLI 命令或新的 Bun.build () JavaScript API 来使用。该工具可以用于构建前端应用程序，并提供了内置的 Bun.build () 函数和 bun build CLI 命令。文章指出，JavaScript 生态系统的复杂性不断增加，如何运行 TypeScript 文件、如何为生产环境构建 / 打包代码等问题使得开发变得越来越复杂。Bun bundler 的目标是将打包引入 JavaScript 运行时，从而使前端和全栈代码的发布更简单、更快速。该工具的优点包括：插件执行快速、生成预转换文件以提高运行性能、统一的插件 API、构建输出数组、支持 ESM 模块系统、支持 tree-shaking、支持源码映射、支持 JS 压缩器等。未来，Bun bundler 还将与 Bun 的 HTTP 服务器 API（Bun.serve）集成，从而实现用简单的声明式 API 代替</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[充满惊喜的JavaScript生态圈]]></title>
        <id>https://fly.io/blog/js-ecosystem-delightfully-wierd/</id>
        <link href="https://fly.io/blog/js-ecosystem-delightfully-wierd/"/>
        <updated>2023-05-16T01:46:08.086Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://fly.io/blog/js-ecosystem-delightfully-wierd/">The JavaScript Ecosystem is Delightfully Weird</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了 JavaScript 生态系统的奇怪之处。作者认为，JavaScript 在不到 10 年前非常糟糕，缺乏许多现代语言特性，而且主要运行在浏览器的 DOM 中，很难处理。然而，随着时间的推移，JavaScript 的发展迅速改善，出现了许多编译器和转换工具，如 CoffeeScript、Babel 和 esbuild，使得开发人员可以使用更加现代化的语言特性来编写 JavaScript 代码。同时，JavaScript 生态系统也变得越来越庞大，涵盖了许多框架和库，但是这些框架和库并没有完全遵循 ECMAScript 标准，而是进行了一些自己的扩展和修改，例如 TypeScript 和 JSX。最近，React Server Components (RSC) 出现了，它通过与打包工具的合作，实现了将 React 组件编译成 HTML 或 JSON 流的功能，从而引发了人们对于 JavaScript 语言本身的重新思考。总</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用Qt和Rust构建一个桌面应用程序 - LogRocket博客]]></title>
        <id>https://blog.logrocket.com/build-desktop-app-qt-rust/</id>
        <link href="https://blog.logrocket.com/build-desktop-app-qt-rust/"/>
        <updated>2023-05-15T07:17:16.737Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.logrocket.com/build-desktop-app-qt-rust/">Build a desktop app with Qt and Rust - LogRocket Blog</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 Rust 和 Qt 框架构建桌面应用程序。作者首先讨论了桌面应用程序的优点，然后介绍了 Rust 在桌面应用程序开发中的流行程度和可靠性。接着，作者演示了如何使用 Qt 和 Rust 构建一个简单的 “Hello World” 应用程序，并逐步添加了加密和解密功能。最后，作者还介绍了如何使用 GitHub CI 工作流程来确保代码正确性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[将Next.js App Router用于生产的5条经验之谈]]></title>
        <id>https://www.inngest.com/blog/5-lessons-learned-from-taking-next-js-app-router-to-production</id>
        <link href="https://www.inngest.com/blog/5-lessons-learned-from-taking-next-js-app-router-to-production"/>
        <updated>2023-05-15T04:52:42.154Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.inngest.com/blog/5-lessons-learned-from-taking-next-js-app-router-to-production">5 Lessons Learned From Taking Next.js App Router to Production</a></p><p><strong>概要：</strong></p><p>Next.js 13 的新功能 App Router 引入了 Nested Layouts、Server Components 和 Streaming 等多项新特性，是第一个开源实现 React 18 原语的工具。从 Next.js 13.4 开始，App Router 已被认为是生产就绪状态。使用 App Router 可以更轻松地在路由之间共享 UI、更好地利用服务器组件、更快地展示页面部分内容以及准备未来。但是，在应用 App Router 时需要注意两个缓存、URL 搜索参数在布局服务器组件中的问题、文件结构的优点以及学习新技术和资源有限的挑战。建议先仔细阅读官方文档，如果遇到问题可以查看 GitHub 和 Twitter 上的讨论，并且分享经验和解决方案有助于建立更加实质性的知识库。总体而言，采用 App Router 可以提高用户和开发者的体验，但需要耐心和深入挖掘。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解useRef和useState用于跟踪React中的组件渲染次数]]></title>
        <id>https://peterkellner.net//2023/05/05/Understanding-useRef-and-useState-for-Tracking-Component-Render-Count-in-React/</id>
        <link href="https://peterkellner.net//2023/05/05/Understanding-useRef-and-useState-for-Tracking-Component-Render-Count-in-React/"/>
        <updated>2023-05-15T04:52:16.782Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://peterkellner.net//2023/05/05/Understanding-useRef-and-useState-for-Tracking-Component-Render-Count-in-React/">Understanding useRef and useState for Tracking Component Render Count in React</a></p><p><strong>概要：</strong></p><p>本文介绍了在 React 中使用 useRef 和 useState 来追踪组件渲染次数的实际例子。通过自定义一个名为 useComponentRenderCount 的 hook，使用 useRef 来存储渲染次数，并使用 useState 来管理组件内的不同状态值。通过将状态值分开控制，可以提高代码可读性并更轻松地管理每个值的状态更新。理解何时使用 useRef 以及如何与 useState 一起使用对于管理复杂的组件行为至关重要。在开发 React 应用程序时，需要平衡性能和功能，才能创建高质量的应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反应全局状态为局部状态]]></title>
        <id>https://webup.org/blog/react-global-state-as-local-state/</id>
        <link href="https://webup.org/blog/react-global-state-as-local-state/"/>
        <updated>2023-05-15T04:51:55.382Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://webup.org/blog/react-global-state-as-local-state/">React Global State as Local State</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一种基于 React 的全局状态管理方案，使用 useGlobalState 钩子来读取全局存储对象，并在其更新时强制所有已订阅的组件重新渲染。相比于 Redux 和 Context，这种方案更加简单且没有繁琐的代码。该方案不需要依赖库，支持测试和 TypeScript。文章详细介绍了如何实现这个钩子，包括 JavaScript 和 TypeScript 的实现以及测试用例。作者表示这种方案虽然简单，但也具有可扩展性，可以在其上构建中间件、错误处理和动作等功能。作者在几个项目中尝试了 createGlobalState，目前已成为他的默认选择。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[罗马 v12.1.0]]></title>
        <id>https://rome.tools/blog/2023/05/10/rome12_1/</id>
        <link href="https://rome.tools/blog/2023/05/10/rome12_1/"/>
        <updated>2023-05-15T02:08:46.595Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://rome.tools/blog/2023/05/10/rome12_1/">Rome v12.1.0</a></p><p><strong>概要：</strong></p><p>Rome v12.1.0 发布了，支持新的 Stage 3 装饰器、VCS 集成和新的 lint 规则。现在，Rome 可以解析和格式化大多数框架中的装饰器，并且支持 git VCS 集成。此外，还添加了许多新的 lint 规则，并提供了一个新的命令来更新配置文件。还有一个新的 CLI 帮助提示库，可以从源代码生成输出。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[掌握 TypeScript 中的 infer - JavaScript in Plain English]]></title>
        <id>https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86</id>
        <link href="https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86"/>
        <updated>2023-05-14T16:28:12.103Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86">Mastering infer in TypeScript - JavaScript in Plain English</a></p><p><strong>概要：</strong></p><p>本文介绍了 TypeScript 中 infer 关键字的用法，它可以从现有的代码中提取和推断类型。使用 infer 关键字可以增加代码的类型安全性、效率和组织性。infer 关键字可以在泛型类型、函数参数和返回值、映射类型中使用，但只能在条件类型中使用。同时，文章还提供了一些实际的例子来展示 infer 关键字的使用方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Dart 3 - Dart - Medium]]></title>
        <id>https://medium.com/dartlang/announcing-dart-3-53f065a10635</id>
        <link href="https://medium.com/dartlang/announcing-dart-3-53f065a10635"/>
        <updated>2023-05-14T16:11:21.730Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://medium.com/dartlang/announcing-dart-3-53f065a10635">Announcing Dart 3 - Dart - Medium</a></p><p><strong>概要：</strong></p><p>Google 在 I/O 2023 上宣布了 Dart 3 的发布，这是迄今为止最大的 Dart 版本，包括三个主要进展：100％的声音空安全、记录、模式和类修饰符的重大新语言特性以及通过 Wasm 编译实现对 Web 的本地代码支持。其中，100％空安全意味着 Dart 具有可靠的类型系统，可以避免某些编码错误，如空指针异常，并允许编译器和运行时优化代码。此外，Dart 3 还引入了记录、模式和类修饰符等新功能，使 Dart 更加表达和精简，同时提供了一种详细控制大型 API 表面的方法。最后，Dart 3 还提供了未来的预览，即通过 Wasm 编译实现对 Web 的本地代码支持。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Fresh、OpenAI 和 Supabase 构建您自己的 ChatGPT 风格文档搜索。]]></title>
        <id>https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh</id>
        <link href="https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh"/>
        <updated>2023-05-13T07:30:37.930Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh">Build your own ChatGPT-style doc search with Fresh, OpenAI, and Supabase</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 OpenAI Text Completion API 创建自定义的 ChatGPT 风格文档搜索，以及如何在 Supabase 的免费托管 PostgresDB 中存储嵌入和执行向量相似性搜索。文章详细介绍了构建自定义 ChatGPT 的四个步骤，包括预处理知识库、存储嵌入、运行时执行向量相似性搜索和将内容注入到 OpenAI GPT-3 文本完成提示中并将响应流式传输给客户端。此外，文章还提供了一些有关使用 OpenAI 和 ChatGPT 构建的其他资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Deno 在 Rust 中运行 JavaScript]]></title>
        <id>https://austinpoor.com/blog/js-in-rs</id>
        <link href="https://austinpoor.com/blog/js-in-rs"/>
        <updated>2023-05-13T07:28:48.597Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://austinpoor.com/blog/js-in-rs">Running JavaScript in Rust with Deno</a></p><p><strong>概要：</strong></p><p>本文介绍了作者创建的一个名为 “js-in-rs” 的基于 Rust 的 CLI 工具，用于使用 JavaScript 表达式过滤文件。与 grep 工具使用正则表达式不同，js-in-rs 使用 JavaScript 表达式进行过滤。文章详细介绍了 js-in-rs 的工作原理和代码实现，并探讨了在 Rust 应用程序中运行 JavaScript 代码的潜在应用，例如 Web 服务器、数据管道和数据库用户定义函数等。此外，作者还提到 Deno 运行时具有有趣的权限管理方法，允许用户开启或关闭运行时功能，以防止恶意代码访问资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery 3.7.0 发布：保持顺序]]></title>
        <id>https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/</id>
        <link href="https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/"/>
        <updated>2023-05-13T07:28:14.090Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/">jQuery 3.7.0 Released: Staying in Order</a></p><p><strong>概要：</strong></p><p>jQuery 3.7.0 发布了，包含了 bug 修复、新方法和性能提升等内容。此次更新中，jQuery 删除了其长期使用的选择器引擎 Sizzle，并将其代码直接放入了 jQuery 核心中，以便为未来版本的选择做准备。同时，jQuery 增加了一个可链接的.uniqueSort () 方法，解决了某些情况下.prevAll () 方法返回元素顺序相反的问题。jQuery 还添加了对更多 CSS 属性的支持，避免自动添加 “px” 单位。此外，该版本还优化了.manipulation () 方法的性能，修复了在 IE 中焦点事件异步触发的问题。该版本与之前的版本兼容，可以从 jQuery CDN 或 npm 获取。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Vue 3.3 | Vue 点击]]></title>
        <id>https://blog.vuejs.org/posts/vue-3-3</id>
        <link href="https://blog.vuejs.org/posts/vue-3-3"/>
        <updated>2023-05-13T07:13:47.996Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.vuejs.org/posts/vue-3-3">Announcing Vue 3.3 | The Vue Point</a></p><p><strong>概要：</strong></p><p>Vue 3.3 "Rurouni Kenshin" has been released, with a focus on improving developer experience when using Vue with TypeScript. The update includes improvements to SFC <script setup> usage with TypeScript, imported and complex types support in macros, generic components, more ergonomic defineEmits, typed slots with defineSlots, and experimental features such as reactive props destructure and defineModel. Other notable features include defineOptions, better getter support with toRef and toValue, and JSX import source support. Maintenance infrastructure improvements have also been made, allowing for faster builds, tests, and types generation. The Vue team plans to make smaller and more frequent feature releases starting in 2023.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 协调：它是如何工作的，为什么我们应该关心]]></title>
        <id>https://www.developerway.com/posts/reconciliation-in-react</id>
        <link href="https://www.developerway.com/posts/reconciliation-in-react"/>
        <updated>2023-05-13T07:12:20.250Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developerway.com/posts/reconciliation-in-react">React reconciliation: how it works and why should we care</a></p><p><strong>概要：</strong></p><p>本文详细介绍了 React 的协调算法，以及它如何影响我们的日常代码。文章探讨了条件渲染、"key" 属性和为什么不应该在其他组件内声明组件等问题，并提供了解决方法。作者通过分析 React 的虚拟 DOM 和状态更新过程，解释了为什么在条件渲染中声明组件会重新挂载，以及为什么需要使用 "key" 属性来避免组件重复挂载或保证元素的唯一性。最后，作者提供了多个示例来说明这些概念。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Deopt Explorer - TypeScript]]></title>
        <id>https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/</id>
        <link href="https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/"/>
        <updated>2023-05-13T01:41:30.924Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/">Introducing Deopt Explorer - TypeScript</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用内联缓存（inline caching）优化 JavaScript 代码的性能，并讲解了在 TypeScript 编译器中如何使用 Deopt Explorer 工具来分析性能问题和减少多态现象。文章详细介绍了内联缓存的概念、不同类型的缓存以及多态现象的产生原因。通过实例分析，作者展示了如何使用 Deopt Explorer 工具来分析 V8 引擎生成的 ICs 和对象类型，并通过优化 Symbol 类型的属性访问，将编译时间平均缩短了 8-10%。最后，作者介绍了 Deopt Explorer 工具的使用方法和开源地址。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用性能 API 测量页面加载时间]]></title>
        <id>https://www.silvestar.codes/articles/how-to-measure-page-loading-time-with-performance-api/</id>
        <link href="https://www.silvestar.codes/articles/how-to-measure-page-loading-time-with-performance-api/"/>
        <updated>2023-05-11T01:09:04.045Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.silvestar.codes/articles/how-to-measure-page-loading-time-with-performance-api/">How to measure page loading time with Performance API</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 Performance API 来测量网页的加载时间。作者最初从 Tim Kadlec 的博客中发现了一个显示页面加载时间的特性，但是在调整代码时遇到了一些问题。最终，作者通过使用 Performance API 的 performance.mark () 方法来解决了这个问题，并分享了获取页面加载时间的最终代码。此外，作者还提供了一个名为 page-loaded-in 的 NPM 包来帮助读者快速实现该特性。文章强调了在开发基于 Web 的项目时优化性能的重要性，并提供了使用 Performance API 来衡量页面性能的方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的混音之路]]></title>
        <id>https://redd.one/blog/my-struggle-with-remix</id>
        <link href="https://redd.one/blog/my-struggle-with-remix"/>
        <updated>2023-05-11T01:08:33.697Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://redd.one/blog/my-struggle-with-remix">My Struggle With Remix</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了作者使用 Remix 框架的经验和遇到的问题。作者认为 Remix 是一个很好的框架，但是也存在一些缺点。作者提出了四个主要问题：开发体验、路由过于神秘、仍然不够成熟以及控制不是默认的。作者指出，Remix 在某些方面缺乏对开发者的控制权，例如构建过程和静态资源处理。此外，Remix 的路由语法可能会使人感到困惑，并且更新时可能会出现问题。尽管存在这些问题，作者仍然认为 Remix 是一个优秀的框架，特别适用于数据密集型应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[滑动进入动画]]></title>
        <id>https://antfu.me/posts/sliding-enter-animation</id>
        <link href="https://antfu.me/posts/sliding-enter-animation"/>
        <updated>2023-05-11T01:07:22.715Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/sliding-enter-animation">Sliding Enter Animation</a></p><p><strong>概要：</strong></p><p>本文介绍了一种通过 CSS 动画实现页面元素滑动进入的效果，并提供了一个示例代码。作者在文章中还尝试了使用 CSS 计数器来简化应用到 Markdown 页面内容的过程，但由于计数器函数返回字符串而无法直接转换为数字，因此最终采用了 nth-child () 选择器来手动实现该效果。最后，作者将该效果应用到了自己的博客页面中，并分享了源代码。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - dai-shi/will-this-react-global-state-work-in-concurrent-rendering: 在 React 并发渲染中测试撕裂和分支。]]></title>
        <id>https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-rendering</id>
        <link href="https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-rendering"/>
        <updated>2023-05-10T01:49:33.357Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-rendering">GitHub - dai-shi/will-this-react-global-state-work-in-concurrent-rendering: Test tearing and branching in React concurrent rendering</a></p><p><strong>概要：</strong></p><p>本文介绍了 React 18 中的一个新特性 —— 并发渲染，以及在全局状态下可能出现的 “tearing” 问题。作者通过测试不同的全局状态库，如 react-redux、zustand、recoil 等，来验证它们在并发渲染下的表现。测试包括更新和挂载时是否存在 tearing，以及暂时是否存在 tearing 等情况。文章指出，这些测试结果仅供参考，因为 tearing 和状态分支可能取决于应用程序的要求，并且测试方法有限。此外，作者还提到了另一个仓库，用于列出全局状态库的比较，欢迎贡献。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不阻塞事件循环的实用指南]]></title>
        <id>https://www.bbss.dev/posts/eventloop/</id>
        <link href="https://www.bbss.dev/posts/eventloop/"/>
        <updated>2023-05-09T08:34:39.705Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.bbss.dev/posts/eventloop/">Practical Guide To Not Blocking The Event Loop</a></p><p><strong>概要：</strong></p><p>本文介绍了 JavaScript 在单线程环境下的事件循环机制，以及如何避免同步任务阻塞事件循环。作者提出了三种解决方案：增加节点数量、将同步任务改为异步任务、将同步任务转移到另一个线程。其中，将同步任务转移到另一个线程需要使用 Worker，并且有数据传输限制。作者还介绍了将同步任务改为异步任务的具体实现方法，即通过将代码块分散到事件循环中来添加同步执行之间的间隙，从而让事件循环得以运行。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2.4 | 天文学]]></title>
        <id>https://astro.build/blog/astro-240/</id>
        <link href="https://astro.build/blog/astro-240/"/>
        <updated>2023-05-09T08:33:23.736Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://astro.build/blog/astro-240/">Astro 2.4 | Astro</a></p><p><strong>概要：</strong></p><p>Astro 2.4 发布了，新增了几个功能：更强大的 CSS 作用域、升级了 <Code /> 组件、在站点地图中支持服务器端渲染、中间件（实验性）和 CSS 内联（实验性）。其中，scopedStyleStrategy 允许使用类选择器来配置更高的特异性，<Code /> 组件升级到了 Shiki 0.14 版本，@astrojs/sitemaps 包更新以支持服务器端渲染，中间件支持拦截请求和响应并动态注入行为，CSS 内联可以通过配置将样式表嵌入到 < style > 标签中。此外，还包括一些 bug 修复和集成功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[粘性菜单的问题及替代方案]]></title>
        <id>https://adamsilver.io/blog/the-problem-with-sticky-menus-and-what-to-do-instead/</id>
        <link href="https://adamsilver.io/blog/the-problem-with-sticky-menus-and-what-to-do-instead/"/>
        <updated>2023-05-09T02:33:14.398Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://adamsilver.io/blog/the-problem-with-sticky-menus-and-what-to-do-instead/">The problem with sticky menus and what to do instead</a></p><p><strong>概要：</strong></p><p>本文讨论了粘性菜单（即固定在视口边缘的菜单）对用户体验的负面影响。这些菜单会占用页面空间、遮挡内容、缩放时出现问题、难以访问、容易使内部页面锚点失效、距离键盘用户较远并遮挡链接和其他可聚焦元素。作者建议解决根本原因，让页面变短，让用户自由滚动；将相关链接放入上下文中；使用返回顶部链接等方式来替代粘性菜单。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 React 中使用 useContext：全面指南 - Michael Gold - Medium]]></title>
        <id>https://medium.com/@msgold/using-usecontext-in-react-a-comprehensive-guide-8a9f5271f7a8</id>
        <link href="https://medium.com/@msgold/using-usecontext-in-react-a-comprehensive-guide-8a9f5271f7a8"/>
        <updated>2023-05-08T04:44:16.047Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://medium.com/@msgold/using-usecontext-in-react-a-comprehensive-guide-8a9f5271f7a8">Using useContext in React: a comprehensive guide - Michael Gold - Medium</a></p><p><strong>概要：</strong></p><p>本文介绍了 React 中的 useContext 钩子，它可以方便地在多个组件之间共享数据而无需通过 props 传递。文章详细介绍了什么是 React 中的 Context 机制，以及为什么使用 useContext 很重要，包括避免 prop drilling 和共享数据等优点。文章还提供了一个实际例子来演示如何使用 useContext 创建主题切换器。此外，文章还比较了 useContext 和 Redux 之间的区别和用法，并提供了一些最佳实践和限制。最后，文章总结了 useContext 是 React 开发人员工具箱中有价值的工具之一。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些开发者控制台技巧]]></title>
        <id>https://gomakethings.com/a-few-developer-console-tricks/</id>
        <link href="https://gomakethings.com/a-few-developer-console-tricks/"/>
        <updated>2023-05-08T04:42:31.114Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://gomakethings.com/a-few-developer-console-tricks/">A few developer console tricks</a></p><p><strong>概要：</strong></p><p>本文介绍了一些在浏览器控制台中使用的技巧，包括打开控制台、使用 $() 和 $$() 方法获取元素、使用 $0 变量获取当前选定的元素等。作者认为控制台是前端工作中最好的功能之一。建议使用 Chromium 或 Firefox 进行 JavaScript 开发，因为 Safari 的开发者工具功能较少。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 服务器组件是什么？]]></title>
        <id>https://www.viget.com/articles/what-even-are-react-server-components/</id>
        <link href="https://www.viget.com/articles/what-even-are-react-server-components/"/>
        <updated>2023-05-08T04:42:10.356Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.viget.com/articles/what-even-are-react-server-components/">What Even Are React Server Components</a></p><p><strong>概要：</strong></p><p>React Server Components 是在服务器上渲染的 React 组件，旨在减少网络瀑布效应。与传统的服务器端渲染 (SSR)、并行获取和架构更改相比，Server Components 具有更好的用户体验、更快的构建速度和更易于维护的特点。Server Components 可以通过在 JS 和 HTML 中填充一些初始数据来减少客户端请求次数，而且这种方式可以嵌套使用，只需要向顶层组件和其子组件发出一次请求即可。Server Components 还可以减小 JS 包的大小，只发送必要的数据给客户端，从而提高性能。Server Components 看起来就像普通的 React 组件，但是客户端无法与之交互，如果需要交互，则需要将一个 React Client Component 插入到 Server Component 中。目前，Server Components 还处于测试阶段，不适合在生产环境中使用，但可以在实验应用程序中进行尝试。NextJS v13 的 App Router 是目前唯一支持 Server Components 的框架，但 React 团队正在帮</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 LLM 的八件事 | Swizec Teller]]></title>
        <id>https://swizec.com/blog/eight-things-to-know-about-llms/</id>
        <link href="https://swizec.com/blog/eight-things-to-know-about-llms/"/>
        <updated>2023-05-06T02:20:42.799Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://swizec.com/blog/eight-things-to-know-about-llms/">Eight things to know about LLMs | Swizec Teller</a></p><p><strong>概要：</strong></p><p>这篇文章总结了最近人工智能（AI）的进展和引起人们兴奋的原因。其中提到了以下几点：1. 大型语言模型（LLMs）随着规模的增大而变得更好；2.LLMs 具有出人意料的新颖能力，包括 few-shot 和上下文学习；3.LLMs 表现出 “心理模型”；4. 无法可靠地控制 LLMs；5. 目前还没有人知道 LLMs 是如何工作的；6.LLMs 可以胜过人类；7.LLMs 存在偏见问题；8.LLMs 表现很好。作者还提供了一些资源来帮助读者更深入地了解这些问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mojo 可能是数十年来最大的编程语言进步。]]></title>
        <id>https://www.fast.ai/posts/2023-05-03-mojo-launch.html</id>
        <link href="https://www.fast.ai/posts/2023-05-03-mojo-launch.html"/>
        <updated>2023-05-05T12:59:37.147Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.fast.ai/posts/2023-05-03-mojo-launch.html">Mojo may be the biggest programming language advance in decades</a></p><p><strong>概要：</strong></p><p>文章介绍了一种名为 Mojo 的新编程语言，它是 Python 的超集，并且可以通过使用 “fn” 和 “struct” 等新语法来实现高性能代码。该语言建立在强大的基础上，包括 LLVM 和 MLIR 等核心技术，使其快速发展和易于开发。作者认为 Mojo 将成为 AI 模型开发的替代 Python 的重要工具，并且预计它将比预期更快地发展和扩展。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 13.4 在 Vercel 上 - Vercel]]></title>
        <id>https://vercel.com/changelog/next-js-13-4</id>
        <link href="https://vercel.com/changelog/next-js-13-4"/>
        <updated>2023-05-05T01:26:06.105Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/changelog/next-js-13-4">Next.js 13.4 on Vercel – Vercel</a></p><p><strong>概要：</strong></p><p>Next.js 13.4 中的 App Router 现已稳定，Vercel 提供预配置的全局框架定义基础设施，支持构建数据驱动、个性化体验，并实现优化的全球性能自动部署。嵌套路由和布局可轻松共享 UI，同时保留状态并避免昂贵的重新渲染。Next.js App router 原生支持流式响应，可在 Node 和 Edge 运行时进行流式传输，无需代码更改，在 Vercel 上部署为 Edge Functions，提供大幅度的 SEO 和性能改进。服务器组件允许您在组件级别定义数据获取，并轻松表达缓存和重验证策略。Next.js 还提供了内置的 SEO 支持和数据获取支持，以及 Turbopack（Beta）和 Server Actions（Alpha）。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Tauri 1.3.0 | Tauri 应用程序]]></title>
        <id>https://tauri.app/blog/2023/05/03/tauri-1-3/</id>
        <link href="https://tauri.app/blog/2023/05/03/tauri-1-3/"/>
        <updated>2023-05-05T01:25:41.841Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tauri.app/blog/2023/05/03/tauri-1-3/">Announcing Tauri 1.3.0 | Tauri Apps</a></p><p><strong>概要：</strong></p><p>Tauri 团队发布了 1.3 版本，包括安全改进、新功能和重要的错误修复。该版本新增了 NSIS，可以使用 NSIS 创建 Windows 应用程序安装程序，还有其他一些改进和修复。其中最重要的是对外部 API 访问、浏览器参数和 Bundler 进行了加固，以提高应用程序的安全性。同时，开发者需要注意更新 NPM 和 Cargo 依赖项，以确保应用程序的稳定性和安全性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Vercel Spaces 实现规模化的高质量软件 - Vercel]]></title>
        <id>https://vercel.com/blog/vercel-spaces</id>
        <link href="https://vercel.com/blog/vercel-spaces"/>
        <updated>2023-05-05T00:18:14.981Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/vercel-spaces">Quality software at scale with Vercel Spaces – Vercel</a></p><p><strong>概要：</strong></p><p>Vercel推出了Vercel Spaces，它提供了强大的工具和惯例，可以与monorepo设置集成，使开发人员能够在保持质量的同时有效地扩展。Spaces仪表板提供了对开发工作流程、代码健康状况和构建日志的洞察力，并包括通过Conformance、Code Owners和Vercel Runs提升效率和消除障碍的新功能。Conformance可以在开发生命周期的早期自动检测前端产品的关键问题，Code Owners可以帮助确定谁对代码负责，并确保代码变更由正确的人审查，而Vercel Runs通过交互式用户界面提供了一种更简单的调试任务的方式。Vercel Spaces可供Vercel企业客户提前使用。</p>]]></content>
    </entry>
</feed>