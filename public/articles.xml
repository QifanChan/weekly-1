<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-05-15T01:54:11.443Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[掌握 TypeScript 中的 infer - JavaScript in Plain English]]></title>
        <id>https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86</id>
        <link href="https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86"/>
        <updated>2023-05-14T16:28:12.103Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://javascript.plainenglish.io/mastering-infer-in-typescript-6cf3f93cca86">Mastering infer in TypeScript - JavaScript in Plain English</a></p><p><strong>概要：</strong></p><p>本文介绍了 TypeScript 中 infer 关键字的用法，它可以从现有的代码中提取和推断类型。使用 infer 关键字可以增加代码的类型安全性、效率和组织性。infer 关键字可以在泛型类型、函数参数和返回值、映射类型中使用，但只能在条件类型中使用。同时，文章还提供了一些实际的例子来展示 infer 关键字的使用方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Dart 3 - Dart - Medium]]></title>
        <id>https://medium.com/dartlang/announcing-dart-3-53f065a10635</id>
        <link href="https://medium.com/dartlang/announcing-dart-3-53f065a10635"/>
        <updated>2023-05-14T16:11:21.730Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://medium.com/dartlang/announcing-dart-3-53f065a10635">Announcing Dart 3 - Dart - Medium</a></p><p><strong>概要：</strong></p><p>Google 在 I/O 2023 上宣布了 Dart 3 的发布，这是迄今为止最大的 Dart 版本，包括三个主要进展：100％的声音空安全、记录、模式和类修饰符的重大新语言特性以及通过 Wasm 编译实现对 Web 的本地代码支持。其中，100％空安全意味着 Dart 具有可靠的类型系统，可以避免某些编码错误，如空指针异常，并允许编译器和运行时优化代码。此外，Dart 3 还引入了记录、模式和类修饰符等新功能，使 Dart 更加表达和精简，同时提供了一种详细控制大型 API 表面的方法。最后，Dart 3 还提供了未来的预览，即通过 Wasm 编译实现对 Web 的本地代码支持。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Fresh、OpenAI 和 Supabase 构建您自己的 ChatGPT 风格文档搜索。]]></title>
        <id>https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh</id>
        <link href="https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh"/>
        <updated>2023-05-13T07:30:37.930Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/build-chatgpt-doc-search-with-supabase-fresh">Build your own ChatGPT-style doc search with Fresh, OpenAI, and Supabase</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 OpenAI Text Completion API 创建自定义的 ChatGPT 风格文档搜索，以及如何在 Supabase 的免费托管 PostgresDB 中存储嵌入和执行向量相似性搜索。文章详细介绍了构建自定义 ChatGPT 的四个步骤，包括预处理知识库、存储嵌入、运行时执行向量相似性搜索和将内容注入到 OpenAI GPT-3 文本完成提示中并将响应流式传输给客户端。此外，文章还提供了一些有关使用 OpenAI 和 ChatGPT 构建的其他资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Deno 在 Rust 中运行 JavaScript]]></title>
        <id>https://austinpoor.com/blog/js-in-rs</id>
        <link href="https://austinpoor.com/blog/js-in-rs"/>
        <updated>2023-05-13T07:28:48.597Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://austinpoor.com/blog/js-in-rs">Running JavaScript in Rust with Deno</a></p><p><strong>概要：</strong></p><p>本文介绍了作者创建的一个名为 “js-in-rs” 的基于 Rust 的 CLI 工具，用于使用 JavaScript 表达式过滤文件。与 grep 工具使用正则表达式不同，js-in-rs 使用 JavaScript 表达式进行过滤。文章详细介绍了 js-in-rs 的工作原理和代码实现，并探讨了在 Rust 应用程序中运行 JavaScript 代码的潜在应用，例如 Web 服务器、数据管道和数据库用户定义函数等。此外，作者还提到 Deno 运行时具有有趣的权限管理方法，允许用户开启或关闭运行时功能，以防止恶意代码访问资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery 3.7.0 发布：保持顺序]]></title>
        <id>https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/</id>
        <link href="https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/"/>
        <updated>2023-05-13T07:28:14.090Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.jquery.com/2023/05/11/jquery-3-7-0-released-staying-in-order/">jQuery 3.7.0 Released: Staying in Order</a></p><p><strong>概要：</strong></p><p>jQuery 3.7.0 发布了，包含了 bug 修复、新方法和性能提升等内容。此次更新中，jQuery 删除了其长期使用的选择器引擎 Sizzle，并将其代码直接放入了 jQuery 核心中，以便为未来版本的选择做准备。同时，jQuery 增加了一个可链接的.uniqueSort () 方法，解决了某些情况下.prevAll () 方法返回元素顺序相反的问题。jQuery 还添加了对更多 CSS 属性的支持，避免自动添加 “px” 单位。此外，该版本还优化了.manipulation () 方法的性能，修复了在 IE 中焦点事件异步触发的问题。该版本与之前的版本兼容，可以从 jQuery CDN 或 npm 获取。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Vue 3.3 | Vue 点击]]></title>
        <id>https://blog.vuejs.org/posts/vue-3-3</id>
        <link href="https://blog.vuejs.org/posts/vue-3-3"/>
        <updated>2023-05-13T07:13:47.996Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.vuejs.org/posts/vue-3-3">Announcing Vue 3.3 | The Vue Point</a></p><p><strong>概要：</strong></p><p>Vue 3.3 "Rurouni Kenshin" has been released, with a focus on improving developer experience when using Vue with TypeScript. The update includes improvements to SFC <script setup> usage with TypeScript, imported and complex types support in macros, generic components, more ergonomic defineEmits, typed slots with defineSlots, and experimental features such as reactive props destructure and defineModel. Other notable features include defineOptions, better getter support with toRef and toValue, and JSX import source support. Maintenance infrastructure improvements have also been made, allowing for faster builds, tests, and types generation. The Vue team plans to make smaller and more frequent feature releases starting in 2023.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 协调：它是如何工作的，为什么我们应该关心]]></title>
        <id>https://www.developerway.com/posts/reconciliation-in-react</id>
        <link href="https://www.developerway.com/posts/reconciliation-in-react"/>
        <updated>2023-05-13T07:12:20.250Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developerway.com/posts/reconciliation-in-react">React reconciliation: how it works and why should we care</a></p><p><strong>概要：</strong></p><p>本文详细介绍了 React 的协调算法，以及它如何影响我们的日常代码。文章探讨了条件渲染、"key" 属性和为什么不应该在其他组件内声明组件等问题，并提供了解决方法。作者通过分析 React 的虚拟 DOM 和状态更新过程，解释了为什么在条件渲染中声明组件会重新挂载，以及为什么需要使用 "key" 属性来避免组件重复挂载或保证元素的唯一性。最后，作者提供了多个示例来说明这些概念。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Deopt Explorer - TypeScript]]></title>
        <id>https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/</id>
        <link href="https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/"/>
        <updated>2023-05-13T01:41:30.924Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://devblogs.microsoft.com/typescript/introducing-deopt-explorer/">Introducing Deopt Explorer - TypeScript</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用内联缓存（inline caching）优化 JavaScript 代码的性能，并讲解了在 TypeScript 编译器中如何使用 Deopt Explorer 工具来分析性能问题和减少多态现象。文章详细介绍了内联缓存的概念、不同类型的缓存以及多态现象的产生原因。通过实例分析，作者展示了如何使用 Deopt Explorer 工具来分析 V8 引擎生成的 ICs 和对象类型，并通过优化 Symbol 类型的属性访问，将编译时间平均缩短了 8-10%。最后，作者介绍了 Deopt Explorer 工具的使用方法和开源地址。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用性能 API 测量页面加载时间]]></title>
        <id>https://www.silvestar.codes/articles/how-to-measure-page-loading-time-with-performance-api/</id>
        <link href="https://www.silvestar.codes/articles/how-to-measure-page-loading-time-with-performance-api/"/>
        <updated>2023-05-11T01:09:04.045Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.silvestar.codes/articles/how-to-measure-page-loading-time-with-performance-api/">How to measure page loading time with Performance API</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 Performance API 来测量网页的加载时间。作者最初从 Tim Kadlec 的博客中发现了一个显示页面加载时间的特性，但是在调整代码时遇到了一些问题。最终，作者通过使用 Performance API 的 performance.mark () 方法来解决了这个问题，并分享了获取页面加载时间的最终代码。此外，作者还提供了一个名为 page-loaded-in 的 NPM 包来帮助读者快速实现该特性。文章强调了在开发基于 Web 的项目时优化性能的重要性，并提供了使用 Performance API 来衡量页面性能的方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的混音之路]]></title>
        <id>https://redd.one/blog/my-struggle-with-remix</id>
        <link href="https://redd.one/blog/my-struggle-with-remix"/>
        <updated>2023-05-11T01:08:33.697Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://redd.one/blog/my-struggle-with-remix">My Struggle With Remix</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了作者使用 Remix 框架的经验和遇到的问题。作者认为 Remix 是一个很好的框架，但是也存在一些缺点。作者提出了四个主要问题：开发体验、路由过于神秘、仍然不够成熟以及控制不是默认的。作者指出，Remix 在某些方面缺乏对开发者的控制权，例如构建过程和静态资源处理。此外，Remix 的路由语法可能会使人感到困惑，并且更新时可能会出现问题。尽管存在这些问题，作者仍然认为 Remix 是一个优秀的框架，特别适用于数据密集型应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[滑动进入动画]]></title>
        <id>https://antfu.me/posts/sliding-enter-animation</id>
        <link href="https://antfu.me/posts/sliding-enter-animation"/>
        <updated>2023-05-11T01:07:22.715Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/sliding-enter-animation">Sliding Enter Animation</a></p><p><strong>概要：</strong></p><p>本文介绍了一种通过 CSS 动画实现页面元素滑动进入的效果，并提供了一个示例代码。作者在文章中还尝试了使用 CSS 计数器来简化应用到 Markdown 页面内容的过程，但由于计数器函数返回字符串而无法直接转换为数字，因此最终采用了 nth-child () 选择器来手动实现该效果。最后，作者将该效果应用到了自己的博客页面中，并分享了源代码。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - dai-shi/will-this-react-global-state-work-in-concurrent-rendering: 在 React 并发渲染中测试撕裂和分支。]]></title>
        <id>https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-rendering</id>
        <link href="https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-rendering"/>
        <updated>2023-05-10T01:49:33.357Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-rendering">GitHub - dai-shi/will-this-react-global-state-work-in-concurrent-rendering: Test tearing and branching in React concurrent rendering</a></p><p><strong>概要：</strong></p><p>本文介绍了 React 18 中的一个新特性 —— 并发渲染，以及在全局状态下可能出现的 “tearing” 问题。作者通过测试不同的全局状态库，如 react-redux、zustand、recoil 等，来验证它们在并发渲染下的表现。测试包括更新和挂载时是否存在 tearing，以及暂时是否存在 tearing 等情况。文章指出，这些测试结果仅供参考，因为 tearing 和状态分支可能取决于应用程序的要求，并且测试方法有限。此外，作者还提到了另一个仓库，用于列出全局状态库的比较，欢迎贡献。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不阻塞事件循环的实用指南]]></title>
        <id>https://www.bbss.dev/posts/eventloop/</id>
        <link href="https://www.bbss.dev/posts/eventloop/"/>
        <updated>2023-05-09T08:34:39.705Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.bbss.dev/posts/eventloop/">Practical Guide To Not Blocking The Event Loop</a></p><p><strong>概要：</strong></p><p>本文介绍了 JavaScript 在单线程环境下的事件循环机制，以及如何避免同步任务阻塞事件循环。作者提出了三种解决方案：增加节点数量、将同步任务改为异步任务、将同步任务转移到另一个线程。其中，将同步任务转移到另一个线程需要使用 Worker，并且有数据传输限制。作者还介绍了将同步任务改为异步任务的具体实现方法，即通过将代码块分散到事件循环中来添加同步执行之间的间隙，从而让事件循环得以运行。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2.4 | 天文学]]></title>
        <id>https://astro.build/blog/astro-240/</id>
        <link href="https://astro.build/blog/astro-240/"/>
        <updated>2023-05-09T08:33:23.736Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://astro.build/blog/astro-240/">Astro 2.4 | Astro</a></p><p><strong>概要：</strong></p><p>Astro 2.4 发布了，新增了几个功能：更强大的 CSS 作用域、升级了 <Code /> 组件、在站点地图中支持服务器端渲染、中间件（实验性）和 CSS 内联（实验性）。其中，scopedStyleStrategy 允许使用类选择器来配置更高的特异性，<Code /> 组件升级到了 Shiki 0.14 版本，@astrojs/sitemaps 包更新以支持服务器端渲染，中间件支持拦截请求和响应并动态注入行为，CSS 内联可以通过配置将样式表嵌入到 < style > 标签中。此外，还包括一些 bug 修复和集成功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[粘性菜单的问题及替代方案]]></title>
        <id>https://adamsilver.io/blog/the-problem-with-sticky-menus-and-what-to-do-instead/</id>
        <link href="https://adamsilver.io/blog/the-problem-with-sticky-menus-and-what-to-do-instead/"/>
        <updated>2023-05-09T02:33:14.398Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://adamsilver.io/blog/the-problem-with-sticky-menus-and-what-to-do-instead/">The problem with sticky menus and what to do instead</a></p><p><strong>概要：</strong></p><p>本文讨论了粘性菜单（即固定在视口边缘的菜单）对用户体验的负面影响。这些菜单会占用页面空间、遮挡内容、缩放时出现问题、难以访问、容易使内部页面锚点失效、距离键盘用户较远并遮挡链接和其他可聚焦元素。作者建议解决根本原因，让页面变短，让用户自由滚动；将相关链接放入上下文中；使用返回顶部链接等方式来替代粘性菜单。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 React 中使用 useContext：全面指南 - Michael Gold - Medium]]></title>
        <id>https://medium.com/@msgold/using-usecontext-in-react-a-comprehensive-guide-8a9f5271f7a8</id>
        <link href="https://medium.com/@msgold/using-usecontext-in-react-a-comprehensive-guide-8a9f5271f7a8"/>
        <updated>2023-05-08T04:44:16.047Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://medium.com/@msgold/using-usecontext-in-react-a-comprehensive-guide-8a9f5271f7a8">Using useContext in React: a comprehensive guide - Michael Gold - Medium</a></p><p><strong>概要：</strong></p><p>本文介绍了 React 中的 useContext 钩子，它可以方便地在多个组件之间共享数据而无需通过 props 传递。文章详细介绍了什么是 React 中的 Context 机制，以及为什么使用 useContext 很重要，包括避免 prop drilling 和共享数据等优点。文章还提供了一个实际例子来演示如何使用 useContext 创建主题切换器。此外，文章还比较了 useContext 和 Redux 之间的区别和用法，并提供了一些最佳实践和限制。最后，文章总结了 useContext 是 React 开发人员工具箱中有价值的工具之一。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些开发者控制台技巧]]></title>
        <id>https://gomakethings.com/a-few-developer-console-tricks/</id>
        <link href="https://gomakethings.com/a-few-developer-console-tricks/"/>
        <updated>2023-05-08T04:42:31.114Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://gomakethings.com/a-few-developer-console-tricks/">A few developer console tricks</a></p><p><strong>概要：</strong></p><p>本文介绍了一些在浏览器控制台中使用的技巧，包括打开控制台、使用 $() 和 $$() 方法获取元素、使用 $0 变量获取当前选定的元素等。作者认为控制台是前端工作中最好的功能之一。建议使用 Chromium 或 Firefox 进行 JavaScript 开发，因为 Safari 的开发者工具功能较少。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 服务器组件是什么？]]></title>
        <id>https://www.viget.com/articles/what-even-are-react-server-components/</id>
        <link href="https://www.viget.com/articles/what-even-are-react-server-components/"/>
        <updated>2023-05-08T04:42:10.356Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.viget.com/articles/what-even-are-react-server-components/">What Even Are React Server Components</a></p><p><strong>概要：</strong></p><p>React Server Components 是在服务器上渲染的 React 组件，旨在减少网络瀑布效应。与传统的服务器端渲染 (SSR)、并行获取和架构更改相比，Server Components 具有更好的用户体验、更快的构建速度和更易于维护的特点。Server Components 可以通过在 JS 和 HTML 中填充一些初始数据来减少客户端请求次数，而且这种方式可以嵌套使用，只需要向顶层组件和其子组件发出一次请求即可。Server Components 还可以减小 JS 包的大小，只发送必要的数据给客户端，从而提高性能。Server Components 看起来就像普通的 React 组件，但是客户端无法与之交互，如果需要交互，则需要将一个 React Client Component 插入到 Server Component 中。目前，Server Components 还处于测试阶段，不适合在生产环境中使用，但可以在实验应用程序中进行尝试。NextJS v13 的 App Router 是目前唯一支持 Server Components 的框架，但 React 团队正在帮</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 LLM 的八件事 | Swizec Teller]]></title>
        <id>https://swizec.com/blog/eight-things-to-know-about-llms/</id>
        <link href="https://swizec.com/blog/eight-things-to-know-about-llms/"/>
        <updated>2023-05-06T02:20:42.799Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://swizec.com/blog/eight-things-to-know-about-llms/">Eight things to know about LLMs | Swizec Teller</a></p><p><strong>概要：</strong></p><p>这篇文章总结了最近人工智能（AI）的进展和引起人们兴奋的原因。其中提到了以下几点：1. 大型语言模型（LLMs）随着规模的增大而变得更好；2.LLMs 具有出人意料的新颖能力，包括 few-shot 和上下文学习；3.LLMs 表现出 “心理模型”；4. 无法可靠地控制 LLMs；5. 目前还没有人知道 LLMs 是如何工作的；6.LLMs 可以胜过人类；7.LLMs 存在偏见问题；8.LLMs 表现很好。作者还提供了一些资源来帮助读者更深入地了解这些问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mojo 可能是数十年来最大的编程语言进步。]]></title>
        <id>https://www.fast.ai/posts/2023-05-03-mojo-launch.html</id>
        <link href="https://www.fast.ai/posts/2023-05-03-mojo-launch.html"/>
        <updated>2023-05-05T12:59:37.147Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.fast.ai/posts/2023-05-03-mojo-launch.html">Mojo may be the biggest programming language advance in decades</a></p><p><strong>概要：</strong></p><p>文章介绍了一种名为 Mojo 的新编程语言，它是 Python 的超集，并且可以通过使用 “fn” 和 “struct” 等新语法来实现高性能代码。该语言建立在强大的基础上，包括 LLVM 和 MLIR 等核心技术，使其快速发展和易于开发。作者认为 Mojo 将成为 AI 模型开发的替代 Python 的重要工具，并且预计它将比预期更快地发展和扩展。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 13.4 在 Vercel 上 - Vercel]]></title>
        <id>https://vercel.com/changelog/next-js-13-4</id>
        <link href="https://vercel.com/changelog/next-js-13-4"/>
        <updated>2023-05-05T01:26:06.105Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/changelog/next-js-13-4">Next.js 13.4 on Vercel – Vercel</a></p><p><strong>概要：</strong></p><p>Next.js 13.4 中的 App Router 现已稳定，Vercel 提供预配置的全局框架定义基础设施，支持构建数据驱动、个性化体验，并实现优化的全球性能自动部署。嵌套路由和布局可轻松共享 UI，同时保留状态并避免昂贵的重新渲染。Next.js App router 原生支持流式响应，可在 Node 和 Edge 运行时进行流式传输，无需代码更改，在 Vercel 上部署为 Edge Functions，提供大幅度的 SEO 和性能改进。服务器组件允许您在组件级别定义数据获取，并轻松表达缓存和重验证策略。Next.js 还提供了内置的 SEO 支持和数据获取支持，以及 Turbopack（Beta）和 Server Actions（Alpha）。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Tauri 1.3.0 | Tauri 应用程序]]></title>
        <id>https://tauri.app/blog/2023/05/03/tauri-1-3/</id>
        <link href="https://tauri.app/blog/2023/05/03/tauri-1-3/"/>
        <updated>2023-05-05T01:25:41.841Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tauri.app/blog/2023/05/03/tauri-1-3/">Announcing Tauri 1.3.0 | Tauri Apps</a></p><p><strong>概要：</strong></p><p>Tauri 团队发布了 1.3 版本，包括安全改进、新功能和重要的错误修复。该版本新增了 NSIS，可以使用 NSIS 创建 Windows 应用程序安装程序，还有其他一些改进和修复。其中最重要的是对外部 API 访问、浏览器参数和 Bundler 进行了加固，以提高应用程序的安全性。同时，开发者需要注意更新 NPM 和 Cargo 依赖项，以确保应用程序的稳定性和安全性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Vercel Spaces 实现规模化的高质量软件 - Vercel]]></title>
        <id>https://vercel.com/blog/vercel-spaces</id>
        <link href="https://vercel.com/blog/vercel-spaces"/>
        <updated>2023-05-05T00:18:14.981Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/vercel-spaces">Quality software at scale with Vercel Spaces – Vercel</a></p><p><strong>概要：</strong></p><p>Vercel推出了Vercel Spaces，它提供了强大的工具和惯例，可以与monorepo设置集成，使开发人员能够在保持质量的同时有效地扩展。Spaces仪表板提供了对开发工作流程、代码健康状况和构建日志的洞察力，并包括通过Conformance、Code Owners和Vercel Runs提升效率和消除障碍的新功能。Conformance可以在开发生命周期的早期自动检测前端产品的关键问题，Code Owners可以帮助确定谁对代码负责，并确保代码变更由正确的人审查，而Vercel Runs通过交互式用户界面提供了一种更简单的调试任务的方式。Vercel Spaces可供Vercel企业客户提前使用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Angular v16 已经发布了！- Angular 博客]]></title>
        <id>https://blog.angular.io/angular-v16-is-here-4d7a28ec680d</id>
        <link href="https://blog.angular.io/angular-v16-is-here-4d7a28ec680d"/>
        <updated>2023-05-05T00:03:11.942Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.angular.io/angular-v16-is-here-4d7a28ec680d">Angular v16 is here! - Angular Blog</a></p><p><strong>概要：</strong></p><p>Angular 发布了最大的版本更新，包括改进响应性、服务器端渲染和工具等方面。其中最重要的是引入了全新的响应性模型，提高了性能和开发者体验。该版本还支持服务端渲染和水合，提供了更好的工具和单独的 API，以及其他许多改进。此外，Angular 还计划在未来一年内推出更多的改进和功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TailwindCSS vs. UnoCSS

TailwindCSS 与 UnoCSS]]></title>
        <id>https://dev.to/mapleleaf/tailwindcss-vs-unocss-2a53</id>
        <link href="https://dev.to/mapleleaf/tailwindcss-vs-unocss-2a53"/>
        <updated>2023-05-05T00:02:05.363Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/mapleleaf/tailwindcss-vs-unocss-2a53">TailwindCSS vs. UnoCSS</a></p><p><strong>概要：</strong></p><p>本文对比了 TailwindCSS 和 UnoCSS 两个工具，总结了它们的特点、语言、文档、自定义样式和编辑器支持等方面。TailwindCSS 拥有完整的 CSS 特性类名，可以通过任意值、变体和属性来进行全面的样式设计，而 UnoCSS 则支持所有 TailwindCSS 的功能，并提供了一些额外的功能，如变体组、CSS 网格流体列和更多动画效果。在语言方面，TailwindCSS 有一个相对规范的类名命名方式，UnoCSS 则更加灵活。在文档和自定义样式方面，两者都有不错的表现，但 UnoCSS 的交互式文档和颜色提示更加出色。在编辑器支持方面，TailwindCSS 支持较好，但存在一些缺陷，而 UnoCSS 的高亮显示和颜色提示则更为出色。作者认为，如果你看重灵活性和额外的功能，你可能会喜欢 UnoCSS，但如果你看重约束和更清晰的编写语言，则应该选择</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 13.4]]></title>
        <id>https://nextjs.org/blog/next-13-4</id>
        <link href="https://nextjs.org/blog/next-13-4"/>
        <updated>2023-05-04T23:58:36.281Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nextjs.org/blog/next-13-4">Next.js 13.4</a></p><p><strong>概要：</strong></p><p>Next.js 13.4 是一个重要的版本，标志着 App Router 的稳定性。这个版本增加了许多新特性，包括 React Server Components、嵌套路由和布局、简化数据获取、流式渲染和 Suspense、内置 SEO 支持等。其中最重要的是 App Router，它是 Next.js 的核心组件，可以让开发者更方便地定义页面布局和数据获取方式。此外，Turbopack 也是一个值得关注的新功能，它可以加速本地开发和生产构建过程。最后，Server Actions 是一个实验性的功能，可以在服务器端直接修改数据，不需要客户端 JavaScript。总之，Next.js 13.4 为开发者提供了更强大的工具，帮助他们更轻松地构建动态、个性化和全球化的 Web 应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何测试您的类型]]></title>
        <id>https://www.totaltypescript.com/how-to-test-your-types</id>
        <link href="https://www.totaltypescript.com/how-to-test-your-types"/>
        <updated>2023-05-04T12:52:44.759Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.totaltypescript.com/how-to-test-your-types">How to test your types</a></p><p><strong>概要：</strong></p><p>本文介绍了三种测试 TypeScript 类型的方法。首先是使用 vitest，这是一个基于 Vite 的强大测试运行器，可以用来测试运行时代码和类型。其次是自己编写测试代码，可以使用 Expect 和 Equal 等类型帮助工具来测试特定类型，并在测试套件中运行 tsc 检查类型测试是否失败。最后，还介绍了一个名为 tsd 的库，它与 vitest 很相似，但包含了所有必要的内容，使得测试更加方便。对于应用程序开发而言，测试类型并不是必须的，但对于任何将被大量人使用的库而言，测试类型是至关重要的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10 种使用 ChatGPT 学习更好的方法 - 斯科特・H・扬]]></title>
        <id>https://www.scotthyoung.com/blog/2023/05/02/chatgpt-learning-tips/</id>
        <link href="https://www.scotthyoung.com/blog/2023/05/02/chatgpt-learning-tips/"/>
        <updated>2023-05-04T09:01:50.070Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.scotthyoung.com/blog/2023/05/02/chatgpt-learning-tips/">10 Ways You Can Use ChatGPT to Learn Better - Scott H Young</a></p><p><strong>概要：</strong></p><p>这篇文章总结了读者们如何使用大型语言模型（LLMs）来学习和研究的建议，并探讨了使用这些工具的优缺点。作者提醒读者要注意，虽然 ChatGPT 可以进行人类般的对话，但它并不是真正的人类，有时会提供错误的答案。然而，ChatGPT 在许多任务上都很有用，例如作为个人导师、语言教练、生成摘要、与长文本对话、简化专业术语等。作者还提到了一些不应该使用 AI 工具的情况，例如期望它们正确地获取事实、引用和数学等方面。最后，作者邀请读者分享他们使用 ChatGPT 或其他 AI 工具进行学习的经验和建议。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Canaries：在 Meta 之外启用增量功能发布的 React]]></title>
        <id>https://react.dev/blog/2023/05/03/react-canaries</id>
        <link href="https://react.dev/blog/2023/05/03/react-canaries"/>
        <updated>2023-05-04T06:53:29.142Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://react.dev/blog/2023/05/03/react-canaries">React Canaries: Enabling Incremental Feature Rollout Outside Meta – React</a></p><p><strong>概要：</strong></p><p>React 团队推出了一个新的官方支持的 Canary 版本，让开发者可以在稳定版本发布之前就采用新功能。这个 Canary 版本只包含 React 团队相信已经准备好被采用的特性，而不像实验性版本那样可能会有重大变化。Canary 版本可以让框架在全局 React 发布计划之外单独采用 React 特性，也可以让框架在自己的次要版本中发布 React 相关的重大变更，而不会破坏 semver。React 将按照 semver 规范每个稳定版本进行更新，同时也会在博客上发布 Canary 版本中的重大变更和新特性。Canary 版本需要被固定版本号，以避免包含重大变更。除此之外，React 的稳定版本不会有任何改变。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个文件中多个样式表・Issue #5629・w3c/csswg-drafts]]></title>
        <id>https://github.com/w3c/csswg-drafts/issues/5629</id>
        <link href="https://github.com/w3c/csswg-drafts/issues/5629"/>
        <updated>2023-05-04T04:50:11.466Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/w3c/csswg-drafts/issues/5629">Multiple stylesheets per file · Issue #5629 · w3c/csswg-drafts</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了在 JS 中导入 CSSStyleSheets 的问题。目前的解决方法是将 CSS 编译为 JS 模块，但这会降低浏览器直接加载和解析 CSS 的性能。Web Bundles 可能会通用地解决这个问题，但其未来在多个浏览器上的应用尚不确定。作者提出了一个新的解决方案：引入一个 @sheet 规则，它包含整个样式表作为其内容，以允许 CSS 的打包。该提议对于管理 JS 中的 CSSStyleSheets 的代码最为相关，并且也可以作为用户自定义 CSS 加载程序的桥梁，通过标准化打包，可以使用客户端实用程序进行作用域限定。</p>]]></content>
    </entry>
</feed>