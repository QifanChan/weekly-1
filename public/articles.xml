<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-07-28T00:58:15.379Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[如何在两分钟内创建标记符编辑器（使用 GitHub Copilot）]]></title>
        <id>https://dev.to/github/how-to-build-a-markdown-editor-in-two-minutes-with-github-copilot-khb</id>
        <link href="https://dev.to/github/how-to-build-a-markdown-editor-in-two-minutes-with-github-copilot-khb"/>
        <updated>2023-07-28T00:11:35.915Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/github/how-to-build-a-markdown-editor-in-two-minutes-with-github-copilot-khb">How to build a markdown editor in two minutes (with GitHub Copilot)</a></p><p><strong>概要：</strong></p><p>这篇博客文章介绍了如何使用 GitHub Copilot 在两分钟内构建一个 markdown 编辑器。首先，需要创建一个 Next.js 的 GitHub Codespace 模板，然后安装特定的依赖项，删除 index.js 文件中的代码，并通过注释提示 GitHub Copilot。然后触发 GitHub Copilot 的建议，保存文件并尝试运行。此外，还可以使用 Copilot 聊天来改善 markdown 编辑器的用户界面。但是，由于 GitHub Copilot 和其他生成 AI 工具是非确定性的，所以这些工具有时会生成不同的输出。作者还强调，虽然这个教程对今天（2023 年 6 月）仍然适用，但未来可能会过时。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Astro 2.9：视图转换（实验性） | Astro]]></title>
        <id>https://astro.build/blog/astro-290/</id>
        <link href="https://astro.build/blog/astro-290/"/>
        <updated>2023-07-27T06:17:03.682Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://astro.build/blog/astro-290/">Astro 2.9: View Transitions (experimental) | Astro</a></p><p><strong>概要：</strong></p><p>Astro 2.9 版本已经发布，新特性包括对视图过渡的实验性支持，重定向配置以及改进的脚本打包。现在，Astro 通过新的 <ViewTransitions /> 组件和 transition:animate 指令支持视图过渡，使得过渡更加顺畅，无需牺牲 MPA 的简单性。此外，重定向配置选项不再是实验性的，你可以在项目中安全地使用重定向。Astro 还改进了静态分析，使其能够确定哪些 < script > 标签需要一起打包，这使得脚本的使用在页面之间进行了优化，并将它们放在文档的头部，以尽可能早地下载。感谢社区贡献者 Ottomated 为这个新功能的开发做出的贡献。此版本还包括其他的错误修复和集成特性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 服务器组件提示]]></title>
        <id>https://echobind.com/post/react-server-components-tips</id>
        <link href="https://echobind.com/post/react-server-components-tips"/>
        <updated>2023-07-27T06:07:48.874Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://echobind.com/post/react-server-components-tips">React Server Components Tips</a></p><p><strong>概要：</strong></p><p>React 官方的数据获取解决方案为 React Server Components（RSC）。使用 RSC 需要深度集成打包器，且严格执行组件树结构和模块组合。使用 RSC 时，任何交互代码必须在特殊的客户端组件中完成。但是，RSC 也有诸多优点：可以在组件内部获取数据，避免客户端获取数据时常见的瀑布式获取，可以使用 <Suspense> 流数据以加快初始页面加载速度，可以在服务器上执行更多代码而无需将其发送到客户端，从而保持包大小较小。目前，唯一被广泛接受的 React Server Components 实现是 Next.js App Router。此外，还提供了一些使用 RSC 构建应用程序的技巧，如制作更多的组件，自由使用客户端组件，构建组件以便于组合，不要忘记共享组件等。最后，作为 Server Components 获取数据的对应部分，React 团队引入了 Server Actions 来执行变异。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - emilkowalski/vaul：React 的非样式抽屉组件。]]></title>
        <id>https://github.com/emilkowalski/vaul</id>
        <link href="https://github.com/emilkowalski/vaul"/>
        <updated>2023-07-26T04:40:19.231Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/emilkowalski/vaul">GitHub - emilkowalski/vaul: An unstyled drawer component for React.</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 Vaul 的 React 抽屉组件，可以用作平板和移动设备上的 Dialog 替代品。它使用 Radix 的 Dialog 原始组件，并受到一条推文的启发。要开始使用这个库，需要在项目中安装它，然后在应用程序中使用这个抽屉。文章还提供了几个例子以及 API 参考，包括 Root、Trigger、Content、Overlay、Title、Description、Close 和 Portal 等部分的详细说明。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Valibot，小于 1kb 的佐德替代品]]></title>
        <id>https://www.builder.io/blog/introducing-valibot</id>
        <link href="https://www.builder.io/blog/introducing-valibot"/>
        <updated>2023-07-26T04:10:17.404Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/introducing-valibot">Introducing Valibot, a < 1kb Zod Alternative</a></p><p><strong>概要：</strong></p><p>文章宣布了新的开源项目 Valibot，这是一个用于验证结构数据的模式库，与 Zod、Ajv、Joi 和 Yup 等相似。Valibot 的创新之处在于其 API 的模块化设计以及源代码的压缩优化，使得它能通过代码分割和压缩实现前所未有的包大小最小化，成为当前全栈空间创新的完美补充。Valibot 没有依赖性，可以在任何 JavaScript 或 TypeScript 项目中使用，以根据模式验证数据。作者 Fabian 介绍了 Valibot 的工作原理，它与其他解决方案的不同之处，以及它适合的使用场景。Valibot 的核心功能是创建模式，这可以与 TypeScript 中的类型定义进行比较。Valibot 几乎提供了与 TypeScript 相同的选项，例如，你可以用 partial 使对象的值变为可选，或者用 required 使它们变为必需。Valibot 是完全类型安全的，允许你推断模式的输入和输出类型。如果数据与模式不匹配，将抛出一个错误，带有有用的信息来修复问题。如果没有抛出错误，那么数据符合模式并返回类型。Valibot 的 API 设计部分基于 Zod，因为我们在各种项目中使用 Zod，并且它在新的 TypeScript 项目中几乎是标准的。尽管 API 在第一眼看起来与其他解决方案相似，但源代码的实施和结构却非常不同。Valibot 的 API 设计和源代码基于许多小而独立的函数，每个函数只有一个任务。这种模块化设计有几个优点，一方面，可以轻松地用外部代码扩展库的功能；另一</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 React Tweet - Vercel]]></title>
        <id>https://vercel.com/blog/introducing-react-tweet</id>
        <link href="https://vercel.com/blog/introducing-react-tweet"/>
        <updated>2023-07-26T03:12:03.586Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/introducing-react-tweet">Introducing React Tweet – Vercel</a></p><p><strong>概要：</strong></p><p>文章介绍了一个名为 react-tweet 的新工具，它可以将推特嵌入到任何 React 应用中，只需一行代码，且不会牺牲性能。与 Twitter 的原生嵌入相比，react-tweet 的客户端 JavaScript 少 35 倍。它支持 React 服务器组件，内置数据获取和缓存功能，并可与 Next.js、Vite、CRA 等任何 React 框架配合使用。传统上，嵌入推文需要使用 Twitter 的嵌入式 iframe，这会加载 560kb 的客户端 JavaScript，降低网站性能并导致布局移位。而使用 react-tweet，无需使用 iframes，只需一个简单的 React 组件即可。此外，它还改善了用户体验，使浏览器中的推文立即可见（无懒加载），并利用强大的 React 组件抽象进行构建。在对原生 Twitter 嵌入、iframe 嵌入和 react-tweet 进行比较后，react-tweet 所需的客户端 JavaScript 最少，只有 16kb。react-tweet 的工作原理是反向工程 Twitter 的嵌入 API，获取给定推文的数据，并以与 Twitter 的嵌入式 iframe 相同的样式呈现出来。你无需依赖 Twitter API v2 自己获取推文，从而节省了费用，也更容易将推文添加到你的网站上。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hono + htmx + Cloudflare 是一种新的堆栈 - Yusuke Wada]]></title>
        <id>https://blog.yusu.ke/hono-htmx-cloudflare/</id>
        <link href="https://blog.yusu.ke/hono-htmx-cloudflare/"/>
        <updated>2023-07-25T00:49:51.565Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.yusu.ke/hono-htmx-cloudflare/">Hono + htmx + Cloudflare is a new stack - Yusuke Wada</a></p><p><strong>概要：</strong></p><p>文章介绍了一种新的技术栈 Hono + htmx + Cloudflare。Hono 是一个 JavaScript 框架，包括 JSX 中间件，可用于编写 HTML，但仅限于服务器端渲染。htmx 是一个库，可以在不需要编写 JavaScript 的情况下启用 Ajax。这种技术栈还包括 Zod、Tailwind CSS、Cloudflare Workers 和 Cloudflare D1 等组件。Cloudflare D1 是一种在 Cloudflare 边缘运行 SQLite 的数据库服务，虽然目前处于 “alpha” 状态，不推荐用于生产使用，但已经非常快速，完全适合概念验证（PoC）项目。文章中的示例展示了如何使用这个技术栈创建一个真实的 Todo 应用示例，只需 100 行代码就能在边缘的 D1 SQLite 中插入和删除数据，执行速度快（约 100 毫秒），轻量级（gzip 压缩后的 worker 大小：22 KB）。作者表示，这种技术栈让他感到熟悉和舒适，它简单、干净，并且有很多优点，例如可以在边缘运行，可以使用 JavaScript/JSX，通过良好的代码组织可以避免出现意大利面条式代码。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 TypeScript 的 5 个难以启齿的真相]]></title>
        <id>https://oida.dev/5-truths-about-typescript/</id>
        <link href="https://oida.dev/5-truths-about-typescript/"/>
        <updated>2023-07-25T00:47:55.530Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://oida.dev/5-truths-about-typescript/">5 Inconvenient Truths about TypeScript</a></p><p><strong>概要：</strong></p><p>这篇文章是作者关于 TypeScript 的见解和经验分享。作者首先指出，TypeScript 并不能替代 JavaScript，它只是 JavaScript 的超集，继承了 JavaScript 的所有历史、怪癖和陷阱，但可以帮助避免错误，提供动态类型编程语言的支持。其次，TypeScript 会为项目增加复杂性，具有很多配置选项，需要开发者熟悉和掌握。然后，作者强调 TypeScript 并不是类型安全的，尤其在处理用户输入、文件访问、网络数据获取等 I/O 操作时，需要依赖开发者的类型注释或断言。此外，TypeScript 有许多版本和使用方式，每个团队都会找到适合自己的方式和工具。最后，尽管存在上述问题，但作者认为学习和使用 TypeScript 是值得的，因为它能使开发者的工作更有效率，也使代码更易于理解和维护。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 LangSmith，一个用于调试、测试、评估和监控 LLM 应用程序的统一平台]]></title>
        <id>https://blog.langchain.dev/announcing-langsmith/</id>
        <link href="https://blog.langchain.dev/announcing-langsmith/"/>
        <updated>2023-07-25T00:41:43.750Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.langchain.dev/announcing-langsmith/">Announcing LangSmith, a unified platform for debugging, testing, evaluating, and monitoring your LLM applications</a></p><p><strong>概要：</strong></p><p>LangChain 是一个开源 Python 包，旨在简化 LLM（Large Language Models）驱动的应用程序开发。然而，将应用程序从原型转变为生产版本仍然面临挑战，主要问题在于应用性能。为了解决这个问题，LangChain 推出了 LangSmith 平台，帮助开发者更好地从原型转向生产。该平台提供了一整套工具和实践，包括调试、测试、日志记录、监控等，使开发者可以专注于构建他们的应用程序。LangSmith 目前处于封闭测试阶段。它的五大核心功能包括：调试、测试、评估、监控以及统一平台。LangSmith 已经成功帮助了 Streamlit、Snowflake、波士顿咨询集团等公司实现了智能代理人的原型设计，并在 DeepLearningAI 的 LangChain 课程中帮助学生更好地理解模型。此外，LangSmith 还计划推出新的功能，如分析、协作、即时学习、提示创建等，并支持导出数据集以便进行微调或加载到其他分析引擎中。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何取得成功]]></title>
        <id>https://blog.samaltman.com/how-to-be-successful</id>
        <link href="https://blog.samaltman.com/how-to-be-successful"/>
        <updated>2023-07-24T04:41:08.273Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.samaltman.com/how-to-be-successful">How To Be Successful</a></p><p><strong>概要：</strong></p><p>这篇文章是由 Y Combinator 的合伙人 Sam Altman 撰写，分享了他对创业成功的 13 个观点。首先，他强调了复利效应的重要性，建议寻找并创造具有网络效应和极端可扩展性的业务。其次，他提倡培养过度的自我信念，独立思考，并学会销售。他还建议早期在职业生涯中冒险，保持专注并努力工作。此外，他鼓励大胆行事，坚定意志，难以与之竞争，并建立一个网络。他指出，通过拥有价值迅速增长的东西来致富，并主张内驱动。最后，他强调了自我激励的重要性，认为最成功的人通常是由内心驱动的，他们做事是为了给自己留下深刻印象，因为他们感到有必要在世界上做出一些事情。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们如何从典型 Rust SDK 生成 JavaScript 和 Python SDK - PostgresML]]></title>
        <id>https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk</id>
        <link href="https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk"/>
        <updated>2023-07-24T01:57:43.612Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://postgresml.org/blog/how-we-generate-javascript-and-python-sdks-from-our-canonical-rust-sdk">How We Generate JavaScript and Python SDKs From Our Canonical Rust SDK – PostgresML</a></p><p><strong>概要：</strong></p><p>PostgresML 团队正在开发一种新的软件开发工具包（SDK），能够将用 Rust 编写的代码转化为 Python 和 JavaScript 模块。他们选择 Rust 作为主要语言，因为它能使代码更安全并加快开发周期。然而，大多数用户仍在使用 Python 和 JavaScript 等语言，所以他们决定制作一个可以在多种语言中使用的 SDK。他们的目标是只在 Rust 中编写一次 SDK，然后使其在任何目标语言中都可用。为此，他们创建了一种流程，通过使用自定义宏来生成 Pyo3 和 Neon Rust 所需的代码。他们还计划将这些宏推广出去，并添加对更多语言的支持。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jeremy Mikkola - 是什么让开发人员富有成效？]]></title>
        <id>https://jeremymikkola.com/posts/developer_productivity.html</id>
        <link href="https://jeremymikkola.com/posts/developer_productivity.html"/>
        <updated>2023-07-24T01:56:32.036Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jeremymikkola.com/posts/developer_productivity.html">Jeremy Mikkola - What makes developers productive?</a></p><p><strong>概要：</strong></p><p>这篇文章探讨了影响开发者生产力的多个因素。一些因素如构建时间容易衡量，但有些因素如开发者对系统的理解程度则难以直接衡量。文章指出，知道要构建什么、做更少的事情、使用反应迅速的工具、开发者头脑中的知识、有帮助的基础设施、低技术债务、低失败率、实用的生产实践、工程师的专注度和完成任务等都是影响生产力的重要因素。作者强调，尽管不能直接通过仪表板来衡量所有这些不同的因素，但任何开发者都能告诉你哪些因素正在影响他们的生产力。修复这些问题可能会大大提高完成任务的数量。例如，花几个小时写一份文档可能会为公司节省数千个小时。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 查询和 React 上下文]]></title>
        <id>https://tkdodo.eu/blog/react-query-and-react-context</id>
        <link href="https://tkdodo.eu/blog/react-query-and-react-context"/>
        <updated>2023-07-24T01:54:02.854Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tkdodo.eu/blog/react-query-and-react-context">React Query and React Context</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了 React Query 的实践应用，特别是在组件树中使用查询的优势。作者指出，React Query 允许我们在需要数据的地方获取数据，使组件解耦和独立。然而，这并非完美无缺，也存在一些权衡。例如，为了使组件自动化，它必须处理查询数据不可用的情况，如加载和错误状态。此外，还存在隐式依赖性问题，即只存在于我们头脑中的依赖关系，但在代码中却看不到。最后，作者提出了一个解决方案，即通过 React Context 使依赖性显性化。尽管 TypeScript 可能不喜欢这种方法，但我们可以通过添加一个不变量来确保在错误的地方访问 useCurrentUserContext 时能快速失败并给出好的错误信息。总的来说，虽然这种技术可能会产生网络瀑布等问题，但对于子树的必需数据（如用户信息）来说，这仍是一种可行的方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最重要的编码习惯]]></title>
        <id>https://puppycoding.com/2023/07/22/healthy-coding-habits/</id>
        <link href="https://puppycoding.com/2023/07/22/healthy-coding-habits/"/>
        <updated>2023-07-24T01:53:42.324Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://puppycoding.com/2023/07/22/healthy-coding-habits/">The Most Important Coding Habits</a></p><p><strong>概要：</strong></p><p>这篇文章的作者分享了他因长时间低头对着键盘编程，导致脊椎间盘突出（俗称 “椎间盘滑脱”）的痛苦经历。他认为，对于程序员来说，最重要的习惯并不是提高代码的可读性、一致性或组织性，而是保持健康的身体以便能长期从事这项工作。他建议大家每天进行拉伸运动，定时休息，避免深夜编程，并改善工作环境，比如使用站立式办公桌等。他希望大家能从他的错误中吸取教训，享受健康编程的乐趣。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[好的代码就像一封情书，写给下一个维护它的开发人员。]]></title>
        <id>https://addyosmani.com/blog/good-code/</id>
        <link href="https://addyosmani.com/blog/good-code/"/>
        <updated>2023-07-24T01:53:22.928Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/good-code/">Good code is like a love letter to the next developer who will maintain it.</a></p><p><strong>概要：</strong></p><p>这篇文章将编程比作写情书，强调了编码的实质是沟通。好的代码就像一封爱情信件，是开发者之间的亲密对话。好的代码个性化、真诚、无需多余复杂性，且考虑到下一个维护它的开发者。我们有设计模式和原则来塑造我们的代码，使其可扩展、可维护、高效，同时也易读和易懂。好的代码会巧妙地利用这些模式，就像熟练的诗人使用诗歌设备来创造共鸣。SOLID, DRY, KISS 和 YAGNI 不仅仅是原则，而是编写好代码的基石。好的代码还遵循既定的最佳实践，如适当的命名规范、模块化和详尽的注释。同样重要的是进行严格的测试和采用测试驱动开发（TDD）的做法。最后，编写他人能阅读、理解和维护的代码，是对专业尊重的体现。因此，好的代码不仅是一封情书，更是我们留给后来者的持久遗产。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有效的代码审查]]></title>
        <id>https://addyosmani.com/blog/code-reviews/</id>
        <link href="https://addyosmani.com/blog/code-reviews/"/>
        <updated>2023-07-24T01:52:59.652Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/code-reviews/">Effective Code Reviews</a></p><p><strong>概要：</strong></p><p>这篇文章主要讲述了进行有效代码审查的指导方针。对于代码作者，应尊重审查者的时间，首先自我审查代码，分解大的更改列表，自动化简单任务，严格限定代码变更范围，积极回应批评，减少审查轮次之间的延迟，明确询问不清楚的信息，并明确沟通反馈。同时，不要忘记编写文档。对于审查者来说，应验证代码是否必需且设计良好，是否易读且目标明确，注释是否解释了代码存在的原因而非其功能，代码是否过于复杂，是否遵循团队的样式指南，以及是否经过充分测试和文档记录。此外，审查评论应专注于代码本身，避免贬低或模糊的评论，而是提供明确、具体且适当的正面反馈。审查过程中需要考虑多个标准，如代码是否满足需求，逻辑是否正确，是否安全等。总的来说，代码审查应尊重、建设性且有针对性，作者和审查者都在维护代码质量和保证其长期可维护性上发挥关键作用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - vantezzen/auto-form：基于 zod 模式自动创建 @shadcn/ui 表单的 React 组件。]]></title>
        <id>https://github.com/vantezzen/auto-form</id>
        <link href="https://github.com/vantezzen/auto-form"/>
        <updated>2023-07-24T01:36:39.348Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/vantezzen/auto-form">GitHub - vantezzen/auto-form: 🌟  A React component that automatically creates a @shadcn/ui form based on a zod schema.</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 AutoForm 的 React 组件，它能根据 zod 模式自动创建一个 @shadcn/ui 表单。安装该组件需要依赖于 shadcn/ui 的多个组件，如：折叠面板、按钮、日历、卡片、复选框、表单、输入框、标签、弹出窗、单选组、选择器、分隔符、开关、文本区和切换等。目前支持的字段类型有：布尔值（复选框、开关）、日期（日期选择器）、枚举（选择器、单选组）、数字（输入框）和字符串（输入框、文本字段）。使用时只能在客户端的 React 组件中使用，如果在 Next.js 应用中使用，需要将组件标记为 "使用客户端"。你可以通过 describe 方法为每个字段设置标签和描述，如果没有设置标签，将使用字段名称并取消驼峰命名。所有字段默认都是必填的，可以通过 optional 方法将字段设置为可选。你还可以通过 default 方法为字段设置默认值。你可以使用 inputProps 属性将 props 传递给输入组件。你可以使用 description 属性在字段下方添加描述。你可以使用 renderParent 属性自定义输入的父元素。有两种方式可以访问表单数据：onSubmit 和 Controlled form。你可以使用 AutoFormSubmit 组件创建提交按钮。所有传递给 AutoForm 组件的子元素都将在表单下方渲染。最后，该组件的许可证为 MIT。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Turborepo 如何从 Go 移植到 Rust - Vercel]]></title>
        <id>https://vercel.com/blog/how-turborepo-is-porting-from-go-to-rust</id>
        <link href="https://vercel.com/blog/how-turborepo-is-porting-from-go-to-rust"/>
        <updated>2023-07-24T01:33:07.553Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/how-turborepo-is-porting-from-go-to-rust">How Turborepo is porting from Go to Rust – Vercel</a></p><p><strong>概要：</strong></p><p>文章讲述了为何以及如何将 Turborepo，一个高性能的 JavaScript 和 TypeScript 构建系统，从 Go 语言迁移到 Rust 语言。首先，他们确定了迁移是可行的，并开始了这个过程。在迁移策略上，他们选择了逐步迁移而非全面重写，因为全面重写会带来一些问题，例如需要暂停新功能的开发，可能导致用户体验下降等。逐步迁移则可以保持原有代码的行为不变，同时进行 Go 和 Rust 代码的互操作。他们首先用 Rust 编写了一个小的新功能，然后逐渐将更多的代码迁移到 Rust。在这个过程中，他们遇到了一些挑战，例如在不同的操作系统和 Linux 版本上测试代码时出现的问题，但最终都得到了解决。通过这次迁移，他们认识到序列化对于互操作性非常有用，逐步迁移需要充分的准备和测试，跨平台、跨语言的发布工程非常具有挑战性，但对他们来说，从 Go 迁移到 Rust 是值得的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 React 中使用 svg 精灵图标]]></title>
        <id>https://www.jacobparis.com/content/svg-icons</id>
        <link href="https://www.jacobparis.com/content/svg-icons"/>
        <updated>2023-07-24T01:32:02.963Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.jacobparis.com/content/svg-icons">Use svg sprite icons in React</a></p><p><strong>概要：</strong></p><p>文章介绍了在 React 应用中使用 svg 图标的方法。最直观但效率最低的方式是将 svg 代码直接写入组件作为 JSX，这会增加包的大小。最好的方式是使用 svg spritesheet，它是一种包含许多精灵（本例中的图标）的单个图像。我们可以通过加载一个大图像并通过代码只显示需要的部分来优化图像加载。网站可以使用同样的策略将许多图标存储在一个 svg 文件中，称为 svg spritesheet。每个图标精灵都存储为 svg 文件内的 <symbol> 元素，我们可以通过使用 < use > 元素并引用图标的 id 来显示特定的图标。文章详细介绍了如何构建一个脚本，将一个文件夹的 svg 图标编译成一个单独的 svg spritesheet，以及如何构建一个 React 组件，通过名称显示特定的图标，并为可用的图标提供完全类型安全的自动完成功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[制作开发人员想要的东西]]></title>
        <id>https://leerob.io/blog/make-something-developers-want</id>
        <link href="https://leerob.io/blog/make-something-developers-want"/>
        <updated>2023-07-21T06:39:33.921Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://leerob.io/blog/make-something-developers-want">Make Something Developers Want</a></p><p><strong>概要：</strong></p><p>Y Combinator 以他们的建议而闻名：制造人们想要的东西。然而，当这些客户是开发者时，我会认为执行这个建议的方式看起来有所不同，可能与人们通常想要的相反。以下是你应该做的，以制造开发者想要的东西：你应该接受开源；你应该有一个免费的层级；你应该有优秀的文档；你应该能够得到开发者的支持；你应该是一个社区的一部分。1. 你应该接受开源，因为经验丰富的开发者喜欢开源产品，新手开发者也喜欢开源产品，因为他们正在学习帮助他们在职业生涯中提升的技能。2. 你应该有一个免费的层级，开发者不想和你的销售团队交谈，他们想尽可能少的摩擦地试用产品。3. 你应该有优秀的文档，文档越好，开发者就越可能尝试你的产品。4. 你应该能够得到开发者的支持，当开发者在你的文档中找不到答案时，他们会寻求支持。5. 你应该成为一个社区的一部分，开发者去哪里玩？在线和线下社区。你需要在那里提供价值。这是一个长期的游戏，有时需要花费几年时间才能实现价值，但事后看来是显而易见的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SvelteJS：我的生态系统比你的大 - HackMD]]></title>
        <id>https://hackmd.io/@roguegpu/r1RKQMdt3</id>
        <link href="https://hackmd.io/@roguegpu/r1RKQMdt3"/>
        <updated>2023-07-21T01:52:32.582Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://hackmd.io/@roguegpu/r1RKQMdt3">SvelteJS: My ecosystem is bigger than yours  - HackMD</a></p><p><strong>概要：</strong></p><p>文章主要讨论了 Svelte 和 React 之间的差异，以及为何使用 Svelte 可能是更好的选择。作者指出，尽管 Svelte 的生态系统相比 React 较小，但这并不意味着它的功能有所欠缺。事实上，Svelte 的一些特性，如内置的状态管理 API 和转换 API，使得开发者无需寻找额外的库就能解决问题。此外，Svelte 还允许直接在框架中进行样式设置，而无需引入其他库。作者还展示了如何在 Svelte 中使用 ag-grid 和 chart.js 等库，并指出与 React 相比，Svelte 可以更直接地使用这些库，而无需通过封装器。最后，作者总结道，虽然使用 React 可能需要学习更多的封装器，但使用 Svelte 则可以更直接地学习和使用底层库。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Persson Dennis - 为何选择服务器组件 - 网络简史]]></title>
        <id>https://www.perssondennis.com/articles/why-server-components-a-brief-history-of-web</id>
        <link href="https://www.perssondennis.com/articles/why-server-components-a-brief-history-of-web"/>
        <updated>2023-07-21T01:37:12.848Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.perssondennis.com/articles/why-server-components-a-brief-history-of-web">Persson Dennis - Why Server Components - A Brief History of Web</a></p><p><strong>概要：</strong></p><p>根据 Stack Overflow 2023 年的调查，Next.js 现在是开发人员最想要的 web 框架中的第三名，也是最受欢迎的第六名。尽管他们的旧版 Pages Router 非常出色，但他们在框架的第 13 版中引入了新的 App Router。随着这个变化，他们还迁移到使用 Server Components，这可以被视为下一级别的服务器渲染。本文将从网络的起源开始，通过各种类型的服务器渲染及其所有优点，到最新的 Next.js Server Components 的网络开发状态，来帮助你理解为什么 Next.js 和 Server Components 不仅仅是传统的客户端 React 应用程序。文章中还详细讨论了服务器渲染与 SPA 的转变，以及客户端组件与服务器组件的对比等内容。总的来说，Next.js 现在允许为每个组件决定是否应该在服务器上预渲染，或者是否需要在客户端上渲染。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于最大化 Rust 代码的性能 | Jonathan Becker]]></title>
        <id>https://jbecker.dev/research/on-writing-performant-rust</id>
        <link href="https://jbecker.dev/research/on-writing-performant-rust"/>
        <updated>2023-07-21T01:31:31.958Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jbecker.dev/research/on-writing-performant-rust">On Maximizing Your Rust Code's Performance | Jonathan Becker</a></p><p><strong>概要：</strong></p><p>文章内容为空，无法进行总结。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JPEG XL 的崛起：苹果公司的支持和图像压缩见解]]></title>
        <id>https://cloudinary.com/blog/jpeg-xl-how-it-started-how-its-going</id>
        <link href="https://cloudinary.com/blog/jpeg-xl-how-it-started-how-its-going"/>
        <updated>2023-07-21T01:26:45.140Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://cloudinary.com/blog/jpeg-xl-how-it-started-how-its-going">Rise of JPEG XL: Apple's Support and Image Compression Insights</a></p><p><strong>概要：</strong></p><p>在上个月的全球开发者大会上，苹果宣布支持 JPEG XL。JPEG XL 是 2018 年 JPEG 委员会启动的下一代图像压缩提案中的一个，由 Google 的 PIK 和 Cloudinary 的 FUIF 提案合并而成。到 2020 年底，主要技术工作完成，比特流冻结，即不再做任何会改变解码器视角的格式更改。然后，在 2023 年 6 月 5 日，苹果的年度全球开发者大会 (WWDC23) 上，Safari 浏览器的新功能列表中出现了 “JPEG XL”。Safari 17 不仅将添加 JPEG XL 支持，新版本的 iOS、iPadOS、macOS、watchOS 和 visionOS 也将支持 JPEG XL。这对 JPEG XL 的采用无疑是好消息。图像压缩是我们在 Cloudinary 的重要工作，我们需要深入理解何时使用哪种编码器，或者说，使用哪种编码器和设置。因此，我们做了一个大实验，创建了 Cloudinary Image Dataset (CID22)，一个大型的人工注释压缩图像数据集。这有助于我们更好地理解压缩对感知质量的影响。目前，JPEG XL 是平均压缩性能最好的编码器，但各种图像的表现存在很大的差异。因此，我们正在研究一个 AI 驱动的新版本的 f_auto,q_auto 特性，可以自动选择最优的格式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 Next13 中使用服务器组件的 5 个常见陷阱（附示例）]]></title>
        <id>https://www.propelauth.com/post/5-common-pitfalls-with-server-components-in-next13-with-examples</id>
        <link href="https://www.propelauth.com/post/5-common-pitfalls-with-server-components-in-next13-with-examples"/>
        <updated>2023-07-21T01:18:56.684Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.propelauth.com/post/5-common-pitfalls-with-server-components-in-next13-with-examples">5 Common Pitfalls with Server Components in Next13 (with examples)</a></p><p><strong>概要：</strong></p><p>NextJS 13 引入了一个新特性 ——App Router，现已成为创建新的 NextJS 应用时推荐的选项，这有效地取代了 Pages Router。App Router 最显著的不同之处在于，默认情况下所有组件都是服务器组件，而非客户端组件。服务器组件与客户端组件有几个重大的差异，可能会引起混淆。本文主要解析了以下几个常见问题：1. 在服务器组件中使用 React Hooks；2. 在服务器组件中使用事件处理器（如 onClick）；3. 直接将服务器组件导入到客户端组件中；4. 假设服务器组件会重新渲染；5. 在服务器组件中设置 cookies；6. 尝试从服务器传递非序列化属性到客户端。对于每个问题，文章都提供了修复方法和替代方案。总的来说，虽然服务器组件是 Next13 的强大功能，但也需要注意一些潜在问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么 Zustand Typescript 的实现如此丑陋？]]></title>
        <id>https://blog.axlight.com/posts/why-zustand-typescript-implementation-is-so-ugly/</id>
        <link href="https://blog.axlight.com/posts/why-zustand-typescript-implementation-is-so-ugly/"/>
        <updated>2023-07-21T01:18:06.716Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.axlight.com/posts/why-zustand-typescript-implementation-is-so-ugly/">Why Zustand Typescript Implementation Is So Ugly</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了 Zustand 库在 TypeScript 中的实现。虽然 Zustand 的 JavaScript 实现非常简洁，但其在 TypeScript 中的实现却相当复杂。文章分析了其中一个原因 ——SetStateInternal 类型。这种类型使用了 TypeScript 的一种技巧，如果不使用这种技巧，会导致某些情况下无法正常工作。文章强调，作为库的使用者，无需知道这背后的原理，这是 TypeScript 专家应该处理的问题。文章还提到，Zustand 在 TypeScript 中的实现复杂性还有其他原因，可能会在未来的文章中进行探讨。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用 NextJS 13 应用路由器解密 React 服务器组件]]></title>
        <id>https://demystifying-rsc.vercel.app/</id>
        <link href="https://demystifying-rsc.vercel.app/"/>
        <updated>2023-07-21T01:17:39.270Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://demystifying-rsc.vercel.app/">Demystifying React Server Components with NextJS 13 App Router</a></p><p><strong>概要：</strong></p><p>这个应用程序的目的是以一种揭示真实情况的方式展示 NextJS13 中 React Server 组件的概念和代码。目标受众是有经验的 React 开发者，可能对 RSC 不熟悉，或者正在使用 RSC 并希望更深入理解其工作原理。这个教程可以在 GitHub 上克隆。本教程旨在线性步骤中进行，但你可以跳到下面的任何页面。重要内容包括静态内容、虚拟 DOM、整合客户端组件、水合失败、禁用客户端组件的 SSR、禁用服务器端的组件 SSR、客户端组件详情、服务器组件作为客户端组件的子代、将服务器组件导入到客户端组件、异步服务器组件、服务器端暂停流、动态更新服务器渲染内容、RSC 缓存、服务器功能？、RSC 常见问题、App 路由器演示等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 TypeChat - TypeChat]]></title>
        <id>https://microsoft.github.io/TypeChat/blog/introducing-typechat/</id>
        <link href="https://microsoft.github.io/TypeChat/blog/introducing-typechat/"/>
        <updated>2023-07-21T01:09:00.943Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://microsoft.github.io/TypeChat/blog/introducing-typechat/">Introducing TypeChat - TypeChat</a></p><p><strong>概要：</strong></p><p>2023 年 7 月 20 日，Anders Hejlsberg、Steve Lucco、Daniel Rosenwasser、Pierce Boggan、Umesh Madan、Mike Hopcroft 和 Gayathri Chandrasekaran 发布了一款名为 TypeChat 的实验性库。这个库旨在解决如何将大型语言模型最好地集成到现有的应用界面中，以及如何使用 AI 将用户请求转化为应用可以操作的内容等问题。TypeChat 利用代码库中的类型定义来获取结构化且类型安全的 AI 响应。此外，TypeChat 还能与任何语言模型配合使用。开发者们发现，由于大型语言模型已经看到了许多类型定义，因此类型也可以作为 AI 应该如何响应的指导。TypeChat 是开源的，且设计出来是为了适应各种模型。尽管目前它与 OpenAI API 和 Azure OpenAI 服务有基本的集成，但理论上它应该适用于任何你想使用的聊天补全式 API。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[过去并非真实]]></title>
        <id>https://sive.rs/pnt</id>
        <link href="https://sive.rs/pnt"/>
        <updated>2023-07-20T07:56:20.540Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://sive.rs/pnt">The past is not true</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了作者在 17 岁时，因驾驶不慎撞到了一辆迎面而来的车，导致对方司机的脊柱受伤，无法行走。这件事让他背负了巨大的罪恶感，直到 35 岁时才决定去找这个女人道歉。然而当他找到她并道歉时，发现她并没有因为那次事故而丧失行走能力，反而因此更加注重健康，身体状况比以前更好。原来，他们两人都被告知是自己的错，并为此感到内疚了 18 年。这让作者意识到，过去的记忆和故事并非完全真实，微小的误解可以随着时间的推移被放大，形成误解。历史并非绝对真实，我们可以改变历史，因为真正的事实只占很小的一部分，其余都是解释和理解。所以，改变故事永远不会太晚。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不要指望每天都有动力]]></title>
        <id>https://addyosmani.com/blog/motivation/</id>
        <link href="https://addyosmani.com/blog/motivation/"/>
        <updated>2023-07-20T00:51:20.291Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/motivation/">Don't expect to be motivated everyday</a></p><p><strong>概要：</strong></p><p>这篇文章强调了纪律对于实现目标的重要性，而不是仅仅依赖动力。动力虽然能驱使我们完成伟大的事情，但它并不可靠且短暂。作者建议通过以下三种策略来培养纪律：开始小，比如每天写 100 个单词或完成 5 分钟的锻炼；保持一致，选择一个特定的时间或提示来执行你的习惯，并将其变成日常生活中不可更改的部分；接受失败，理解挫折是过程的自然部分，当你犯错误时，从中学习并继续前进。纪律为创建习惯奠定基础，从而形成例行公事，最终定义我们每天的自我。因此，下次当你缺乏动力时，不要感到绝望，而是依赖你的纪律帮助你度过困难时期并保持对目标的追求。</p>]]></content>
    </entry>
</feed>