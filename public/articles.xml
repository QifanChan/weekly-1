<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-07-21T01:55:29.168Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[SvelteJS：我的生态系统比你的大 - HackMD]]></title>
        <id>https://hackmd.io/@roguegpu/r1RKQMdt3</id>
        <link href="https://hackmd.io/@roguegpu/r1RKQMdt3"/>
        <updated>2023-07-21T01:52:32.582Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://hackmd.io/@roguegpu/r1RKQMdt3">SvelteJS: My ecosystem is bigger than yours  - HackMD</a></p><p><strong>概要：</strong></p><p>文章主要讨论了 Svelte 和 React 之间的差异，以及为何使用 Svelte 可能是更好的选择。作者指出，尽管 Svelte 的生态系统相比 React 较小，但这并不意味着它的功能有所欠缺。事实上，Svelte 的一些特性，如内置的状态管理 API 和转换 API，使得开发者无需寻找额外的库就能解决问题。此外，Svelte 还允许直接在框架中进行样式设置，而无需引入其他库。作者还展示了如何在 Svelte 中使用 ag-grid 和 chart.js 等库，并指出与 React 相比，Svelte 可以更直接地使用这些库，而无需通过封装器。最后，作者总结道，虽然使用 React 可能需要学习更多的封装器，但使用 Svelte 则可以更直接地学习和使用底层库。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Persson Dennis - 为何选择服务器组件 - 网络简史]]></title>
        <id>https://www.perssondennis.com/articles/why-server-components-a-brief-history-of-web</id>
        <link href="https://www.perssondennis.com/articles/why-server-components-a-brief-history-of-web"/>
        <updated>2023-07-21T01:37:12.848Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.perssondennis.com/articles/why-server-components-a-brief-history-of-web">Persson Dennis - Why Server Components - A Brief History of Web</a></p><p><strong>概要：</strong></p><p>根据 Stack Overflow 2023 年的调查，Next.js 现在是开发人员最想要的 web 框架中的第三名，也是最受欢迎的第六名。尽管他们的旧版 Pages Router 非常出色，但他们在框架的第 13 版中引入了新的 App Router。随着这个变化，他们还迁移到使用 Server Components，这可以被视为下一级别的服务器渲染。本文将从网络的起源开始，通过各种类型的服务器渲染及其所有优点，到最新的 Next.js Server Components 的网络开发状态，来帮助你理解为什么 Next.js 和 Server Components 不仅仅是传统的客户端 React 应用程序。文章中还详细讨论了服务器渲染与 SPA 的转变，以及客户端组件与服务器组件的对比等内容。总的来说，Next.js 现在允许为每个组件决定是否应该在服务器上预渲染，或者是否需要在客户端上渲染。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于最大化 Rust 代码的性能 | Jonathan Becker]]></title>
        <id>https://jbecker.dev/research/on-writing-performant-rust</id>
        <link href="https://jbecker.dev/research/on-writing-performant-rust"/>
        <updated>2023-07-21T01:31:31.958Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jbecker.dev/research/on-writing-performant-rust">On Maximizing Your Rust Code's Performance | Jonathan Becker</a></p><p><strong>概要：</strong></p><p>文章内容为空，无法进行总结。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JPEG XL 的崛起：苹果公司的支持和图像压缩见解]]></title>
        <id>https://cloudinary.com/blog/jpeg-xl-how-it-started-how-its-going</id>
        <link href="https://cloudinary.com/blog/jpeg-xl-how-it-started-how-its-going"/>
        <updated>2023-07-21T01:26:45.140Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://cloudinary.com/blog/jpeg-xl-how-it-started-how-its-going">Rise of JPEG XL: Apple's Support and Image Compression Insights</a></p><p><strong>概要：</strong></p><p>在上个月的全球开发者大会上，苹果宣布支持 JPEG XL。JPEG XL 是 2018 年 JPEG 委员会启动的下一代图像压缩提案中的一个，由 Google 的 PIK 和 Cloudinary 的 FUIF 提案合并而成。到 2020 年底，主要技术工作完成，比特流冻结，即不再做任何会改变解码器视角的格式更改。然后，在 2023 年 6 月 5 日，苹果的年度全球开发者大会 (WWDC23) 上，Safari 浏览器的新功能列表中出现了 “JPEG XL”。Safari 17 不仅将添加 JPEG XL 支持，新版本的 iOS、iPadOS、macOS、watchOS 和 visionOS 也将支持 JPEG XL。这对 JPEG XL 的采用无疑是好消息。图像压缩是我们在 Cloudinary 的重要工作，我们需要深入理解何时使用哪种编码器，或者说，使用哪种编码器和设置。因此，我们做了一个大实验，创建了 Cloudinary Image Dataset (CID22)，一个大型的人工注释压缩图像数据集。这有助于我们更好地理解压缩对感知质量的影响。目前，JPEG XL 是平均压缩性能最好的编码器，但各种图像的表现存在很大的差异。因此，我们正在研究一个 AI 驱动的新版本的 f_auto,q_auto 特性，可以自动选择最优的格式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 Next13 中使用服务器组件的 5 个常见陷阱（附示例）]]></title>
        <id>https://www.propelauth.com/post/5-common-pitfalls-with-server-components-in-next13-with-examples</id>
        <link href="https://www.propelauth.com/post/5-common-pitfalls-with-server-components-in-next13-with-examples"/>
        <updated>2023-07-21T01:18:56.684Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.propelauth.com/post/5-common-pitfalls-with-server-components-in-next13-with-examples">5 Common Pitfalls with Server Components in Next13 (with examples)</a></p><p><strong>概要：</strong></p><p>NextJS 13 引入了一个新特性 ——App Router，现已成为创建新的 NextJS 应用时推荐的选项，这有效地取代了 Pages Router。App Router 最显著的不同之处在于，默认情况下所有组件都是服务器组件，而非客户端组件。服务器组件与客户端组件有几个重大的差异，可能会引起混淆。本文主要解析了以下几个常见问题：1. 在服务器组件中使用 React Hooks；2. 在服务器组件中使用事件处理器（如 onClick）；3. 直接将服务器组件导入到客户端组件中；4. 假设服务器组件会重新渲染；5. 在服务器组件中设置 cookies；6. 尝试从服务器传递非序列化属性到客户端。对于每个问题，文章都提供了修复方法和替代方案。总的来说，虽然服务器组件是 Next13 的强大功能，但也需要注意一些潜在问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么 Zustand Typescript 的实现如此丑陋？]]></title>
        <id>https://blog.axlight.com/posts/why-zustand-typescript-implementation-is-so-ugly/</id>
        <link href="https://blog.axlight.com/posts/why-zustand-typescript-implementation-is-so-ugly/"/>
        <updated>2023-07-21T01:18:06.716Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.axlight.com/posts/why-zustand-typescript-implementation-is-so-ugly/">Why Zustand Typescript Implementation Is So Ugly</a></p><p><strong>概要：</strong></p><p>这篇文章主要讨论了 Zustand 库在 TypeScript 中的实现。虽然 Zustand 的 JavaScript 实现非常简洁，但其在 TypeScript 中的实现却相当复杂。文章分析了其中一个原因 ——SetStateInternal 类型。这种类型使用了 TypeScript 的一种技巧，如果不使用这种技巧，会导致某些情况下无法正常工作。文章强调，作为库的使用者，无需知道这背后的原理，这是 TypeScript 专家应该处理的问题。文章还提到，Zustand 在 TypeScript 中的实现复杂性还有其他原因，可能会在未来的文章中进行探讨。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用 NextJS 13 应用路由器解密 React 服务器组件]]></title>
        <id>https://demystifying-rsc.vercel.app/</id>
        <link href="https://demystifying-rsc.vercel.app/"/>
        <updated>2023-07-21T01:17:39.270Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://demystifying-rsc.vercel.app/">Demystifying React Server Components with NextJS 13 App Router</a></p><p><strong>概要：</strong></p><p>这个应用程序的目的是以一种揭示真实情况的方式展示 NextJS13 中 React Server 组件的概念和代码。目标受众是有经验的 React 开发者，可能对 RSC 不熟悉，或者正在使用 RSC 并希望更深入理解其工作原理。这个教程可以在 GitHub 上克隆。本教程旨在线性步骤中进行，但你可以跳到下面的任何页面。重要内容包括静态内容、虚拟 DOM、整合客户端组件、水合失败、禁用客户端组件的 SSR、禁用服务器端的组件 SSR、客户端组件详情、服务器组件作为客户端组件的子代、将服务器组件导入到客户端组件、异步服务器组件、服务器端暂停流、动态更新服务器渲染内容、RSC 缓存、服务器功能？、RSC 常见问题、App 路由器演示等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 TypeChat - TypeChat]]></title>
        <id>https://microsoft.github.io/TypeChat/blog/introducing-typechat/</id>
        <link href="https://microsoft.github.io/TypeChat/blog/introducing-typechat/"/>
        <updated>2023-07-21T01:09:00.943Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://microsoft.github.io/TypeChat/blog/introducing-typechat/">Introducing TypeChat - TypeChat</a></p><p><strong>概要：</strong></p><p>2023 年 7 月 20 日，Anders Hejlsberg、Steve Lucco、Daniel Rosenwasser、Pierce Boggan、Umesh Madan、Mike Hopcroft 和 Gayathri Chandrasekaran 发布了一款名为 TypeChat 的实验性库。这个库旨在解决如何将大型语言模型最好地集成到现有的应用界面中，以及如何使用 AI 将用户请求转化为应用可以操作的内容等问题。TypeChat 利用代码库中的类型定义来获取结构化且类型安全的 AI 响应。此外，TypeChat 还能与任何语言模型配合使用。开发者们发现，由于大型语言模型已经看到了许多类型定义，因此类型也可以作为 AI 应该如何响应的指导。TypeChat 是开源的，且设计出来是为了适应各种模型。尽管目前它与 OpenAI API 和 Azure OpenAI 服务有基本的集成，但理论上它应该适用于任何你想使用的聊天补全式 API。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[过去并非真实]]></title>
        <id>https://sive.rs/pnt</id>
        <link href="https://sive.rs/pnt"/>
        <updated>2023-07-20T07:56:20.540Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://sive.rs/pnt">The past is not true</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了作者在 17 岁时，因驾驶不慎撞到了一辆迎面而来的车，导致对方司机的脊柱受伤，无法行走。这件事让他背负了巨大的罪恶感，直到 35 岁时才决定去找这个女人道歉。然而当他找到她并道歉时，发现她并没有因为那次事故而丧失行走能力，反而因此更加注重健康，身体状况比以前更好。原来，他们两人都被告知是自己的错，并为此感到内疚了 18 年。这让作者意识到，过去的记忆和故事并非完全真实，微小的误解可以随着时间的推移被放大，形成误解。历史并非绝对真实，我们可以改变历史，因为真正的事实只占很小的一部分，其余都是解释和理解。所以，改变故事永远不会太晚。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不要指望每天都有动力]]></title>
        <id>https://addyosmani.com/blog/motivation/</id>
        <link href="https://addyosmani.com/blog/motivation/"/>
        <updated>2023-07-20T00:51:20.291Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/motivation/">Don't expect to be motivated everyday</a></p><p><strong>概要：</strong></p><p>这篇文章强调了纪律对于实现目标的重要性，而不是仅仅依赖动力。动力虽然能驱使我们完成伟大的事情，但它并不可靠且短暂。作者建议通过以下三种策略来培养纪律：开始小，比如每天写 100 个单词或完成 5 分钟的锻炼；保持一致，选择一个特定的时间或提示来执行你的习惯，并将其变成日常生活中不可更改的部分；接受失败，理解挫折是过程的自然部分，当你犯错误时，从中学习并继续前进。纪律为创建习惯奠定基础，从而形成例行公事，最终定义我们每天的自我。因此，下次当你缺乏动力时，不要感到绝望，而是依赖你的纪律帮助你度过困难时期并保持对目标的追求。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[是时候升级显示器了]]></title>
        <id>https://tonsky.me/blog/monitors/</id>
        <link href="https://tonsky.me/blog/monitors/"/>
        <updated>2023-07-20T00:48:28.727Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tonsky.me/blog/monitors/">Time to upgrade your monitor</a></p><p><strong>概要：</strong></p><p>这篇文章是作者根据自身经验，讨论了编程人员最佳显示器选择的观点。他认为，对于大多数编程工作，高分辨率和清晰的字体显示至关重要。他建议购买 4K 分辨率的显示器，并使用 2 倍的缩放以获得更好的文本渲染效果。此外，作者还推荐使用 120Hz 的刷新率，尽管这对于文本工作并非必须，但可以提供更流畅的动画和滚动效果，使系统感觉更加响应迅速。不过，他也指出，在 MacOS 上运行 4K 120Hz 显示可能会遇到一些问题，需要进行一些设置调整。总的来说，作者认为独立的高分辨率显示器对于编程工作来说是最佳选择。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[故事书 7.1]]></title>
        <id>https://storybook.js.org/blog/storybook-7-1/</id>
        <link href="https://storybook.js.org/blog/storybook-7-1/"/>
        <updated>2023-07-20T00:45:07.545Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://storybook.js.org/blog/storybook-7-1/">Storybook 7.1</a></p><p><strong>概要：</strong></p><p>Storybook 是 UI 组件开发、文档编写和测试的行业标准工作室，被 Twitter、GitHub、BBC 和纽约时报等团队使用。自今年四月发布 Storybook 7.0 后，我们计划推出更频繁且体积更小的未来版本，以便 Storybook 能够与前端生态系统中的变化保持同步，同时使我们的用户升级过程更加顺畅。今天，我们很高兴为您带来这些版本中的第一个：Storybook 7.1，其中包含了许多改进。此外，Storybook 支持 React、Vue、Angular、Web 组件、Svelte、Webpack 和 Vite 以及超过 400 种集成，使其成为迄今为止最强大的组件工作室。在 Storybook 7.1 中，我们通过为新用户引入入门流程来降低学习曲线。此外，Storybook 7.1 还为 Tailwind、Material UI、Emotion 和 styled-components 等提供了零配置样式支持。我们还为配置文件、ArgTypes 和 Doc 块引入了 API 参考文档，并将 Storybook 的文档制作为 TypeScript 优先，因为 TS 占据了所有 Storybook 项目的 80% 以上。此外，我们还增加了对 Vue 3 源片段和反应性改进的支持，并为文档添加了目录。我们还为 Figma 设计插件提供了官方支持，并进行了数百项修复和改进。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建自己的 FaaS：在 Fly 上自主托管 Cloudflare Worker 和 javascript 函数 | BreakpDev 博客]]></title>
        <id>https://www.breakp.dev/blog/build-your-own-faas/</id>
        <link href="https://www.breakp.dev/blog/build-your-own-faas/"/>
        <updated>2023-07-19T03:25:22.732Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.breakp.dev/blog/build-your-own-faas/">Build your own FaaS: Self-host Cloudflare workers and javascript functions on Fly and everywhere | BreakpDev Blog</a></p><p><strong>概要：</strong></p><p>本文提供了如何构建和自我托管一个完整的 FaaS（Function as a Service）架构的逐步指南。文章首先解释了什么是云计算中的函数以及 FaaS，然后阐述了为什么要自我托管 FaaS。接着，文章详细介绍了如何创建自己的 FaaS，包括设置发布者和工作人员、准备配置、进行干运行和部署等步骤。最后，文章还提供了一些额外的内容，如保护发布者 API、在发布时自动重启工作人员、发布命令行工具等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在网络上使用表情符号]]></title>
        <id>https://fullystacked.net/posts/using-emoji-on-the-web/</id>
        <link href="https://fullystacked.net/posts/using-emoji-on-the-web/"/>
        <updated>2023-07-19T01:29:38.563Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://fullystacked.net/posts/using-emoji-on-the-web/">Using emoji on the web</a></p><p><strong>概要：</strong></p><p>文章讨论了在不同操作系统和浏览器上使用表情符号的问题。大多数浏览器默认使用操作系统提供的表情字体，例如 ChromeOS 和大多数 Android 设备使用 Google 的 Noto Color Emoji，iOS 和 macOS 使用 Apple Color Emoji，Windows 使用 Microsoft Segoe Color Emoji。然而，Firefox 在 Windows 和 Linux 上是个例外，它使用 Twitter 的 Twemoji 字体。在 HTML 标记中使用表情符号通常可以正常工作，但也存在一些问题。例如，一些旧的表情符号可能以单色图标或多色表情符号呈现；Windows 用户（除 Firefox 浏览器外）无法看到国家旗帜的表情符号；老版本操作系统的用户无法获取新的表情符号。解决方案包括显式设置表情字体、使用 CSS 属性 font-variant-emoji、使用 color fonts 等。此外，还可以使用开源的 color emoji 字体，如 Google 的 Noto Color、Adobe 的 Emoji One、Twitter 的 Twemoji、Mozilla 的 FxEmoji 和 Microsoft 的 Fluent Emoji。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动画 SVG 徽标]]></title>
        <id>https://antfu.me/posts/animated-svg-logo</id>
        <link href="https://antfu.me/posts/animated-svg-logo"/>
        <updated>2023-07-19T01:21:42.778Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://antfu.me/posts/animated-svg-logo">Animated SVG Logo</a></p><p><strong>概要：</strong></p><p>文章作者 Anthony Fu 分享了他如何将网站左上角的 Logo 替换为动态 SVG。首次看到这种 SVG 描边动画是在 Vjacheslav Trushkin 的 Material Line Icons 中，但直到在 Mu-An Chiou 的网站上看到类似的设计，才萌生了自己也要做一个的想法。通过研究 Mu-An 的 SVG 代码和参考 Material Line Icons，作者发现他们是通过动画化 stroke-dasharray 来实现这种效果的。原始 Logo 是 8 年前作者用 Surface Pro 4 上的压感笔绘制的，之后用 Adobe Illustrator 进行图像追踪得到 SVG 版本。作者需要用单个描边重新绘制 Logo，然后手动添加样式到导出的 SVG 中，从而得到一个不错的动态 Logo。唯一的缺点是描边在所有地方都均匀粗细，使其看起来不太像签名。作者试图寻找解决方案，最后发现 SVG 支持遮罩功能，于是尝试让描边在遮罩内部动画，并取得了成功。虽然这种方法并非完美，因为无法控制描边宽度，所以描边会稍微偏离遮罩，但作者认为这已经很好了。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fresh 1.3 - 简化的路由组件及其他]]></title>
        <id>https://deno.com/blog/fresh-1.3</id>
        <link href="https://deno.com/blog/fresh-1.3"/>
        <updated>2023-07-19T00:44:37.401Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/fresh-1.3">Fresh 1.3 – Simplified Route Components and More</a></p><p><strong>概要：</strong></p><p>自从我们发布 Fresh 1.2 后仅过去一个月，我们已经回来发布另一个版本！我们计划每个月都发布新的小版本。这个周期包含了社区的许多令人难以置信的 PR，这简直太棒了！文档得到了扩展和改进，修复了许多错误并添加了新功能。感谢所有帮助完成此次发布的人。但话不多说，让我们看看我们对 Fresh 进行了哪些改进。

异步路由组件
从插件中添加路由和 / 或中间件
500 错误模板回退
错误边界
在同一文件中导出多个岛屿
Fresh linting 规则
支持 Deno.serve
更多提高生活质量的改进

异步路由组件我们听到很多反馈，从路由处理程序传递数据到页面的组件需要一些烦人的样板文件。为了确保类型安全，你总是需要为组件的 props 创建一个接口，将其作为通用的传递给 Handlers 类型，并在组件定义中使用它。这真是很多步骤！
由于 GET 处理程序往往与它将呈现的组件高度耦合，显而易见的问题是，为什么我们不直接将两者合并在一起？这正是我们所做的。在 Fresh 1.3 中，我们可以大大简化之前的代码片段：
由于处理程序和组件都在同一个函数中，因此无需声明一个中间接口来在两者之间传递数据；你可以直接传递数据。
但是别担心，没有必要重写所有的路由。实际上，我们并不喜欢重写代码。新的方式只是一个额外的选项，可以使简单的路由更容易编写。使用异步路由并非</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Copilot 7 月 14 日更新]]></title>
        <id>https://github.blog/changelog/2023-07-14-github-copilot-july-14th-update/</id>
        <link href="https://github.blog/changelog/2023-07-14-github-copilot-july-14th-update/"/>
        <updated>2023-07-19T00:26:16.401Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/changelog/2023-07-14-github-copilot-july-14th-update/">GitHub Copilot July 14th Update</a></p><p><strong>概要：</strong></p><p>2023 年 7 月 14 日，GitHub 为其 Visual Studio Code 和 Visual Studio 扩展中的 Chat 功能进行了许多改进，并为管理员提供了新的能力。首先，他们推出了针对 Copilot for Business 的 User Management API（beta），使管理员可以列出所有启用 Copilot 的组织成员及其详细信息，并为个人和团队添加 / 删除访问权限，从而实现大规模的自动化访问管理。此外，他们还在 Visual Studio Code 1.80 中引入了新的创建命令，如 /search, /createWorkspace 等，以帮助用户创建项目和笔记本，并在工作空间中搜索文本。同时，他们还对 Visual Studio 扩展进行了改进，包括更好地支持其他编程语言，保存和恢复聊天历史，清除聊天历史，多行提示框，显示内容的流媒体支持，测试生成的特定插入，以及改善整个聊天体验的各种生活质量更新。最后，他们还引入了基于嵌入的上下文感知操作，如文档，解释和生成测试，这些操作利用现有的内联上下文并制定特定的意图，以提供最佳的任务体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 18 如何提高应用程序性能 - Vercel]]></title>
        <id>https://vercel.com/blog/how-react-18-improves-application-performance</id>
        <link href="https://vercel.com/blog/how-react-18-improves-application-performance"/>
        <updated>2023-07-19T00:24:43.774Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/how-react-18-improves-application-performance">How React 18 Improves Application Performance – Vercel</a></p><p><strong>概要：</strong></p><p>React 18 引入了并发特性，从根本上改变了 React 应用的渲染方式。当我们在浏览器中运行 JavaScript 时，JavaScript 引擎在单线程环境中执行代码，这通常被称为主线程。主线程负责处理其他任务，包括管理用户交互、处理网络事件、定时器、更新动画和管理浏览器重排和重绘。任何运行时间超过 50 毫秒的任务都被视为 "长任务"。React 18 引入了一个新的并发渲染器，它在后台操作。这个渲染器为我们提供了一些方法，使得某些渲染标记为非紧急。此外，这个并发渲染器能够 “并发” 地在后台渲染组件树的多个版本，而不是立即提交结果。React 服务器组件是 React 18 的实验性功能，但已经准备好让框架采用。使用 Suspense，我们可以延迟渲染一个组件，直到满足某些条件，如从远程源加载数据。总的来说，React 18 的最新特性在很多方面提高了性能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023 年的 Npm 状态：概述]]></title>
        <id>https://blog.sandworm.dev/state-of-npm-2023-the-overview</id>
        <link href="https://blog.sandworm.dev/state-of-npm-2023-the-overview"/>
        <updated>2023-07-18T10:52:05.295Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.sandworm.dev/state-of-npm-2023-the-overview">State Of Npm 2023: The Overview</a></p><p><strong>概要：</strong></p><p>这篇文章是 "npm 状态 2023" 系列的一部分。在这个系列中，Sandworm 团队深入探讨了 npm 的当前状况，挖掘出了有趣的统计数据，并揭示了有关注册表的引人入胜的事实。

在软件开发的广阔领域中，一个名字已经成为 JavaScript 生态系统的代名词：npm。作为全球数百万开发者的首选包管理器，npm 在革新我们构建和分享 JavaScript 代码的方式上发挥了关键作用。随着其庞大的注册表不断收纳更多的包，npm 已经成为了一种不可或缺的工具，推动创新并赋予开发者轻松创建出色应用的能力。

在本系列中，Sandworm 团队深入探讨了 npm 的当前状况，挖掘出了有趣的统计数据，并揭示了有关注册表的引人入胜的事实。从包的数量到最受欢迎的库，我们将探索这个为 JavaScript 社区提供动力的强大工具的内部运作。让我们一起来更深入地了解 npm 的状态，并洞察其中的趋势、模式和充满活力的生态系统。

npm 的初始提交是由 Isaac Z. Schlueter（isaacs）在 2009 年 9 月 29 日推送的。它最初是一个在 VPS 上的单一 CouchDB 服务。"npm" 原本代表 "Node Package Manager"，但后来被改为递归的反向首字母缩写，意思是 "npm 不是首字母缩写"。npm 在 2014 年作为一家公司成立，当时它筹集了 260 万美元以持续资助其迅速增长的社</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - 0xpayne/gpt-migrate：轻松地将代码库从一个框架或语言迁移到另一个框架或语言。]]></title>
        <id>https://github.com/0xpayne/gpt-migrate</id>
        <link href="https://github.com/0xpayne/gpt-migrate"/>
        <updated>2023-07-18T08:16:27.616Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/0xpayne/gpt-migrate">GitHub - 0xpayne/gpt-migrate: Easily migrate your codebase from one framework or language to another.</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个名为 GPT-Migrate 的项目，该项目能够帮助用户轻松地将代码库从一个框架或语言迁移到另一个。尽管迁移是一个昂贵、繁琐且非平凡的问题，但借助开源社区的集体智慧和大型语言模型的当前状态，这个问题变得可以处理。GPT-Migrate 首先为目标语言创建一个 Docker 环境，然后评估现有代码以识别第三方依赖项，并选择相应的目标语言依赖项。接着，它从指定的源文件开始递归地构建新的目标语言代码。然后，它启动带有新代码库的 Docker 环境，并根据需要进行迭代调试。它使用 Python 的 unittest 框架开发单元测试，并可选择性地针对运行中的原始应用程序进行测试。最后，它会在日志、错误消息、相关文件和目录结构的上下文中为你迭代地调试代码。新的代码库完成后将存在于目标目录中。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[软件工程：解决问题和批判性思维]]></title>
        <id>https://addyosmani.com/blog/softeng-problem-solving/</id>
        <link href="https://addyosmani.com/blog/softeng-problem-solving/"/>
        <updated>2023-07-18T04:44:54.270Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/softeng-problem-solving/">Software engineering: problem-solving and critical-thinking</a></p><p><strong>概要：</strong></p><p>这篇文章强调了软件工程不仅仅是编码，更重要的是解决问题和批判性思考。软件工程被误解为只涉及编码，但实际上，它涉及到解决问题和批判性思考的方面，编码只是冰山一角，是分析严谨、抽象推理和创造性问题解决过程的具体输出。软件工程的核心不仅仅在于编码，更在于进行编码之前的过程。在软件工程中，每一个软件都是为了解决特定的问题或一系列问题而创建的，工程师首先需要理解他们需要解决的问题，然后概念化可能的解决方案。批判性思考是软件工程的基础，它涉及到对问题的客观分析和评估以形成判断，在设计阶段、实施阶段和测试阶段都需要应用批判性思考。总的来说，软件工程是解决问题和批判性思考的复杂结合，编码只是其表现形式。随着软件越来越深入地融入我们社会的结构中，软件工程师的角色也在扩大，他们不仅需要擅长编码，还必须是熟练的问题解决者和批判性思考者。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博雅发布 v0.17 - Boa]]></title>
        <id>https://boajs.dev/posts/2023-07-08-boa-release-17/</id>
        <link href="https://boajs.dev/posts/2023-07-08-boa-release-17/"/>
        <updated>2023-07-18T04:09:46.861Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://boajs.dev/posts/2023-07-08-boa-release-17/">Boa release v0.17 - Boa</a></p><p><strong>概要：</strong></p><p>Boa v0.17 已经发布，这是自项目开始以来最大的一次 Boa 发布。在大约 7 个月的开发后，我们很高兴向您展示 Boa JavaScript 引擎的最新版本。Boa 使得在你的项目中嵌入 JS 引擎变得简单，你甚至可以从 WebAssembly 中使用它。在此版本中，我们的符合性从官方 ECMAScript 测试套件（Test262）的 74.53% 增长到 78.74%，我们现在通过了比上一版本多 6079 个测试。此外，此版本的重大变化不在于符合性，而在于巨大的内部增强和新的 API。此次大规模发布部分得益于 Lit Protocol 的资助。此外，Boa 现在有了一个新的域名 boajs.dev。在此版本中，我们添加了 HostHooks 和 JobQueue 特性到 Context，这将允许主机实现自定义事件循环和其他主机特定功能。此外，Boa 现在有了国际化支持，尽管我们还在努力完全符合 ecma402 规范，但我们已经有了一些 Intl 工具。此版本的 Boa 还包含了一些新的功能，如 JsPromise, JsRegExp, JsGenerator, JsDate 和 JsDataView 等内置对象包装器。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不健康冲突与健康冲突]]></title>
        <id>https://addyosmani.com/blog/healthy-unhealthy-conflict/</id>
        <link href="https://addyosmani.com/blog/healthy-unhealthy-conflict/"/>
        <updated>2023-07-17T10:36:07.588Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/healthy-unhealthy-conflict/">Unhealthy conflict vs. healthy conflict</a></p><p><strong>概要：</strong></p><p>这篇文章探讨了健康冲突和不健康冲突的区别，以及如何利用冲突的积极方面促进成长。不健康的冲突以对抗性心态为特征，人们将彼此视为对手，重点在于个人胜利而非解决问题。健康的冲突则将分歧视为需要共同解决的问题，这种心态培养出合作和相互尊重的氛围。文章还提供了一些策略来培养健康冲突的文化，包括设定基本的尊重沟通原则、积极倾听他人的观点、使用 "I" 语句表达自己的感受和观察、寻找共同立场以及提供和接受妥协。健康的冲突可以成为促进成长的催化剂。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[尽可能长时间地坚持乏味的建筑风格]]></title>
        <id>https://addyosmani.com/blog/boring-architecture/</id>
        <link href="https://addyosmani.com/blog/boring-architecture/"/>
        <updated>2023-07-17T10:35:36.345Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://addyosmani.com/blog/boring-architecture/">Stick to boring architecture for as long as possible</a></p><p><strong>概要：</strong></p><p>Kelsey Hightower 建议在新项目开始时，尽可能坚持使用 "无聊" 的架构，并将大部分时间和资源投入到客户愿意付费的产品建设中。他认为，虽然工程师们天生对新奇的解决方案有吸引力，但是区分什么是激动人心的，什么是适合你的用例是至关重要的。通常，“无聊” 的技术 —— 那些稳定、被理解并且可能是上一代的工具 —— 有很多可以提供的。它们经过试验和测试，已证明可扩展性，且配有详细的文档和社区支持。在采用新技术之前，需要问自己：这是否解决了一个特定的问题或显著增强了我的产品？这是否值得学习曲线和潜在的不稳定性？这是否会在未来帮助我们？Hightower 还提出了 "创新点原则"，即每个项目都有一个 “创新点”，可以用来采用 “激动人心” 的技术或架构。这个单一的点迫使你做出深思熟虑的选择。除非新技术显然给你的项目增加了实质价值，否则应依赖于你知道的有效工作。最后，他建议从基于良好理解的技术的坚实基础开始你的项目，随着项目的发展和你对挑战的深入理解，评估是否有充分的理由引入更先进的技术。这是一种有意识的进展：从无聊开始，然后有策略地创新。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - tc39/proposal-defer-import-eval：关于引入模块延迟评估方法的建议]]></title>
        <id>https://github.com/tc39/proposal-defer-import-eval</id>
        <link href="https://github.com/tc39/proposal-defer-import-eval"/>
        <updated>2023-07-17T00:05:33.260Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/tc39/proposal-defer-import-eval">GitHub - tc39/proposal-defer-import-eval: A proposal for introducing a way to defer evaluate of a module</a></p><p><strong>概要：</strong></p><p>文章介绍了一种名为 "推迟模块评估"（曾被称为 "懒惰模块初始化"）的新技术，其目标是提高大型 JavaScript 应用程序的性能。这项技术旨在解决在应用程序初始化期间由于代码编写方式导致的 CPU 瓶颈问题。推迟模块评估的提案是引入一种新的语法形式，该形式只会返回一个命名空间异构对象。使用此形式时，模块及其依赖项不会被执行，但会在模块图被认为已加载之前完全加载到可执行状态。只有在访问此模块的属性时，才会执行执行操作（如果需要）。这样，模块命名空间异构对象就像是模块评估的代理，有效地触发同步评估并返回定义的绑定。然而，这项技术还存在一些问题，例如无法推迟执行使用顶级等待的模块的评估，以及在导入使用推迟导入语法的模块时，其异步依赖项及其自身的传递依赖项将被积极评估，只有图形的同步部分被推迟。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[交互设计的隐形细节]]></title>
        <id>https://rauno.me/craft/interaction-design</id>
        <link href="https://rauno.me/craft/interaction-design"/>
        <updated>2023-07-14T12:14:37.127Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://rauno.me/craft/interaction-design">Invisible Details of Interaction Design</a></p><p><strong>概要：</strong></p><p>这篇文章探讨了交互设计的科学性和直觉性，作者通过深入研究并试图解构出优秀的交互设计背后的原因。他认为，伟大的设计启示往往源于创造过程中遇到的问题，而不仅仅是坐下来深思熟虑。文章还分析了一些常用但很少被思考的交互细节，如隐喻、动态物理、滑动手势、反应式手势等，并强调了设计决策的重要性。作者认为，交互设计不仅需要形式和功能之间的平衡，也需要对人类行为的深入理解。此外，文章还讨论了如何通过反思和模仿界面来建立更强的设计直觉和词汇表，并提出了 “无输入” 即上下文作为输入的理念，以及 Fitts 定律等概念。最后，作者强调了理解和阐述为何某样东西感觉对的重要性，这有助于培养品味，提高执行水平，并增加对卓越追求的欣赏。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3种常见的测试自动化类型]]></title>
        <id>https://web.dev/ta-types/</id>
        <link href="https://web.dev/ta-types/"/>
        <updated>2023-07-14T01:01:52.841Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://web.dev/ta-types/">3 common types of test automation</a></p><p><strong>概要：</strong></p><p>这篇文章主要探讨了如何进行 web 开发测试，包括两种一般的测试模式和三种常见的自动化测试类型。首先，我们需要确定我们应用程序质量需要保证的部分以及如何实现。在开始编写实际的测试代码之前，我们需要有一个计划。本文主要关注的是如何进行测试。我们的主要目标是规划正确的测试策略，但我们将在这里介绍最初的步骤：让我们发现可以用来从共同基础开始的测试类型。手动测试和自动化测试是两种基本的测试方式，然后详细介绍了不透明盒子测试（又称黑盒测试）和清晰盒子测试（又称白盒测试）两种测试程序。接着，文章介绍了单元测试、集成测试、端到端测试、视觉 UI 测试和静态分析等五种测试类型。最后，文章提出了五种常见的测试策略：测试金字塔、测试钻石、测试冰锥、测试蜂巢和测试奖杯。在下一篇文章中，我们将更详细地讨论这些不同的策略，并解释如何为你的项目选择最合适的策略。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js中的矢量数据库入门]]></title>
        <id>https://thecodebarbarian.com/getting-started-with-vector-databases-in-node-js.html</id>
        <link href="https://thecodebarbarian.com/getting-started-with-vector-databases-in-node-js.html"/>
        <updated>2023-07-14T00:56:16.725Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://thecodebarbarian.com/getting-started-with-vector-databases-in-node-js.html">Getting Started with Vector Databases in Node.js</a></p><p><strong>概要：</strong></p><p>向量数据库是当前的热门话题，其结合 AI 工具如 ChatGPT，可以实现语义相似性搜索：找出与此物体相似的物品。这种搜索形式比基本搜索引擎或文本搜索更复杂，因为搜索算法能够解释文本的语义，而不仅仅是尝试匹配关键词。一个语义搜索的应用是主题分类：给定一段文本，确定预定列表中哪个类别最符合该文本。例如，给定句子 "apple jumped 10% today"，这句话是关于 "Food" 还是 "Stocks"？传统的关键词搜索在这种区别上会有困难，因为没有办法在不解释文本语义的情况下区分苹果（水果）和 Apple（公司）。本教程将指导你使用 Node.js 和一个名为 Chroma 的向量数据库来构建一个玩具主题分类工具。

要在本地运行 Chroma，你应该克隆 Chroma 的 GitHub 仓库，并按照以下方式运行他们的 docker-compose 文件。一旦你运行了 Chroma，如果你还没有 OpenAI 的密钥，你也应该获取一个。然后，你可以使用你的 OpenAI 密钥在 Chroma 中存储给定句子的嵌入。嵌入是表示给定文本特征的向量。

主题分类的一个简单方法是为每个主题插入一些样本文本的嵌入，对于任何给定的文本，找到最接近该文本的向量。例如，让我们使用 "apple jumped 10% today" 作为 "Stocks" 类别的代表，"i like apple pie" 作为 "Food" 类别的代表。以下代码为这两个句子生成嵌入，并将它们与相关类别的元数据一起插入</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[您应该在项目配置中包含的5个TS编译器标志]]></title>
        <id>https://egorkonovalov.github.io/flycatcher/posts/3/</id>
        <link href="https://egorkonovalov.github.io/flycatcher/posts/3/"/>
        <updated>2023-07-14T00:55:42.107Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://egorkonovalov.github.io/flycatcher/posts/3/">5 TS Compiler Flags You Should Include In Your Project's Config</a></p><p><strong>概要：</strong></p><p>新发布的 TypeScript 5.0 主要更新引入了许多重大变化，如稳定的装饰器，常规枚举被联合枚举替代等。但是，我在阅读发布说明时发现了一些新的编译器选项，这让我思考是否有理由设置自定义编译器设置？简短的答案是 - 是的。本文介绍了五个可以提高开发体验的 TypeScript 编译器标志：noImplicitOverride、noUncheckedIndexedAccess、noPropertyAccessFromIndexSignature、allowUnreachableCode 和 noFallthroughCasesInSwitch。通过利用这些编译器设置，你可以提高代码库的安全性、可读性和可维护性。虽然默认配置已经过测试并且可靠，但花时间探索和调整编译器设置可以提供宝贵的见解和优化。然而，必须在便利和定制之间找到平衡，尝试与团队讨论你将使用的风格，并构建所有人都喜欢的环境。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prettier 3.0: 你好, ECMAScript 模块！- 袩褉芯懈蟹胁芯写褋褌胁械薪薪褘械]]></title>
        <id>https://prettier.io/blog/2023/07/05/3.0.0.html</id>
        <link href="https://prettier.io/blog/2023/07/05/3.0.0.html"/>
        <updated>2023-07-14T00:53:38.099Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://prettier.io/blog/2023/07/05/3.0.0.html">Prettier 3.0: Hello, ECMAScript Modules! · Prettier</a></p><p><strong>概要：</strong></p><p>Prettier 团队发布了新版本，其中包括对 ECMAScript 模块的全面使用。这一改变极大地提高了开发体验。此次更新带来了一些重大变化，例如在 markdown 格式中，拉丁字符和中文或日文字符之间不再插入空格。另外，trailingComma 的默认值已更改为 "all"。此次发布还对插件接口进行了重大改造，现在 Prettier 支持使用 ECMAScript 模块和异步解析器编写的插件。此外，该版本还包括许多格式化改进和错误修复。如果你赞赏 Prettier 并希望支持我们的工作，请考虑直接通过我们的 OpenCollective 赞助我们，或者赞助我们依赖的项目，如 typescript-eslint、remark 和 Babel。感谢你的持续支持！</p>]]></content>
    </entry>
</feed>